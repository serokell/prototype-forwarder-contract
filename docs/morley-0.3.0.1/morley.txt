-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Developer tools for the Michelson Language
--   
--   A library to make writing smart contracts in Michelson — the smart
--   contract language of the Tezos blockchain — pleasant and effective.
@package morley
@version 0.3.0.1


-- | Commonly used parts of regular Prelude.
module Lorentz.Prelude

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
--   
--   Note that <tt>($)</tt> is levity-polymorphic in its result type, so
--   that foo $ True where foo :: Bool -&gt; Int# is well-typed
($) :: () => (a -> b) -> a -> b
infixr 0 $

-- | Function composition.
(.) :: () => (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | Infix application.
--   
--   <pre>
--   f :: Either String $ Maybe Int
--   =
--   f :: Either String (Maybe Int)
--   </pre>
type ($) (f :: k -> k1) (a :: k) = f a
infixr 2 $

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a

-- | The <a>Bounded</a> class is used to name the upper and lower limits of
--   a type. <a>Ord</a> is not a superclass of <a>Bounded</a> since types
--   that are not totally ordered may also have upper and lower bounds.
--   
--   The <a>Bounded</a> class may be derived for any enumeration type;
--   <a>minBound</a> is the first constructor listed in the <tt>data</tt>
--   declaration and <a>maxBound</a> is the last. <a>Bounded</a> may also
--   be derived for single-constructor datatypes whose constituent types
--   are in <a>Bounded</a>.
class Bounded a
minBound :: Bounded a => a
maxBound :: Bounded a => a

-- | The class of semigroups (types with an associative binary operation).
--   
--   Instances should satisfy the associativity law:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</pre></li>
--   </ul>
class Semigroup a

-- | An associative operation.
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = <tt>stimesIdempotent</tt></tt> or <tt>stimes =
--   <a>stimesIdempotentMonoid</a></tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a
infixr 6 <>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>x <a>&lt;&gt;</a> <a>mempty</a> = x</pre></li>
--   <li><pre><a>mempty</a> <a>&lt;&gt;</a> x = x</pre></li>
--   <li><tt>x <a>&lt;&gt;</a> (y <a>&lt;&gt;</a> z) = (x <a>&lt;&gt;</a>
--   y) <a>&lt;&gt;</a> z</tt> (<a>Semigroup</a> law)</li>
--   <li><pre><a>mconcat</a> = <a>foldr</a> '(&lt;&gt;)'
--   <a>mempty</a></pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <tt>Sum</tt> and <tt>Product</tt>.
--   
--   <b>NOTE</b>: <a>Semigroup</a> is a superclass of <a>Monoid</a> since
--   <i>base-4.11.0.0</i>.
class Semigroup a => Monoid a

-- | Identity of <a>mappend</a>
mempty :: Monoid a => a

-- | An associative operation
--   
--   <b>NOTE</b>: This method is redundant and has the default
--   implementation <tt><a>mappend</a> = '(&lt;&gt;)'</tt> since
--   <i>base-4.11.0.0</i>.
mappend :: Monoid a => a -> a -> a

-- | Fold a list using the monoid.
--   
--   For most types, the default definition for <a>mconcat</a> will be
--   used, but the function is included in the class definition so that an
--   optimized version can be provided for specific types.
mconcat :: Monoid a => [a] -> a

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <tt>id</tt>
--   <a>to</a> . <a>from</a> ≡ <tt>id</tt>
--   </pre>
class Generic a

-- | A space efficient, packed, unboxed Unicode text type.
data Text

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt>'undefined :: a'</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k) :: forall k. () => k -> Type
Proxy :: Proxy
fromString :: IsString a => String -> a

-- | <a>undefined</a> that leaves a warning in code on every usage.
undefined :: HasCallStack => a

-- | <a>error</a> that takes <a>Text</a> as an argument.
error :: HasCallStack => Text -> a


-- | Functions to check whether two values are equal if their types have
--   parameters and it's not statically known whether they these parameters
--   have the same types.
module Michelson.EqParam

-- | Suppose you have a data type <tt>X</tt> with parameter <tt>a</tt> and
--   you have two values: `x1 :: X a1` and `x2 :: X a2`. You can't compare
--   them using <a>==</a>, because they have different types. However, you
--   can compare them using <a>eqParam1</a> as long as both parameters are
--   <a>Typeable</a>.
eqParam1 :: forall a1 a2 t. (Typeable a1, Typeable a2, Eq (t a1)) => t a1 -> t a2 -> Bool

-- | Version of <a>eqParam1</a> for types with 2 parameters.
eqParam2 :: forall a1 a2 b1 b2 t. (Typeable a1, Typeable a2, Typeable b1, Typeable b2, Eq (t a1 b2)) => t a1 b1 -> t a2 b2 -> Bool

-- | Version of <a>eqParam1</a> for types with 3 parameters.
eqParam3 :: forall a1 a2 b1 b2 c1 c2 t. (Typeable a1, Typeable a2, Typeable b1, Typeable b2, Typeable c1, Typeable c2, Eq (t a1 b1 c1)) => t a1 b1 c1 -> t a2 b2 c2 -> Bool

module Michelson.ErrorPos
mkPos :: Int -> Pos
newtype Pos
Pos :: Word -> Pos
data SrcPos
SrcPos :: Pos -> Pos -> SrcPos
srcPos :: Word -> Word -> SrcPos
data InstrCallStack
InstrCallStack :: LetCallStack -> SrcPos -> InstrCallStack
[icsCallStack] :: InstrCallStack -> LetCallStack
[icsSrcPos] :: InstrCallStack -> SrcPos
type LetCallStack = [LetName]
newtype LetName
LetName :: Text -> LetName
instance Data.Data.Data Michelson.ErrorPos.InstrCallStack
instance GHC.Generics.Generic Michelson.ErrorPos.InstrCallStack
instance GHC.Show.Show Michelson.ErrorPos.InstrCallStack
instance GHC.Classes.Ord Michelson.ErrorPos.InstrCallStack
instance GHC.Classes.Eq Michelson.ErrorPos.InstrCallStack
instance GHC.Generics.Generic Michelson.ErrorPos.LetName
instance Data.Data.Data Michelson.ErrorPos.LetName
instance GHC.Show.Show Michelson.ErrorPos.LetName
instance GHC.Classes.Ord Michelson.ErrorPos.LetName
instance GHC.Classes.Eq Michelson.ErrorPos.LetName
instance Data.Data.Data Michelson.ErrorPos.SrcPos
instance GHC.Generics.Generic Michelson.ErrorPos.SrcPos
instance GHC.Show.Show Michelson.ErrorPos.SrcPos
instance GHC.Classes.Ord Michelson.ErrorPos.SrcPos
instance GHC.Classes.Eq Michelson.ErrorPos.SrcPos
instance Data.Data.Data Michelson.ErrorPos.Pos
instance GHC.Generics.Generic Michelson.ErrorPos.Pos
instance GHC.Show.Show Michelson.ErrorPos.Pos
instance GHC.Classes.Ord Michelson.ErrorPos.Pos
instance GHC.Classes.Eq Michelson.ErrorPos.Pos
instance Data.Default.Class.Default Michelson.ErrorPos.InstrCallStack
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.ErrorPos.InstrCallStack
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.ErrorPos.InstrCallStack
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.ErrorPos.LetName
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.ErrorPos.LetName
instance Data.Default.Class.Default Michelson.ErrorPos.SrcPos
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.ErrorPos.SrcPos
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.ErrorPos.SrcPos
instance Data.Default.Class.Default Michelson.ErrorPos.Pos
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.ErrorPos.Pos
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.ErrorPos.Pos

module Michelson.Printer.Util

-- | Generalize converting a type into a Text.PrettyPrint.Leijen.Text.Doc.
--   Used to pretty print Michelson code and define Fmt.Buildable
--   instances.
class RenderDoc a
renderDoc :: RenderDoc a => a -> Doc

-- | Whether a value can be represented in Michelson code. Normally either
--   all values of some type are renderable or not renderable. However, in
--   case of instructions we have extra instructions which should not be
--   rendered. Note: it's not suficcient to just return <a>mempty</a> for
--   such instructions, because sometimes we want to print lists of
--   instructions and we need to ignore them complete (to avoid putting
--   redundant separators).
isRenderable :: RenderDoc a => a -> Bool

-- | A new type that can wrap values so that the RenderDoc instances of the
--   combined value can have a different behavior for the pretty printer.
newtype Prettier a
Prettier :: a -> Prettier a

-- | Convert <a>Doc</a> to <a>Text</a> with a line width of 80.
printDoc :: Bool -> Doc -> Text

-- | Generic way to render the different op types that get passed to a
--   contract.
renderOps :: RenderDoc op => Bool -> NonEmpty op -> Doc
renderOpsList :: RenderDoc op => Bool -> [op] -> Doc

-- | Create a specific number of spaces.
spaces :: Int -> Doc

-- | Wrap documents in parentheses if there are two or more in the list.
wrapInParens :: NonEmpty Doc -> Doc

-- | Turn something that is instance of <a>RenderDoc</a> into a
--   <a>Builder</a>. It's formatted the same way as <a>printDoc</a> formats
--   docs.
buildRenderDoc :: RenderDoc a => a -> Builder


-- | Testing utility functions used by testing framework itself or intended
--   to be used by test writers.
module Michelson.Test.Util
leftToShowPanic :: (Show e, HasCallStack) => Either e a -> a
leftToPrettyPanic :: (Buildable e, HasCallStack) => Either e a -> a

-- | A <a>Property</a> that always failes with given message.
failedProp :: Text -> Property

-- | A <a>Property</a> that always succeeds.
succeededProp :: Property

-- | The <a>Property</a> holds on `Left a`.
qcIsLeft :: Show b => Either a b -> Property

-- | The <a>Property</a> holds on `Right b`.
qcIsRight :: Show a => Either a b -> Property

module Michelson.Typed.Haskell.Instr.Helpers

-- | Which branch to choose in generic tree representation: left, straight
--   or right. <a>S</a> is used when there is one constructor with one
--   field (something newtype-like).
--   
--   The reason why we need <a>S</a> can be explained by this example: data
--   A = A1 B | A2 Integer data B = B Bool Now we may search for A1
--   constructor or B constructor. Without <a>S</a> in both cases path will
--   be the same ([L]).
data Branch
L :: Branch
S :: Branch
R :: Branch

-- | Path to a leaf (some field or constructor) in generic tree
--   representation.
type Path = [Branch]

-- | Split a record into two pieces.
class RSplit (l :: [k]) (r :: [k])
rsplit :: forall f. RSplit l r => Rec f (l ++ r) -> (Rec f l, Rec f r)
instance forall k (r :: [k]). Michelson.Typed.Haskell.Instr.Helpers.RSplit '[] r
instance forall k (ls :: [k]) (r :: [k]) (l :: k). Michelson.Typed.Haskell.Instr.Helpers.RSplit ls r => Michelson.Typed.Haskell.Instr.Helpers.RSplit (l : ls) r


-- | Michelson annotations in untyped model.
module Michelson.Untyped.Annotation
newtype Annotation tag
Annotation :: Text -> Annotation tag
pattern WithAnn :: Annotation tag -> Annotation tag
type TypeAnn = Annotation TypeTag
type FieldAnn = Annotation FieldTag
type VarAnn = Annotation VarTag

-- | Typeclass for printing annotations, <tt>renderAnn</tt> prints empty
--   prefix in case of <tt>noAnn</tt>.
--   
--   Such functionality is required in case when instruction has two
--   annotations of the same type, former is empty and the latter is not.
--   So that `PAIR noAnn noAnn noAnn %kek` is printed as `PAIR % %kek`
class RenderAnn t
renderAnn :: RenderAnn t => t -> Doc
noAnn :: Annotation a
ann :: Text -> Annotation a
unifyAnn :: Annotation tag -> Annotation tag -> Maybe (Annotation tag)
ifAnnUnified :: Annotation tag -> Annotation tag -> Bool
disjoinVn :: VarAnn -> (VarAnn, VarAnn)
convAnn :: Annotation tag1 -> Annotation tag2
instance forall k (tag :: k). Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Annotation.Annotation tag)
instance forall k (tag :: k). Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Annotation.Annotation tag)
instance forall k (tag :: k). Data.String.IsString (Michelson.Untyped.Annotation.Annotation tag)
instance forall k (tag :: k). GHC.Generics.Generic (Michelson.Untyped.Annotation.Annotation tag)
instance GHC.Base.Functor Michelson.Untyped.Annotation.Annotation
instance forall k (tag :: k). (Data.Typeable.Internal.Typeable tag, Data.Typeable.Internal.Typeable k) => Data.Data.Data (Michelson.Untyped.Annotation.Annotation tag)
instance forall k (tag :: k). GHC.Classes.Eq (Michelson.Untyped.Annotation.Annotation tag)
instance Michelson.Untyped.Annotation.RenderAnn Michelson.Untyped.Annotation.TypeAnn
instance Michelson.Untyped.Annotation.RenderAnn Michelson.Untyped.Annotation.FieldAnn
instance Michelson.Untyped.Annotation.RenderAnn Michelson.Untyped.Annotation.VarAnn
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Annotation.VarAnn
instance Formatting.Buildable.Buildable Michelson.Untyped.Annotation.VarAnn
instance GHC.Base.Semigroup Michelson.Untyped.Annotation.VarAnn
instance GHC.Base.Monoid Michelson.Untyped.Annotation.VarAnn
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Annotation.FieldAnn
instance Formatting.Buildable.Buildable Michelson.Untyped.Annotation.FieldAnn
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Annotation.TypeAnn
instance Formatting.Buildable.Buildable Michelson.Untyped.Annotation.TypeAnn
instance GHC.Show.Show (Michelson.Untyped.Annotation.Annotation Michelson.Untyped.Annotation.VarTag)
instance GHC.Show.Show (Michelson.Untyped.Annotation.Annotation Michelson.Untyped.Annotation.FieldTag)
instance GHC.Show.Show (Michelson.Untyped.Annotation.Annotation Michelson.Untyped.Annotation.TypeTag)
instance forall k (tag :: k). Data.Default.Class.Default (Michelson.Untyped.Annotation.Annotation tag)


-- | Michelson types represented in untyped model.
module Michelson.Untyped.Type
data Type
Type :: T -> TypeAnn -> Type

-- | Implicit Parameter type which can be used in contract code
TypeParameter :: Type

-- | Implicit Storage type which can be used in contract code
TypeStorage :: Type
data Comparable
Comparable :: CT -> TypeAnn -> Comparable
compToType :: Comparable -> Type
typeToComp :: Type -> Maybe Comparable
data T
Tc :: CT -> T
TKey :: T
TUnit :: T
TSignature :: T
TOption :: FieldAnn -> Type -> T
TList :: Type -> T
TSet :: Comparable -> T
TOperation :: T
TContract :: Type -> T
TPair :: FieldAnn -> FieldAnn -> Type -> Type -> T
TOr :: FieldAnn -> FieldAnn -> Type -> Type -> T
TLambda :: Type -> Type -> T
TMap :: Comparable -> Type -> T
TBigMap :: Comparable -> Type -> T
data CT
CInt :: CT
CNat :: CT
CString :: CT
CBytes :: CT
CMutez :: CT
CBool :: CT
CKeyHash :: CT
CTimestamp :: CT
CAddress :: CT
pattern Tint :: T
pattern Tnat :: T
pattern Tstring :: T
pattern Tbytes :: T
pattern Tmutez :: T
pattern Tbool :: T
pattern Tkey_hash :: T
pattern Ttimestamp :: T
pattern Taddress :: T
tint :: T
tnat :: T
tstring :: T
tbytes :: T
tmutez :: T
tbool :: T
tkeyHash :: T
ttimestamp :: T
taddress :: T
toption :: Type -> T
tpair :: Type -> Type -> T
tor :: Type -> Type -> T
tyint :: Type
tynat :: Type
tyunit :: Type
tybool :: Type
typair :: Type -> Type -> Type
tyor :: Type -> Type -> Type
isAtomicType :: Type -> Bool
isKey :: Type -> Bool
isSignature :: Type -> Bool
isComparable :: Type -> Bool
isMutez :: Type -> Bool
isKeyHash :: Type -> Bool
isBool :: Type -> Bool
isString :: Type -> Bool
isInteger :: Type -> Bool
isTimestamp :: Type -> Bool
isNat :: Type -> Bool
isInt :: Type -> Bool
isBytes :: Type -> Bool
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Type.CT
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Type.CT
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Type.T
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Type.T
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Type.Comparable
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Type.Comparable
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Type.Type
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Type.Type
instance GHC.Generics.Generic Michelson.Untyped.Type.Type
instance Data.Data.Data Michelson.Untyped.Type.Type
instance GHC.Show.Show Michelson.Untyped.Type.Type
instance GHC.Classes.Eq Michelson.Untyped.Type.Type
instance GHC.Generics.Generic Michelson.Untyped.Type.T
instance Data.Data.Data Michelson.Untyped.Type.T
instance GHC.Show.Show Michelson.Untyped.Type.T
instance GHC.Classes.Eq Michelson.Untyped.Type.T
instance GHC.Generics.Generic Michelson.Untyped.Type.Comparable
instance Data.Data.Data Michelson.Untyped.Type.Comparable
instance GHC.Show.Show Michelson.Untyped.Type.Comparable
instance GHC.Classes.Eq Michelson.Untyped.Type.Comparable
instance GHC.Generics.Generic Michelson.Untyped.Type.CT
instance GHC.Enum.Bounded Michelson.Untyped.Type.CT
instance GHC.Enum.Enum Michelson.Untyped.Type.CT
instance Data.Data.Data Michelson.Untyped.Type.CT
instance GHC.Show.Show Michelson.Untyped.Type.CT
instance GHC.Classes.Ord Michelson.Untyped.Type.CT
instance GHC.Classes.Eq Michelson.Untyped.Type.CT
instance Michelson.Printer.Util.RenderDoc (Michelson.Printer.Util.Prettier Michelson.Untyped.Type.Type)
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Type.Type
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Type.T
instance Formatting.Buildable.Buildable Michelson.Untyped.Type.Type
instance Formatting.Buildable.Buildable Michelson.Untyped.Type.T
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Type.Comparable
instance Formatting.Buildable.Buildable Michelson.Untyped.Type.Comparable
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Type.CT
instance Formatting.Buildable.Buildable Michelson.Untyped.Type.CT

module Michelson.Untyped.Ext

-- | Implementation-specific instructions embedded in a <tt>NOP</tt>
--   primitive, which mark a specific point during a contract's
--   typechecking or execution.
--   
--   These instructions are not allowed to modify the contract's stack, but
--   may impose additional constraints that can cause a contract to report
--   errors in type-checking or testing.
--   
--   Additionaly, some implementation-specific language features such as
--   type-checking of <tt>LetMacro</tt>s are implemented using this
--   mechanism (specifically <tt>FN</tt> and <tt>FN_END</tt>).
data ExtInstrAbstract op

-- | Matches current stack against a type-pattern
STACKTYPE :: StackTypePattern -> ExtInstrAbstract op

-- | A typed stack function (push and pop a <tt>TcExtFrame</tt>)
FN :: Text -> StackFn -> [op] -> ExtInstrAbstract op

-- | Copy the current stack and run an inline assertion on it
UTEST_ASSERT :: TestAssert op -> ExtInstrAbstract op

-- | Print a comment with optional embedded <tt>StackRef</tt>s
UPRINT :: PrintComment -> ExtInstrAbstract op

-- | A reference into the stack.
newtype StackRef
StackRef :: Natural -> StackRef
newtype PrintComment
PrintComment :: [Either Text StackRef] -> PrintComment
[unUPrintComment] :: PrintComment -> [Either Text StackRef]
data TestAssert op
TestAssert :: Text -> PrintComment -> [op] -> TestAssert op
[tassName] :: TestAssert op -> Text
[tassComment] :: TestAssert op -> PrintComment
[tassInstrs] :: TestAssert op -> [op]
newtype Var
Var :: Text -> Var

-- | A type-variable or a type-constant
data TyVar
VarID :: Var -> TyVar
TyCon :: Type -> TyVar

-- | A stack pattern-match
data StackTypePattern
StkEmpty :: StackTypePattern
StkRest :: StackTypePattern
StkCons :: TyVar -> StackTypePattern -> StackTypePattern

-- | A stack function that expresses the type signature of a
--   <tt>LetMacro</tt>
data StackFn
StackFn :: Maybe (Set Var) -> StackTypePattern -> StackTypePattern -> StackFn
[quantifiedVars] :: StackFn -> Maybe (Set Var)
[inPattern] :: StackFn -> StackTypePattern
[outPattern] :: StackFn -> StackTypePattern

-- | Get the set of variables in a stack pattern
varSet :: StackTypePattern -> Set Var

-- | Convert <a>StackTypePattern</a> to a list of types. Also returns
--   <a>Bool</a> which is <a>True</a> if the pattern is a fixed list of
--   types and <a>False</a> if it's a pattern match on the head of the
--   stack.
stackTypePatternToList :: StackTypePattern -> ([TyVar], Bool)
instance Data.Aeson.Types.ToJSON.ToJSON op => Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Ext.TestAssert op)
instance Data.Aeson.Types.FromJSON.FromJSON op => Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Ext.TestAssert op)
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Ext.TyVar
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Ext.TyVar
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Ext.Var
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Ext.Var
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Ext.StackFn
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Ext.StackFn
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Ext.StackRef
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Ext.StackRef
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Ext.StackTypePattern
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Ext.StackTypePattern
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Ext.PrintComment
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Ext.PrintComment
instance Data.Aeson.Types.ToJSON.ToJSON op => Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance Data.Aeson.Types.FromJSON.FromJSON op => Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance GHC.Base.Functor Michelson.Untyped.Ext.ExtInstrAbstract
instance GHC.Generics.Generic (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance Data.Data.Data op => Data.Data.Data (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance GHC.Show.Show op => GHC.Show.Show (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance GHC.Classes.Eq op => GHC.Classes.Eq (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance GHC.Generics.Generic (Michelson.Untyped.Ext.TestAssert op)
instance Data.Data.Data op => Data.Data.Data (Michelson.Untyped.Ext.TestAssert op)
instance GHC.Base.Functor Michelson.Untyped.Ext.TestAssert
instance GHC.Show.Show op => GHC.Show.Show (Michelson.Untyped.Ext.TestAssert op)
instance GHC.Classes.Eq op => GHC.Classes.Eq (Michelson.Untyped.Ext.TestAssert op)
instance GHC.Generics.Generic Michelson.Untyped.Ext.PrintComment
instance Data.Data.Data Michelson.Untyped.Ext.PrintComment
instance GHC.Show.Show Michelson.Untyped.Ext.PrintComment
instance GHC.Classes.Eq Michelson.Untyped.Ext.PrintComment
instance GHC.Generics.Generic Michelson.Untyped.Ext.StackFn
instance Data.Data.Data Michelson.Untyped.Ext.StackFn
instance GHC.Show.Show Michelson.Untyped.Ext.StackFn
instance GHC.Classes.Eq Michelson.Untyped.Ext.StackFn
instance GHC.Generics.Generic Michelson.Untyped.Ext.StackTypePattern
instance Data.Data.Data Michelson.Untyped.Ext.StackTypePattern
instance GHC.Show.Show Michelson.Untyped.Ext.StackTypePattern
instance GHC.Classes.Eq Michelson.Untyped.Ext.StackTypePattern
instance GHC.Generics.Generic Michelson.Untyped.Ext.TyVar
instance Data.Data.Data Michelson.Untyped.Ext.TyVar
instance GHC.Show.Show Michelson.Untyped.Ext.TyVar
instance GHC.Classes.Eq Michelson.Untyped.Ext.TyVar
instance GHC.Generics.Generic Michelson.Untyped.Ext.Var
instance Data.Data.Data Michelson.Untyped.Ext.Var
instance GHC.Classes.Ord Michelson.Untyped.Ext.Var
instance GHC.Show.Show Michelson.Untyped.Ext.Var
instance GHC.Classes.Eq Michelson.Untyped.Ext.Var
instance GHC.Generics.Generic Michelson.Untyped.Ext.StackRef
instance Data.Data.Data Michelson.Untyped.Ext.StackRef
instance GHC.Show.Show Michelson.Untyped.Ext.StackRef
instance GHC.Classes.Eq Michelson.Untyped.Ext.StackRef
instance Michelson.Printer.Util.RenderDoc op => Michelson.Printer.Util.RenderDoc (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance Formatting.Buildable.Buildable op => Formatting.Buildable.Buildable (Michelson.Untyped.Ext.ExtInstrAbstract op)
instance Formatting.Buildable.Buildable code => Formatting.Buildable.Buildable (Michelson.Untyped.Ext.TestAssert code)
instance Formatting.Buildable.Buildable Michelson.Untyped.Ext.PrintComment
instance Formatting.Buildable.Buildable Michelson.Untyped.Ext.StackFn
instance Formatting.Buildable.Buildable Michelson.Untyped.Ext.StackTypePattern
instance Formatting.Buildable.Buildable Michelson.Untyped.Ext.TyVar
instance Formatting.Buildable.Buildable Michelson.Untyped.Ext.Var
instance Formatting.Buildable.Buildable Michelson.Untyped.Ext.StackRef


-- | Michelson contract in untyped model.
module Michelson.Untyped.Contract
type Parameter = Type
type Storage = Type
data Contract' op
Contract :: Parameter -> Storage -> [op] -> Contract' op
[para] :: Contract' op -> Parameter
[stor] :: Contract' op -> Storage
[code] :: Contract' op -> [op]
instance Data.Aeson.Types.ToJSON.ToJSON op => Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Contract.Contract' op)
instance Data.Aeson.Types.FromJSON.FromJSON op => Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Contract.Contract' op)
instance GHC.Generics.Generic (Michelson.Untyped.Contract.Contract' op)
instance Data.Data.Data op => Data.Data.Data (Michelson.Untyped.Contract.Contract' op)
instance GHC.Base.Functor Michelson.Untyped.Contract.Contract'
instance GHC.Show.Show op => GHC.Show.Show (Michelson.Untyped.Contract.Contract' op)
instance GHC.Classes.Eq op => GHC.Classes.Eq (Michelson.Untyped.Contract.Contract' op)
instance Michelson.Printer.Util.RenderDoc op => Michelson.Printer.Util.RenderDoc (Michelson.Untyped.Contract.Contract' op)
instance Michelson.Printer.Util.RenderDoc op => Formatting.Buildable.Buildable (Michelson.Untyped.Contract.Contract' op)


-- | Module, providing <a>CT</a> and <a>T</a> data types, representing
--   Michelson language types without annotations.
module Michelson.Typed.T
data CT
CInt :: CT
CNat :: CT
CString :: CT
CBytes :: CT
CMutez :: CT
CBool :: CT
CKeyHash :: CT
CTimestamp :: CT
CAddress :: CT

-- | Michelson language type with annotations stripped off.
data T
Tc :: CT -> T
TKey :: T
TUnit :: T
TSignature :: T
TOption :: T -> T
TList :: T -> T
TSet :: CT -> T
TOperation :: T
TContract :: T -> T
TPair :: T -> T -> T
TOr :: T -> T -> T
TLambda :: T -> T -> T
TMap :: CT -> T -> T
TBigMap :: CT -> T -> T
instance GHC.Show.Show Michelson.Typed.T.T
instance GHC.Classes.Eq Michelson.Typed.T.T


-- | Module, providing singleton boilerplate for <a>T</a> and <a>CT</a>
--   data types.
--   
--   Some functions from Data.Singletons are provided alternative version
--   here. Some instances which are usually generated with TH are manually
--   implemented as they require some specific constraints, namely
--   <a>Typeable</a> and/or <tt>Converge</tt>, not provided in instances
--   generated by TH.
module Michelson.Typed.Sing

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type

-- | Version of <tt>withSomeSing</tt> with <a>Typeable</a> constraint
--   provided to processing function.
--   
--   Required for not to erase these useful constraints when doing
--   conversion from value of type <a>T</a> to its singleton
--   representation.
withSomeSingT :: T -> (forall (a :: T). (Typeable a, SingI a) => Sing a -> r) -> r

-- | Version of <tt>withSomeSing</tt> with <a>Typeable</a> constraint
--   provided to processing function.
--   
--   Required for not to erase this useful constraint when doing conversion
--   from value of type <a>CT</a> to its singleton representation.
withSomeSingCT :: CT -> (forall (a :: CT). (SingI a, Typeable a) => Sing a -> r) -> r

-- | Version of <a>fromSing</a> specialized for use with <tt>data instance
--   Sing :: T -&gt; Type</tt> which requires <a>Typeable</a> constraint
--   for some of its constructors
fromSingT :: Sing (a :: T) -> T
fromSingCT :: Sing (a :: CT) -> CT
instance Data.Singletons.Internal.SingKind Michelson.Typed.T.T
instance Data.Singletons.Internal.SingKind Michelson.Untyped.Type.CT
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CInt
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CNat
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CString
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CBytes
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CMutez
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CBool
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CKeyHash
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CTimestamp
instance Data.Singletons.Internal.SingI 'Michelson.Untyped.Type.CAddress
instance (Data.Singletons.Internal.SingI t, Data.Typeable.Internal.Typeable t) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.Tc t)
instance Data.Singletons.Internal.SingI 'Michelson.Typed.T.TKey
instance Data.Singletons.Internal.SingI 'Michelson.Typed.T.TUnit
instance Data.Singletons.Internal.SingI 'Michelson.Typed.T.TSignature
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TOption a)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TList a)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TSet a)
instance Data.Singletons.Internal.SingI 'Michelson.Typed.T.TOperation
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TContract a)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Singletons.Internal.SingI b) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TPair a b)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Singletons.Internal.SingI b) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TOr a b)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Singletons.Internal.SingI b) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TLambda a b)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Singletons.Internal.SingI b) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TMap a b)
instance (Data.Singletons.Internal.SingI a, Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.Singletons.Internal.SingI b) => Data.Singletons.Internal.SingI ('Michelson.Typed.T.TBigMap a b)


-- | Module, containing restrictions imposed by instruction or value scope.
module Michelson.Typed.Scope
type AllowBigMap t = FailOnBigMapFound (BadBigMapPair t)

-- | Constraint which ensures that bigmap does not appear in a given type.
class (ContainsBigMap t ~  'False) => HasNoBigMap t

-- | Constraint which ensures that operation type does not appear in a
--   given type.
--   
--   Not just a type alias in order to be able to partially apply it (e.g.
--   in <a>Each</a>).
class (ContainsOp t ~  'False) => HasNoOp t
type ForbidBigMap t = FailOnBigMapFound (ContainsBigMap t)

-- | This is like <a>HasNoOp</a>, it raises a more human-readable error
--   when <tt>t</tt> type is concrete, but you cannot easily extract a
--   proof of no-operation-presence from it.
--   
--   Use it in our eDSL.
type ForbidOp t = FailOnOperationFound (ContainsOp t)
data BigMapPresence (t :: T)
BigMapPresent :: BigMapPresence
BigMapAbsent :: BigMapPresence

-- | Whether the type contains <a>TOperation</a>, with proof.
data OpPresence (t :: T)
OpPresent :: OpPresence
OpAbsent :: OpPresence

-- | Constraint which ensures, that <tt>t</tt> can be used as type of
--   contract storage so it optionally has bigmap only on the left of its
--   toplevel pair
type BigMapConstraint t = BadBigMapPair t ~  'False

-- | Check at runtime whether the given type contains <a>TOperation</a>.
checkOpPresence :: Sing (ty :: T) -> OpPresence ty

-- | Check at runtime whether the given type contains <a>TBigMap</a>.
checkBigMapPresence :: Sing (ty :: T) -> BigMapPresence ty
checkBigMapConstraint :: forall t a. (SingI t, AllowBigMap t) => (BigMapConstraint t => a) -> a

-- | Check at runtime that the given type does not contain
--   <a>TOperation</a>.
opAbsense :: Sing (t :: T) -> Maybe (Dict $ HasNoOp t)

-- | Check at runtime that the given type does not containt <a>TBigMap</a>
bigMapAbsense :: Sing (t :: T) -> Maybe (Dict $ HasNoBigMap t)

-- | Reify <a>HasNoOp</a> contraint from <a>ForbidOp</a>.
forbiddenOp :: forall t a. (SingI t, ForbidOp t) => (HasNoOp t => a) -> a
forbiddenBigMap :: forall t a. (SingI t, ForbidBigMap t) => (HasNoBigMap t => a) -> a

-- | Check at runtime that the given type optionally has bigmap only on the
--   left of its toplevel pair, which is actuall constraint for bigmap
--   appearance in the storage
bigMapConstrained :: Sing (t :: T) -> Maybe (Dict $ BigMapConstraint t)
instance (Michelson.Typed.Scope.ContainsBigMap t Data.Type.Equality.~ 'GHC.Types.False) => Michelson.Typed.Scope.HasNoBigMap t
instance (Michelson.Typed.Scope.ContainsOp t Data.Type.Equality.~ 'GHC.Types.False) => Michelson.Typed.Scope.HasNoOp t


-- | Module, providing <tt>Notes t</tt> data type, which holds annotations
--   for a given type <tt>t</tt>.
--   
--   Annotation type <tt>Notes t</tt> is a tree, each leaf is either a star
--   (<tt>*</tt>) or a constructor holding some annotation data for a given
--   type <tt>t</tt>. Star corresponds to the case when given Michelson
--   type contains no annotations.
--   
--   This module also provides type class <tt>Converge</tt> along with some
--   utility functions which are used to combine two annotations trees
--   <tt>a</tt> and <tt>b</tt> into a new one <tt>c</tt> in such a way that
--   <tt>c</tt> can be obtained from both <tt>a</tt> and <tt>b</tt> by
--   replacing some <tt>*</tt> leafs with type or/and field annotations.
module Michelson.Typed.Annotation

-- | Data type, holding annotation data for a given Michelson type
--   <tt>t</tt> or <tt>*</tt> in case no data is provided for the tree.
--   
--   There is a little semantical duplication between data type
--   constructors. Semantics behind <a>NStar</a> constructor are exactly
--   same as semantics behind <a>N</a> constructor with relevant
--   <a>Notes'</a> constructor be given all default values (which means all
--   annotations are empty).
--   
--   Constructor <a>NStar</a> is given as a tiny optimization to allow
--   handling no-annotation case completely for free (see <a>converge</a>
--   and <a>mkNotes</a> functions).
data Notes t
N :: Notes' t -> Notes t
NStar :: Notes t

-- | Data type, holding annotation data for a given Michelson type
--   <tt>t</tt>.
--   
--   Each constructor corresponds to exactly one constructor of <a>T</a>
--   and holds all type and field annotations that can be attributed to a
--   Michelson type corrspoding to <tt>t</tt>.
data Notes' t
[NTc] :: TypeAnn -> Notes' ( 'Tc ct)
[NTKey] :: TypeAnn -> Notes'  'TKey
[NTUnit] :: TypeAnn -> Notes'  'TUnit
[NTSignature] :: TypeAnn -> Notes'  'TSignature
[NTOption] :: TypeAnn -> FieldAnn -> Notes t -> Notes' ( 'TOption t)
[NTList] :: TypeAnn -> Notes t -> Notes' ( 'TList t)
[NTSet] :: TypeAnn -> TypeAnn -> Notes' ( 'TSet ct)
[NTOperation] :: TypeAnn -> Notes'  'TOperation
[NTContract] :: TypeAnn -> Notes t -> Notes' ( 'TContract t)
[NTPair] :: TypeAnn -> FieldAnn -> FieldAnn -> Notes p -> Notes q -> Notes' ( 'TPair p q)
[NTOr] :: TypeAnn -> FieldAnn -> FieldAnn -> Notes p -> Notes q -> Notes' ( 'TOr p q)
[NTLambda] :: TypeAnn -> Notes p -> Notes q -> Notes' ( 'TLambda p q)
[NTMap] :: TypeAnn -> TypeAnn -> Notes v -> Notes' ( 'TMap k v)
[NTBigMap] :: TypeAnn -> TypeAnn -> Notes v -> Notes' ( 'TBigMap k v)
data AnnConvergeError
[AnnConvergeError] :: forall (tag :: Type). (Buildable (Annotation tag), Show (Annotation tag), Typeable tag) => Annotation tag -> Annotation tag -> AnnConvergeError

-- | Same as <a>converge'</a> but works with <a>Notes</a> data type.
converge :: Notes t -> Notes t -> Either AnnConvergeError (Notes t)

-- | Converge two type or field notes (which may be wildcards).
convergeAnns :: forall (tag :: Type). (Buildable (Annotation tag), Show (Annotation tag), Typeable tag) => Annotation tag -> Annotation tag -> Either AnnConvergeError (Annotation tag)

-- | Helper function for work with <a>Notes</a> data type.
--   
--   <pre>
--   notesCase f g notes
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   case notes of
--     NStar -&gt; f
--     N v -&gt; g v
--   </pre>
notesCase :: r -> (Notes' t -> r) -> Notes t -> r

-- | Check whether given annotations object is <tt>*</tt>.
isStar :: Notes t -> Bool

-- | Checks whether given notes <tt>n</tt> can be immediately converted to
--   star and returns either <tt>NStar</tt> or <tt>N n</tt>.
--   
--   Given <tt>n :: Notes' t</tt> can be immediately converted to star iff
--   all nested <tt>(sn :: Notes t) == NStar</tt> and for each annotation
--   <tt>an</tt>: <tt>an == def</tt>.
mkNotes :: Notes' t -> Notes t
orAnn :: Annotation t -> Annotation t -> Annotation t
instance GHC.Classes.Eq (Michelson.Typed.Annotation.Notes t)
instance GHC.Show.Show (Michelson.Typed.Annotation.Notes p)
instance GHC.Show.Show (Michelson.Typed.Annotation.Notes' t)
instance GHC.Classes.Eq (Michelson.Typed.Annotation.Notes' t)
instance GHC.Show.Show Michelson.Typed.Annotation.AnnConvergeError
instance GHC.Classes.Eq Michelson.Typed.Annotation.AnnConvergeError
instance Formatting.Buildable.Buildable Michelson.Typed.Annotation.AnnConvergeError


-- | Core primitive Tezos types.
module Tezos.Core

-- | Mutez is a wrapper over integer data type. 1 mutez is 1 token (μTz).
data Mutez

-- | Safely create <a>Mutez</a> checking for overflow.
mkMutez :: Word64 -> Maybe Mutez

-- | Partial function for <a>Mutez</a> creation, it's pre-condition is that
--   the argument must not exceed the maximal <a>Mutez</a> value.
unsafeMkMutez :: HasCallStack => Word64 -> Mutez

-- | Safely create <a>Mutez</a>.
--   
--   This is recommended way to create <tt>Mutez</tt> from a numeric
--   literal; you can't construct all valid <tt>Mutez</tt> values using
--   this function but for small values it works neat.
--   
--   Warnings displayed when trying to construct invalid <a>Natural</a> or
--   <a>Word</a> literal are hardcoded for these types in GHC
--   implementation, so we can only exploit these existing rules.
toMutez :: Word32 -> Mutez

-- | Addition of <a>Mutez</a> values. Returns <a>Nothing</a> in case of
--   overflow.
addMutez :: Mutez -> Mutez -> Maybe Mutez

-- | Partial addition of <a>Mutez</a>, should be used only if you're sure
--   there'll be no overflow.
unsafeAddMutez :: HasCallStack => Mutez -> Mutez -> Mutez

-- | Subtraction of <a>Mutez</a> values. Returns <a>Nothing</a> when the
--   subtrahend is greater than the minuend, and <a>Just</a> otherwise.
subMutez :: Mutez -> Mutez -> Maybe Mutez

-- | Partial subtraction of <a>Mutez</a>, should be used only if you're
--   sure there'll be no underflow.
unsafeSubMutez :: HasCallStack => Mutez -> Mutez -> Mutez

-- | Multiplication of <a>Mutez</a> and an integral number. Returns
--   <a>Nothing</a> in case of overflow.
mulMutez :: Integral a => Mutez -> a -> Maybe Mutez

-- | Euclidian division of two <a>Mutez</a> values.
divModMutez :: Mutez -> Mutez -> Maybe (Word64, Mutez)

-- | Euclidian division of <a>Mutez</a> and a number.
divModMutezInt :: Integral a => Mutez -> a -> Maybe (Mutez, Mutez)

-- | Time in the real world. Use the functions below to convert it to/from
--   Unix time in seconds.
newtype Timestamp
Timestamp :: POSIXTime -> Timestamp
[unTimestamp] :: Timestamp -> POSIXTime
timestampToSeconds :: Integral a => Timestamp -> a
timestampFromSeconds :: Integer -> Timestamp
timestampFromUTCTime :: UTCTime -> Timestamp

-- | Add given amount of seconds to a <a>Timestamp</a>.
timestampPlusSeconds :: Timestamp -> Integer -> Timestamp

-- | Display timestamp in human-readable way as used by Michelson. Uses UTC
--   timezone, though maybe we should take it as an argument.
--   
--   NB: this will render timestamp with up to seconds precision.
formatTimestamp :: Timestamp -> Text

-- | Parse textual representation of <a>Timestamp</a>.
parseTimestamp :: Text -> Maybe Timestamp

-- | Quote a value of type <a>Timestamp</a> in
--   <tt>yyyy-mm-ddThh:mm:ss[.sss]Z</tt> format.
--   
--   <pre>
--   &gt;&gt;&gt; formatTimestamp [timestampQuote| 2019-02-21T16:54:12.2344523Z |]
--   "2019-02-21T16:54:12Z"
--   </pre>
--   
--   Inspired by 'time-quote' library.
timestampQuote :: QuasiQuoter

-- | Return current time as <a>Timestamp</a>.
getCurrentTime :: IO Timestamp

-- | Timestamp which is always greater than result of
--   <a>getCurrentTime</a>.
farFuture :: Timestamp

-- | Timestamp which is always less than result of <a>getCurrentTime</a>.
farPast :: Timestamp
instance Data.Aeson.Types.ToJSON.ToJSON Tezos.Core.Timestamp
instance Data.Aeson.Types.FromJSON.FromJSON Tezos.Core.Timestamp
instance Data.Aeson.Types.ToJSON.ToJSON Tezos.Core.Mutez
instance Data.Aeson.Types.FromJSON.FromJSON Tezos.Core.Mutez
instance GHC.Generics.Generic Tezos.Core.Timestamp
instance Data.Data.Data Tezos.Core.Timestamp
instance GHC.Classes.Ord Tezos.Core.Timestamp
instance GHC.Classes.Eq Tezos.Core.Timestamp
instance GHC.Show.Show Tezos.Core.Timestamp
instance Formatting.Buildable.Buildable Tezos.Core.Mutez
instance GHC.Enum.Enum Tezos.Core.Mutez
instance GHC.Generics.Generic Tezos.Core.Mutez
instance Data.Data.Data Tezos.Core.Mutez
instance GHC.Classes.Ord Tezos.Core.Mutez
instance GHC.Classes.Eq Tezos.Core.Mutez
instance GHC.Show.Show Tezos.Core.Mutez
instance Formatting.Buildable.Buildable Tezos.Core.Timestamp
instance GHC.Enum.Bounded Tezos.Core.Mutez


-- | Utilities related to <a>Alternative</a>.
module Util.Alternative

-- | This function is the same as <a>some</a> except that it returns
--   <a>NonEmpty</a>, because <a>some</a> is guaranteed to return non-empty
--   list, but it's not captured in types.
someNE :: Alternative f => f a -> f (NonEmpty a)

module Util.Default
permute2Def :: (Default a, Default b, Monad f, Alternative f) => f a -> f b -> f (a, b)
permute3Def :: (Default a, Default b, Default c, Monad f, Alternative f) => f a -> f b -> f c -> f (a, b, c)

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a


-- | Generic-related utils.
module Util.Generic

-- | Rebuild a list into a binary tree of exactly the same form which
--   <a>Generic</a> uses to represent datatypes.
--   
--   Along with the original list you have to provide constructor for
--   intermediate nodes - it accepts zero-based index of the leftmost
--   element of the right tree and merged trees themselves.
mkGenericTree :: (Natural -> a -> a -> a) -> NonEmpty a -> a
mkGenericTreeVec :: HasCallStack => (a -> b) -> (Natural -> b -> b -> b) -> Vector a -> b

-- | Extract datatype name via its Generic representation.
--   
--   For polymorphic types this throws away all type arguments.
type GenericTypeName a = GTypeName (Rep a)

module Util.IO
readFileUtf8 :: FilePath -> IO Text
writeFileUtf8 :: Print text => FilePath -> text -> IO ()
appendFileUtf8 :: Print text => FilePath -> text -> IO ()
withEncoding :: Handle -> TextEncoding -> IO () -> IO ()

-- | Change the character encoding of the given Handle to transliterate on
--   unsupported characters instead of throwing an exception.
hSetTranslit :: Handle -> IO ()


-- | Missing instances from libraries.
module Util.Instances
instance Data.Default.Class.Default GHC.Natural.Natural
instance Formatting.Buildable.Buildable GHC.Natural.Natural

module Util.Lens

-- | For datatype with "myNyan" field it will create "myNyanL" lens.
postfixLFields :: LensRules

-- | Build lenses with a custom configuration.
makeLensesWith :: LensRules -> Name -> DecsQ


-- | A small Markdown eDSL.
module Util.Markdown

-- | Level of header, starting from 1.
newtype HeaderLevel
HeaderLevel :: Int -> HeaderLevel
nextHeaderLevel :: HeaderLevel -> HeaderLevel
mdHeader :: HeaderLevel -> Builder -> Builder
mdSubsection :: Builder -> Builder -> Builder
mdBold :: Builder -> Builder
mdItalic :: Builder -> Builder
mdTicked :: Builder -> Builder
mdLocalRef :: Builder -> Text -> Builder
mdAnchor :: Text -> Builder
mdSeparator :: Builder

-- | Text which is hidden until clicked.
mdSpoiler :: Builder -> Builder -> Builder


-- | Renderable documentation injected to contract code.
module Michelson.Typed.Doc

-- | A piece of documentation describing one property of a thing, be it a
--   name or description of a contract, or an error throwable by given
--   endpoint.
--   
--   Items of the same type appear close to each other in a rendered
--   documentation and form a <i>section</i>.
--   
--   Doc items are later injected into a contract code via a dedicated
--   nop-like instruction. Normally doc items which belong to one section
--   appear in resulting doc in the same order in which they appeared in
--   the contract.
class (Typeable d, KnownNat (DocItemPosition d)) => DocItem d where {
    
    -- | Position of this item in the resulting documentation; the smaller the
    --   value, the higher the section with this element will be placed.
    --   
    --   Documentation structure is not necessarily flat. If some doc item
    --   consolidates a whole documentation block within it, this block will
    --   have its own placement of items independent from outer parts of the
    --   doc.
    type family DocItemPosition d = (pos :: Nat) | pos -> d;
    
    -- | Defines where given doc item should be put. There are two options: 1.
    --   Inline right here (default behaviour); 2. Put into definitions
    --   section.
    type family DocItemPlacement d :: DocItemPlacementKind;
    type DocItemPlacement d =  'DocItemInlined;
}

-- | When multiple items of the same type belong to one section, how this
--   section will be called.
--   
--   If not provided, section will contain just untitled content.
docItemSectionName :: DocItem d => Maybe Text

-- | Description of a section.
--   
--   Can be used to mention some common things about all elements of this
--   section. Markdown syntax is permitted here.
docItemSectionDescription :: DocItem d => Maybe Builder

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: DocItem d => d -> DocItemRef (DocItemPlacement d)

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: (DocItem d, DocItemPlacement d ~  'DocItemInlined) => d -> DocItemRef (DocItemPlacement d)

-- | Render given doc item to Markdown, preferably one line, optionally
--   with header.
--   
--   Accepts the smallest allowed level of header. (Using smaller value
--   than provided one will interfere with existing headers thus delivering
--   mess).
docItemToMarkdown :: DocItem d => HeaderLevel -> d -> Builder

-- | All doc items which this doc item refers to.
--   
--   They will automatically be put to definitions as soon as given doc
--   item is detected.
docItemDependencies :: DocItem d => d -> [SomeDocDefinitionItem]

-- | This function accepts doc items put under the same section in the
--   order in which they appeared in the contract and returns their new
--   desired order. It's also fine to use this function for filtering or
--   merging doc items.
--   
--   Default implementation * leaves inlined items as is; * for items put
--   to definitions, lexicographically sorts them by their id.
docItemsOrder :: DocItem d => [d] -> [d]

-- | Get doc item position at term-level.
docItemPosition :: forall d. DocItem d => DocItemPos

-- | Some unique identifier of a doc item.
--   
--   All doc items which should be refer-able need to have this identifier.
newtype DocItemId
DocItemId :: Text -> DocItemId

-- | Where do we place given doc item.
data DocItemPlacementKind

-- | Placed in the document content itself.
DocItemInlined :: DocItemPlacementKind

-- | Placed in dedicated definitions section; can later be referenced.
DocItemInDefinitions :: DocItemPlacementKind

-- | Defines an identifier which given doc item can be referenced with.
data DocItemRef (p :: DocItemPlacementKind)
[DocItemRef] :: DocItemId -> DocItemRef  'DocItemInDefinitions
[DocItemNoRef] :: DocItemRef  'DocItemInlined

-- | Hides some documentation item.
data SomeDocItem
[SomeDocItem] :: DocItem d => d -> SomeDocItem

-- | Hides some documentation item which is put to "definitions" section.
data SomeDocDefinitionItem
[SomeDocDefinitionItem] :: (DocItem d, DocItemPlacement d ~  'DocItemInDefinitions) => d -> SomeDocDefinitionItem

-- | A map from positions to document elements.
--   
--   Note that each value in this map keeps a list of doc items, all of
--   which have the same type (since each doc item type is forced to have
--   unique position).
type DocBlock = Map DocItemPos (NonEmpty SomeDocItem)

-- | A function which groups a piece of doc under one doc item.
type DocGrouping = DocBlock -> SomeDocItem

-- | Keeps documentation gathered for some piece of contract code.
--   
--   Used for building documentation of a contract.
data ContractDoc
ContractDoc :: DocBlock -> DocBlock -> Set DocItemId -> ContractDoc

-- | All inlined doc items.
[cdContents] :: ContractDoc -> DocBlock

-- | Definitions used in document.
--   
--   Usually you put some large and repetitive descriptions here. This
--   differs from the document content in that it contains sections which
--   are always at top-level, disregard the nesting.
--   
--   All doc items which define <tt>docItemId</tt> method go here, and only
--   they.
[cdDefinitions] :: ContractDoc -> DocBlock

-- | We remember all already used identifiers to avoid repetitions.
[cdDefinitionIds] :: ContractDoc -> Set DocItemId
cdContentsL :: Lens' ContractDoc DocBlock
cdDefinitionsL :: Lens' ContractDoc DocBlock
cdDefinitionIdsL :: Lens' ContractDoc (Set DocItemId)

-- | Render a documentation block.
docBlockToMarkdown :: HeaderLevel -> DocBlock -> Builder

-- | Render given contract documentation to markdown document.
contractDocToMarkdown :: ContractDoc -> LText

-- | Give a name to document block.
data DName
DName :: Text -> DocBlock -> DName

-- | Description of something.
data DDescription
DDescription :: Text -> DDescription

-- | Specify version if given contract.
data DVersion
DVersion :: Natural -> DVersion

-- | An error thrown by a contract.
data DError
DError :: DError
instance Michelson.Typed.Doc.DocItem Michelson.Typed.Doc.DError
instance Michelson.Typed.Doc.DocItem Michelson.Typed.Doc.DVersion
instance Michelson.Typed.Doc.DocItem Michelson.Typed.Doc.DDescription
instance Michelson.Typed.Doc.DocItem Michelson.Typed.Doc.DName
instance GHC.Base.Semigroup Michelson.Typed.Doc.ContractDoc
instance GHC.Base.Monoid Michelson.Typed.Doc.ContractDoc
instance Formatting.Buildable.Buildable Michelson.Typed.Doc.DocItemPos
instance GHC.Show.Show Michelson.Typed.Doc.DocItemPos
instance GHC.Classes.Ord Michelson.Typed.Doc.DocItemPos
instance GHC.Classes.Eq Michelson.Typed.Doc.DocItemPos
instance GHC.Show.Show Michelson.Typed.Doc.DocItemId
instance GHC.Classes.Ord Michelson.Typed.Doc.DocItemId
instance GHC.Classes.Eq Michelson.Typed.Doc.DocItemId
instance GHC.Show.Show Michelson.Typed.Doc.DocGrouping
instance GHC.Show.Show Michelson.Typed.Doc.SomeDocItem


-- | Additional functionality for <tt>named</tt> package.
module Util.Named
(.!) :: Name name -> a -> NamedF Identity a name
(.?) :: Name name -> Maybe a -> NamedF Maybe a name
(<.!>) :: Functor m => Name name -> m a -> m (NamedF Identity a name)
(<.?>) :: Functor m => Name name -> m (Maybe a) -> m (NamedF Maybe a name)
type family NamedInner n
instance GHC.Classes.Eq (f a) => GHC.Classes.Eq (Named.Internal.NamedF f a name)
instance GHC.Classes.Ord (f a) => GHC.Classes.Ord (Named.Internal.NamedF f a name)
instance (Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable a, GHC.TypeLits.KnownSymbol name, Data.Data.Data (f a)) => Data.Data.Data (Named.Internal.NamedF f a name)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Named.Internal.NamedF Data.Functor.Identity.Identity a name)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Named.Internal.NamedF GHC.Maybe.Maybe a name)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Named.Internal.NamedF Data.Functor.Identity.Identity a name)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Named.Internal.NamedF GHC.Maybe.Maybe a name)
instance Control.Lens.Wrapped.Wrapped (Named.Internal.NamedF Data.Functor.Identity.Identity a name)
instance Control.Lens.Wrapped.Wrapped (Named.Internal.NamedF GHC.Maybe.Maybe a name)
instance (GHC.Show.Show a, GHC.TypeLits.KnownSymbol name) => GHC.Show.Show (Named.Internal.NamedF Data.Functor.Identity.Identity a name)
instance (GHC.TypeLits.KnownSymbol name, Formatting.Buildable.Buildable (f a)) => Formatting.Buildable.Buildable (Named.Internal.NamedF f a name)


-- | Type-nat utilities.
--   
--   We take Peano numbers as base for operations because they make it much
--   easer to prove things to compiler. Their performance does not seem to
--   introduce a problem, because we use nats primarily along with stack
--   which is a linked list with similar performance characteristics.
--   
--   Many of things we introduce here are covered in <tt>type-natural</tt>
--   package, but unfortunatelly it does not work with GHC 8.6 at the
--   moment of writing this module. We use <a>Vinyl</a> as source of Peano
--   <tt>Nat</tt> for now.
module Util.Peano

-- | A convenient alias.
--   
--   We are going to use <a>Peano</a> numbers for type-dependent logic and
--   normal <a>Nat</a>s in user API, need to distinguish them somehow.
type Peano = Nat
type family ToPeano (n :: Nat) :: Nat
type family Length l
class KnownPeano (n :: Nat)
peanoVal :: KnownPeano n => proxy n -> Natural
peanoVal' :: forall n. KnownPeano n => Natural

-- | The singleton kind-indexed data family.
data family Sing (a :: k) :: Type
type family At (n :: Peano) s

-- | Comparison of type-level naturals, as a function.
--   
--   It is as lazy on the list argument as possible - there is no need to
--   know the whole list if the natural argument is small enough. This
--   property is important if we want to be able to extract reusable parts
--   of code which are aware only of relevant part of stack.
type family IsLongerThan (l :: [k]) (a :: Nat) :: Bool

-- | Comparison of type-level naturals, as a constraint.
type LongerThan l a = IsLongerThan l a ~  'True

-- | Comparison of type-level naturals, raises human-readable compile error
--   when does not hold.
--   
--   This is for in eDSL use only, GHC cannot reason about such constraint.
type family RequireLongerThan (l :: [k]) (a :: Nat) :: Constraint

-- | Derive <a>LongerThan</a> from <a>RequireLongerThan</a>.
requiredLongerThan :: forall l a r. RequireLongerThan l a => (LongerThan l a => r) -> r
instance GHC.Classes.Eq (Data.Singletons.Internal.Sing n)
instance Util.Peano.KnownPeano 'Data.Vinyl.TypeLevel.Z
instance Util.Peano.KnownPeano a => Util.Peano.KnownPeano ('Data.Vinyl.TypeLevel.S a)
instance Data.Singletons.Internal.SingI 'Data.Vinyl.TypeLevel.Z
instance Data.Singletons.Internal.SingI n => Data.Singletons.Internal.SingI ('Data.Vinyl.TypeLevel.S n)


-- | Definition of <a>Positive</a> type and related utilities.
module Util.Positive

-- | Integer values starting from 1.
--   
--   We define our own datatype in order to have <a>Data</a> instance for
--   it, which can not be derived for third-party types without exported
--   constructor.
newtype Positive
PositiveUnsafe :: Natural -> Positive
[unPositive] :: Positive -> Natural
mkPositive :: (Integral i, Buildable i) => i -> Either Text Positive

-- | Count length of non-empty list.
lengthNE :: NonEmpty a -> Positive

-- | Produce a non empty list consisting of the given value.
replicateNE :: Positive -> a -> NonEmpty a
instance Data.Aeson.Types.FromJSON.FromJSON Util.Positive.Positive
instance Data.Aeson.Types.ToJSON.ToJSON Util.Positive.Positive
instance Formatting.Buildable.Buildable Util.Positive.Positive
instance GHC.Show.Show Util.Positive.Positive
instance Data.Data.Data Util.Positive.Positive
instance GHC.Classes.Ord Util.Positive.Positive
instance GHC.Classes.Eq Util.Positive.Positive


-- | Custom exceptions that can happen during parsing.
module Michelson.Parser.Error
data CustomParserException
UnknownTypeException :: CustomParserException
StringLiteralException :: StringLiteralParserException -> CustomParserException
OddNumberBytesException :: CustomParserException
ProhibitedLetType :: Text -> CustomParserException
WrongTagArgs :: Natural -> Positive -> CustomParserException
WrongAccessArgs :: Natural -> Positive -> CustomParserException
WrongSetArgs :: Natural -> Positive -> CustomParserException
data StringLiteralParserException
InvalidEscapeSequence :: Char -> StringLiteralParserException
InvalidChar :: Char -> StringLiteralParserException

-- | A non-empty collection of <a>ParseError</a>s equipped with
--   <a>PosState</a> that allows to pretty-print the errors efficiently and
--   correctly.
data ParseErrorBundle s e
data ParserException
ParserException :: ParseErrorBundle Text CustomParserException -> ParserException
instance GHC.Classes.Eq Michelson.Parser.Error.ParserException
instance GHC.Show.Show Michelson.Parser.Error.CustomParserException
instance GHC.Classes.Ord Michelson.Parser.Error.CustomParserException
instance Data.Data.Data Michelson.Parser.Error.CustomParserException
instance GHC.Classes.Eq Michelson.Parser.Error.CustomParserException
instance GHC.Show.Show Michelson.Parser.Error.StringLiteralParserException
instance GHC.Classes.Ord Michelson.Parser.Error.StringLiteralParserException
instance Data.Data.Data Michelson.Parser.Error.StringLiteralParserException
instance GHC.Classes.Eq Michelson.Parser.Error.StringLiteralParserException
instance GHC.Show.Show Michelson.Parser.Error.ParserException
instance GHC.Exception.Type.Exception Michelson.Parser.Error.ParserException
instance Formatting.Buildable.Buildable Michelson.Parser.Error.ParserException
instance Text.Megaparsec.Error.ShowErrorComponent Michelson.Parser.Error.CustomParserException
instance Text.Megaparsec.Error.ShowErrorComponent Michelson.Parser.Error.StringLiteralParserException


-- | Ingridients that we use in our test suite.
module Util.Test.Ingredients

-- | This is the default set of ingredients extended with the
--   <a>antXMLRunner</a> which is used to generate xml reports for CI.
ourIngredients :: [Ingredient]

module Util.Text

-- | Leads first character of text to lower case.
--   
--   For empty text this will throw an error.
headToLower :: HasCallStack => Text -> Text


-- | General type utilities.
module Util.Type
type family IsElem (a :: k) (l :: [k]) :: Bool
type family Guard (cond :: Bool) (a :: k) :: Maybe k
type family AllUnique (l :: [k]) :: Bool
type family RequireAllUnique (desc :: Symbol) (l :: [k]) :: Constraint

-- | Bring type-level list at term-level using given function to demote its
--   individual elements.
class ReifyList (c :: k -> Constraint) (l :: [k])
reifyList :: ReifyList c l => (forall a. c a => Proxy a -> r) -> [r]
instance forall k (c :: k -> GHC.Types.Constraint). Util.Type.ReifyList c '[]
instance forall a (c :: a -> GHC.Types.Constraint) (x :: a) (xs :: [a]). (c x, Util.Type.ReifyList c xs) => Util.Type.ReifyList c (x : xs)


-- | Re-exports <a>TypeLits</a>, modifying it considering our practices.
module Util.TypeLits

-- | This class gives the string associated with a type-level symbol. There
--   are instances of the class for every concrete literal: "hello", etc.
class KnownSymbol (n :: Symbol)
symbolValT :: forall s. KnownSymbol s => Proxy s -> Text
symbolValT' :: forall s. KnownSymbol s => Text

-- | The type-level equivalent of <tt>error</tt>.
--   
--   The polymorphic kind of this type allows it to be used in several
--   settings. For instance, it can be used as a constraint, e.g. to
--   provide a better error message for a non-existent instance,
--   
--   <pre>
--   -- in a context
--   instance TypeError (Text "Cannot <a>Show</a> functions." :$$:
--                       Text "Perhaps there is a missing argument?")
--         =&gt; Show (a -&gt; b) where
--       showsPrec = error "unreachable"
--   </pre>
--   
--   It can also be placed on the right-hand side of a type-level function
--   to provide an error for an invalid case,
--   
--   <pre>
--   type family ByteSize x where
--      ByteSize Word16   = 2
--      ByteSize Word8    = 1
--      ByteSize a        = TypeError (Text "The type " :&lt;&gt;: ShowType a :&lt;&gt;:
--                                     Text " is not exportable.")
--   </pre>
type family TypeError (a :: ErrorMessage) :: b

-- | A description of a custom type error.
data ErrorMessage

-- | Show the text as is.
[Text] :: () => Symbol -> ErrorMessage

-- | Pretty print the type. <tt>ShowType :: k -&gt; ErrorMessage</tt>
[ShowType] :: forall t. () => t -> ErrorMessage

-- | Put two pieces of error message next to each other.
[:<>:] :: () => ErrorMessage -> ErrorMessage -> ErrorMessage

-- | Stack two pieces of error message on top of each other.
[:$$:] :: () => ErrorMessage -> ErrorMessage -> ErrorMessage
infixl 6 :<>:
infixl 5 :$$:


-- | Strings compliant with Michelson constraints.
--   
--   When writting a Michelson contract, you can only mention characters
--   with codes from <tt>[32 .. 126]</tt> range in string literals. Same
--   restriction applies to string literals passed to <tt>alphanet.sh</tt>.
--   
--   However, Michelson allows some control sequences: <tt>"n"</tt>. You
--   have to write it exactly in this form, and internally it will be
--   transformed to line feed character (this behaviour can be observed
--   when looking at <tt>Pack</tt>ed data).
--   
--   See tests for examples of good and bad strings.
module Michelson.Text

-- | Michelson string value.
--   
--   This is basically a mere text with limits imposed by the language:
--   <a>http://tezos.gitlab.io/zeronet/whitedoc/michelson.html#constants</a>
--   Although, this document seems to be not fully correct, and thus we
--   applied constraints deduced empirically.
--   
--   You construct an item of this type using one of the following ways:
--   
--   <ul>
--   <li>With QuasyQuotes when need to create a string literal.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; [mt|Some text|]
--   MTextUnsafe { unMText = "Some text" }
--   </pre>
--   
--   <ul>
--   <li>With <a>mkMText</a> when constructing from a runtime text
--   value.</li>
--   <li>With <a>mkMTextUnsafe</a> or <a>MTextUnsafe</a> when absolutelly
--   sure that given string does not violate invariants.</li>
--   <li>With <a>mkMTextCut</a> when not sure about text contents and want
--   to make it compliant with Michelson constraints.</li>
--   </ul>
newtype MText
MTextUnsafe :: Text -> MText
[unMText] :: MText -> Text

-- | Wrap a Haskell text into <a>MText</a>, performing necessary checks.
--   
--   You can use e.g. <tt>'\n'</tt> character directly in supplied
--   argument, but attempt to use other bad characters like <tt>'\r'</tt>
--   will cause failure.
mkMText :: Text -> Either Text MText

-- | Contruct <a>MText</a> from a Haskell text, failing if provided Haskell
--   text is invalid Michelson string.
mkMTextUnsafe :: HasCallStack => Text -> MText

-- | Construct <a>MText</a> from a Haskell text, eliminating all characters
--   which should not appear in Michelson strings. Characters which can be
--   displayed normally via escaping are preserved.
mkMTextCut :: Text -> MText

-- | Print <a>MText</a> for Michelson code, with all unusual characters
--   escaped.
writeMText :: MText -> Text
takeMText :: Int -> MText -> MText
dropMText :: Int -> MText -> MText

-- | Constraint on literals appearing in Michelson contract code.
isMChar :: Char -> Bool

-- | Parser used in <a>mt</a> quasi quoter.
qqMText :: String -> Either Text String

-- | QuasyQuoter for constructing Michelson strings.
--   
--   Validity of result will be checked at compile time. Note:
--   
--   <ul>
--   <li>slash must be escaped</li>
--   <li>newline character must appear as '\n'</li>
--   <li>use quotes as is</li>
--   <li>other special characters are not allowed.</li>
--   </ul>
mt :: QuasiQuoter

-- | A type error asking to use <a>MText</a> instead of
--   <a>ErrorMessage</a>.
type family DoNotUseTextError

-- | Create a <a>MText</a> from type-level string.
--   
--   We assume that no unicode characters are used in plain Haskell code,
--   so unless special tricky manipulations are used this should be safe.
symbolToMText :: forall name. KnownSymbol name => MText

-- | Create a <a>MText</a> from label.
--   
--   We assume that no unicode characters are used in plain Haskell code,
--   so unless special tricky manipulations are used this should be safe.
labelToMText :: KnownSymbol name => Label name -> MText
instance Data.Hashable.Class.Hashable Michelson.Text.MText
instance Formatting.Buildable.Buildable Michelson.Text.MText
instance Universum.Container.Class.Container Michelson.Text.MText
instance GHC.Base.Monoid Michelson.Text.MText
instance GHC.Base.Semigroup Michelson.Text.MText
instance Data.Data.Data Michelson.Text.MText
instance GHC.Classes.Ord Michelson.Text.MText
instance GHC.Classes.Eq Michelson.Text.MText
instance GHC.Show.Show Michelson.Text.MText
instance Universum.String.Conversion.ToText Michelson.Text.MText
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Text.MText
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Text.MText
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Text.MText
instance (TypeError ...) => Data.String.IsString Michelson.Text.MText


-- | Cryptographic primitives used in Tezos.
module Tezos.Crypto

-- | ED25519 public cryptographic key.
newtype PublicKey
PublicKey :: PublicKey -> PublicKey
[unPublicKey] :: PublicKey -> PublicKey

-- | ED25519 secret cryptographic key.
data SecretKey

-- | ED25519 cryptographic signature.
newtype Signature
Signature :: Signature -> Signature
[unSignature] :: Signature -> Signature

-- | b58check of a public key.
newtype KeyHash
KeyHash :: ByteString -> KeyHash
[unKeyHash] :: KeyHash -> ByteString

-- | Deterministicaly generate a secret key from seed.
detSecretKey :: ByteString -> SecretKey

-- | Create a public key from a secret key.
toPublic :: SecretKey -> PublicKey

-- | Error that can happen during parsing of cryptographic primitive types.
data CryptoParseError
CryptoParseWrongBase58Check :: CryptoParseError
CryptoParseWrongTag :: !ByteString -> CryptoParseError
CryptoParseCryptoError :: CryptoError -> CryptoParseError
formatPublicKey :: PublicKey -> Text
mformatPublicKey :: PublicKey -> MText
parsePublicKey :: Text -> Either CryptoParseError PublicKey
mkPublicKey :: ByteArrayAccess ba => ba -> Either Text PublicKey
formatSecretKey :: SecretKey -> Text
parseSecretKey :: Text -> Either CryptoParseError SecretKey
formatSignature :: Signature -> Text
mformatSignature :: Signature -> MText
parseSignature :: Text -> Either CryptoParseError Signature
mkSignature :: ByteArrayAccess ba => ba -> Either Text Signature
formatKeyHash :: KeyHash -> Text
mformatKeyHash :: KeyHash -> MText
parseKeyHash :: Text -> Either CryptoParseError KeyHash

-- | Sign a message using the secret key.
sign :: SecretKey -> ByteString -> Signature

-- | Check that a sequence of bytes has been signed with a given key.
checkSignature :: PublicKey -> Signature -> ByteString -> Bool

-- | Compute the b58check of a public key hash.
hashKey :: PublicKey -> KeyHash

-- | Compute a cryptographic hash of a bytestring using the Blake2b_256
--   cryptographic hash function. It's used by the BLAKE2B instruction in
--   Michelson.
blake2b :: ByteString -> ByteString

-- | Compute a cryptographic hash of a bytestring using the Blake2b_160
--   cryptographic hash function.
blake2b160 :: ByteString -> ByteString

-- | Compute a cryptographic hash of a bytestring using the Sha256
--   cryptographic hash function.
sha256 :: ByteString -> ByteString

-- | Compute a cryptographic hash of a bytestring using the Sha512
--   cryptographic hash function.
sha512 :: ByteString -> ByteString

-- | Encode a bytestring in Base58Check format.
encodeBase58Check :: ByteString -> Text

-- | Decode a bytestring from Base58Check format.
decodeBase58Check :: Text -> Maybe ByteString
data B58CheckWithPrefixError
B58CheckWithPrefixWrongPrefix :: ByteString -> B58CheckWithPrefixError
B58CheckWithPrefixWrongEncoding :: B58CheckWithPrefixError

-- | Parse a base58check encoded value expecting some prefix. If the actual
--   prefix matches the expected one, it's stripped of and the resulting
--   payload is returned.
decodeBase58CheckWithPrefix :: ByteString -> Text -> Either B58CheckWithPrefixError ByteString
instance GHC.Show.Show Tezos.Crypto.B58CheckWithPrefixError
instance GHC.Classes.Eq Tezos.Crypto.CryptoParseError
instance GHC.Show.Show Tezos.Crypto.CryptoParseError
instance GHC.Classes.Ord Tezos.Crypto.KeyHash
instance GHC.Classes.Eq Tezos.Crypto.KeyHash
instance GHC.Show.Show Tezos.Crypto.KeyHash
instance GHC.Classes.Eq Tezos.Crypto.Signature
instance GHC.Show.Show Tezos.Crypto.Signature
instance GHC.Classes.Eq Tezos.Crypto.SecretKey
instance GHC.Show.Show Tezos.Crypto.SecretKey
instance GHC.Classes.Eq Tezos.Crypto.PublicKey
instance GHC.Show.Show Tezos.Crypto.PublicKey
instance Formatting.Buildable.Buildable Tezos.Crypto.CryptoParseError
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Crypto.KeyHash
instance Formatting.Buildable.Buildable Tezos.Crypto.KeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Tezos.Crypto.KeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Tezos.Crypto.KeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Crypto.Signature
instance Formatting.Buildable.Buildable Tezos.Crypto.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Tezos.Crypto.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Tezos.Crypto.Signature
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Crypto.SecretKey
instance Formatting.Buildable.Buildable Tezos.Crypto.SecretKey
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Crypto.PublicKey
instance Formatting.Buildable.Buildable Tezos.Crypto.PublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Tezos.Crypto.PublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Tezos.Crypto.PublicKey


-- | Address in Tezos.
module Tezos.Address

-- | Data type corresponding to address structure in Tezos.
data Address

-- | <tt>tz</tt> address which is a hash of a public key.
KeyAddress :: !KeyHash -> Address

-- | <tt>KT</tt> address which corresponds to a callable contract. It's a
--   hash of origination command. TODO: we should probably have a
--   <tt>Hash</tt> type.
ContractAddress :: !ByteString -> Address

-- | Smart constructor for <a>KeyAddress</a>.
mkKeyAddress :: PublicKey -> Address

-- | Smart constructor for <a>ContractAddress</a>. Its argument is
--   serialized origination operation.
--   
--   Note: it's quite unsafe to pass <a>ByteString</a>, because we can pass
--   some garbage which is not a serialized origination operation, but this
--   operation includes contract itself and necessary types are defined in
--   <a>*</a>. So we have to serialize this data outside this module and
--   pass it here as a <a>ByteString</a>. Alternatively we could add some
--   constraint, but it would be almost as unsafe as passing a
--   <a>ByteString</a>. For this reason we add <tt>Raw</tt> suffix to this
--   function and provide a safer function in <a>Instr</a>. We may
--   reconsider it later.
mkContractAddressRaw :: ByteString -> Address
formatAddress :: Address -> Text
mformatAddress :: Address -> MText

-- | Parse an address from its human-readable textual representation used
--   by Tezos (e. g. "tz1faswCTDciRzE4oJ9jn2Vm2dvjeyA9fUzU"). Or fail if
--   it's invalid.
parseAddress :: Text -> Either ParseAddressError Address

-- | Partial version of <a>parseAddress</a> which assumes that the address
--   is correct. Can be used in tests.
unsafeParseAddress :: HasCallStack => Text -> Address
instance GHC.Classes.Eq Tezos.Address.ParseAddressError
instance GHC.Show.Show Tezos.Address.ParseAddressError
instance GHC.Classes.Eq Tezos.Address.ParseContractAddressError
instance GHC.Show.Show Tezos.Address.ParseContractAddressError
instance GHC.Classes.Ord Tezos.Address.Address
instance GHC.Classes.Eq Tezos.Address.Address
instance GHC.Show.Show Tezos.Address.Address
instance Formatting.Buildable.Buildable Tezos.Address.ParseAddressError
instance Formatting.Buildable.Buildable Tezos.Address.ParseContractAddressError
instance Formatting.Buildable.Buildable Tezos.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSON Tezos.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSONKey Tezos.Address.Address
instance Data.Aeson.Types.FromJSON.FromJSON Tezos.Address.Address
instance Data.Aeson.Types.FromJSON.FromJSONKey Tezos.Address.Address
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Address.Address


-- | Untyped Michelson values (i. e. type of a value is not statically
--   known).
module Michelson.Untyped.Value
data Value' op
ValueInt :: Integer -> Value' op
ValueString :: MText -> Value' op
ValueBytes :: InternalByteString -> Value' op
ValueUnit :: Value' op
ValueTrue :: Value' op
ValueFalse :: Value' op
ValuePair :: Value' op -> Value' op -> Value' op
ValueLeft :: Value' op -> Value' op
ValueRight :: Value' op -> Value' op
ValueSome :: Value' op -> Value' op
ValueNone :: Value' op
ValueNil :: Value' op

-- | A sequence of elements: can be a list or a set. We can't distinguish
--   lists and sets during parsing.
ValueSeq :: (NonEmpty $ Value' op) -> Value' op
ValueMap :: (NonEmpty $ Elt op) -> Value' op
ValueLambda :: NonEmpty op -> Value' op
data Elt op
Elt :: Value' op -> Value' op -> Elt op

-- | ByteString does not have an instance for ToJSON and FromJSON, to avoid
--   orphan type class instances, make a new type wrapper around it.
newtype InternalByteString
InternalByteString :: ByteString -> InternalByteString
unInternalByteString :: InternalByteString -> ByteString
instance Data.Aeson.Types.ToJSON.ToJSON op => Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Value.Elt op)
instance Data.Aeson.Types.FromJSON.FromJSON op => Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Value.Elt op)
instance Data.Aeson.Types.ToJSON.ToJSON op => Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Value.Value' op)
instance Data.Aeson.Types.FromJSON.FromJSON op => Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Value.Value' op)
instance GHC.Generics.Generic (Michelson.Untyped.Value.Elt op)
instance Data.Data.Data op => Data.Data.Data (Michelson.Untyped.Value.Elt op)
instance GHC.Base.Functor Michelson.Untyped.Value.Elt
instance GHC.Show.Show op => GHC.Show.Show (Michelson.Untyped.Value.Elt op)
instance GHC.Classes.Eq op => GHC.Classes.Eq (Michelson.Untyped.Value.Elt op)
instance GHC.Generics.Generic (Michelson.Untyped.Value.Value' op)
instance Data.Data.Data op => Data.Data.Data (Michelson.Untyped.Value.Value' op)
instance GHC.Base.Functor Michelson.Untyped.Value.Value'
instance GHC.Show.Show op => GHC.Show.Show (Michelson.Untyped.Value.Value' op)
instance GHC.Classes.Eq op => GHC.Classes.Eq (Michelson.Untyped.Value.Value' op)
instance GHC.Show.Show Michelson.Untyped.Value.InternalByteString
instance GHC.Classes.Eq Michelson.Untyped.Value.InternalByteString
instance Data.Data.Data Michelson.Untyped.Value.InternalByteString
instance Michelson.Printer.Util.RenderDoc op => Michelson.Printer.Util.RenderDoc (Michelson.Untyped.Value.Value' op)
instance Michelson.Printer.Util.RenderDoc op => Michelson.Printer.Util.RenderDoc (Michelson.Untyped.Value.Elt op)
instance Michelson.Printer.Util.RenderDoc op => Formatting.Buildable.Buildable (Michelson.Untyped.Value.Value' op)
instance Michelson.Printer.Util.RenderDoc op => Formatting.Buildable.Buildable (Michelson.Untyped.Value.Elt op)
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Value.InternalByteString
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Value.InternalByteString


-- | Michelson instructions in untyped model.
module Michelson.Untyped.Instr

-- | Michelson instruction with abstract parameter <tt>op</tt>. This
--   parameter is necessary, because at different stages of our pipeline it
--   will be different. Initially it can contain macros and non-flattened
--   instructions, but then it contains only vanilla Michelson
--   instructions.
data InstrAbstract op
EXT :: ExtInstrAbstract op -> InstrAbstract op
DROP :: InstrAbstract op
DUP :: VarAnn -> InstrAbstract op
SWAP :: InstrAbstract op
PUSH :: VarAnn -> Type -> Value' op -> InstrAbstract op
SOME :: TypeAnn -> VarAnn -> FieldAnn -> InstrAbstract op
NONE :: TypeAnn -> VarAnn -> FieldAnn -> Type -> InstrAbstract op
UNIT :: TypeAnn -> VarAnn -> InstrAbstract op
IF_NONE :: [op] -> [op] -> InstrAbstract op
PAIR :: TypeAnn -> VarAnn -> FieldAnn -> FieldAnn -> InstrAbstract op
CAR :: VarAnn -> FieldAnn -> InstrAbstract op
CDR :: VarAnn -> FieldAnn -> InstrAbstract op
LEFT :: TypeAnn -> VarAnn -> FieldAnn -> FieldAnn -> Type -> InstrAbstract op
RIGHT :: TypeAnn -> VarAnn -> FieldAnn -> FieldAnn -> Type -> InstrAbstract op
IF_LEFT :: [op] -> [op] -> InstrAbstract op
NIL :: TypeAnn -> VarAnn -> Type -> InstrAbstract op
CONS :: VarAnn -> InstrAbstract op
IF_CONS :: [op] -> [op] -> InstrAbstract op
SIZE :: VarAnn -> InstrAbstract op
EMPTY_SET :: TypeAnn -> VarAnn -> Comparable -> InstrAbstract op
EMPTY_MAP :: TypeAnn -> VarAnn -> Comparable -> Type -> InstrAbstract op
MAP :: VarAnn -> [op] -> InstrAbstract op
ITER :: [op] -> InstrAbstract op
MEM :: VarAnn -> InstrAbstract op
GET :: VarAnn -> InstrAbstract op
UPDATE :: InstrAbstract op
IF :: [op] -> [op] -> InstrAbstract op
LOOP :: [op] -> InstrAbstract op
LOOP_LEFT :: [op] -> InstrAbstract op
LAMBDA :: VarAnn -> Type -> Type -> [op] -> InstrAbstract op
EXEC :: VarAnn -> InstrAbstract op
DIP :: [op] -> InstrAbstract op
FAILWITH :: InstrAbstract op
CAST :: VarAnn -> Type -> InstrAbstract op
RENAME :: VarAnn -> InstrAbstract op
PACK :: VarAnn -> InstrAbstract op
UNPACK :: VarAnn -> Type -> InstrAbstract op
CONCAT :: VarAnn -> InstrAbstract op
SLICE :: VarAnn -> InstrAbstract op
ISNAT :: VarAnn -> InstrAbstract op
ADD :: VarAnn -> InstrAbstract op
SUB :: VarAnn -> InstrAbstract op
MUL :: VarAnn -> InstrAbstract op
EDIV :: VarAnn -> InstrAbstract op
ABS :: VarAnn -> InstrAbstract op
NEG :: InstrAbstract op
LSL :: VarAnn -> InstrAbstract op
LSR :: VarAnn -> InstrAbstract op
OR :: VarAnn -> InstrAbstract op
AND :: VarAnn -> InstrAbstract op
XOR :: VarAnn -> InstrAbstract op
NOT :: VarAnn -> InstrAbstract op
COMPARE :: VarAnn -> InstrAbstract op
EQ :: VarAnn -> InstrAbstract op
NEQ :: VarAnn -> InstrAbstract op
LT :: VarAnn -> InstrAbstract op
GT :: VarAnn -> InstrAbstract op
LE :: VarAnn -> InstrAbstract op
GE :: VarAnn -> InstrAbstract op
INT :: VarAnn -> InstrAbstract op
SELF :: VarAnn -> InstrAbstract op
CONTRACT :: VarAnn -> Type -> InstrAbstract op
TRANSFER_TOKENS :: VarAnn -> InstrAbstract op
SET_DELEGATE :: VarAnn -> InstrAbstract op
CREATE_ACCOUNT :: VarAnn -> VarAnn -> InstrAbstract op
CREATE_CONTRACT :: VarAnn -> VarAnn -> Contract' op -> InstrAbstract op
IMPLICIT_ACCOUNT :: VarAnn -> InstrAbstract op
NOW :: VarAnn -> InstrAbstract op
AMOUNT :: VarAnn -> InstrAbstract op
BALANCE :: VarAnn -> InstrAbstract op
CHECK_SIGNATURE :: VarAnn -> InstrAbstract op
SHA256 :: VarAnn -> InstrAbstract op
SHA512 :: VarAnn -> InstrAbstract op
BLAKE2B :: VarAnn -> InstrAbstract op
HASH_KEY :: VarAnn -> InstrAbstract op
STEPS_TO_QUOTA :: VarAnn -> InstrAbstract op
SOURCE :: VarAnn -> InstrAbstract op
SENDER :: VarAnn -> InstrAbstract op
ADDRESS :: VarAnn -> InstrAbstract op
newtype Op
Op :: Instr -> Op
[unOp] :: Op -> Instr
type Instr = InstrAbstract Op
data ExpandedOp
PrimEx :: ExpandedInstr -> ExpandedOp
SeqEx :: [ExpandedOp] -> ExpandedOp
WithSrcEx :: InstrCallStack -> ExpandedOp -> ExpandedOp
type ExpandedInstr = InstrAbstract ExpandedOp
type InstrExtU = ExtInstrAbstract Op
type ExpandedInstrExtU = ExtInstrAbstract ExpandedOp

-- | Flatten all <a>SeqEx</a> in <a>ExpandedOp</a>. This function is mostly
--   for testing. It returns instructions with the same logic, but they are
--   not strictly equivalent, because they are serialized differently
--   (grouping instructions into sequences affects the way they are
--   PACK'ed).
--   
--   Note: it does not return a list of <a>Instr</a> because this type is
--   not used anywhere and should probably be removed.
flattenExpandedOp :: ExpandedOp -> [ExpandedInstr]

-- | Data necessary to originate a contract.
data OriginationOperation
OriginationOperation :: !KeyHash -> !Maybe KeyHash -> !Bool -> !Bool -> !Mutez -> !Value' ExpandedOp -> !Contract' ExpandedOp -> OriginationOperation

-- | Manager of the contract.
[ooManager] :: OriginationOperation -> !KeyHash

-- | Optional delegate.
[ooDelegate] :: OriginationOperation -> !Maybe KeyHash

-- | Whether the contract is spendable.
[ooSpendable] :: OriginationOperation -> !Bool

-- | Whether the contract is delegatable.
[ooDelegatable] :: OriginationOperation -> !Bool

-- | Initial balance of the contract.
[ooBalance] :: OriginationOperation -> !Mutez

-- | Initial storage value of the contract.
[ooStorage] :: OriginationOperation -> !Value' ExpandedOp

-- | The contract itself.
[ooContract] :: OriginationOperation -> !Contract' ExpandedOp

-- | Compute address of a contract from its origination operation.
--   
--   TODO [TM-62] It's certainly imprecise, real Tezos implementation
--   doesn't use JSON, but we don't need precise format yet, so we just use
--   some serialization format (JSON because we have necessary instances
--   already).
mkContractAddress :: OriginationOperation -> Address
instance GHC.Generics.Generic Michelson.Untyped.Instr.OriginationOperation
instance GHC.Show.Show Michelson.Untyped.Instr.OriginationOperation
instance Formatting.Buildable.Buildable Michelson.Untyped.Instr.Op
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Instr.Op
instance GHC.Generics.Generic Michelson.Untyped.Instr.Op
instance GHC.Classes.Eq Michelson.Untyped.Instr.Op
instance GHC.Show.Show Michelson.Untyped.Instr.Op
instance GHC.Generics.Generic Michelson.Untyped.Instr.ExpandedOp
instance Data.Data.Data Michelson.Untyped.Instr.ExpandedOp
instance GHC.Classes.Eq Michelson.Untyped.Instr.ExpandedOp
instance GHC.Show.Show Michelson.Untyped.Instr.ExpandedOp
instance GHC.Generics.Generic (Michelson.Untyped.Instr.InstrAbstract op)
instance Data.Data.Data op => Data.Data.Data (Michelson.Untyped.Instr.InstrAbstract op)
instance GHC.Base.Functor Michelson.Untyped.Instr.InstrAbstract
instance GHC.Show.Show op => GHC.Show.Show (Michelson.Untyped.Instr.InstrAbstract op)
instance GHC.Classes.Eq op => GHC.Classes.Eq (Michelson.Untyped.Instr.InstrAbstract op)
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Instr.OriginationOperation
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Instr.OriginationOperation
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Instr.Op
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Instr.Op
instance Michelson.Printer.Util.RenderDoc Michelson.Untyped.Instr.ExpandedOp
instance Formatting.Buildable.Buildable Michelson.Untyped.Instr.ExpandedOp
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Untyped.Instr.ExpandedOp
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Untyped.Instr.ExpandedOp
instance Michelson.Printer.Util.RenderDoc op => Michelson.Printer.Util.RenderDoc (Michelson.Untyped.Instr.InstrAbstract op)
instance (Michelson.Printer.Util.RenderDoc op, Formatting.Buildable.Buildable op) => Formatting.Buildable.Buildable (Michelson.Untyped.Instr.InstrAbstract op)
instance Data.Aeson.Types.ToJSON.ToJSON op => Data.Aeson.Types.ToJSON.ToJSON (Michelson.Untyped.Instr.InstrAbstract op)
instance Data.Aeson.Types.FromJSON.FromJSON op => Data.Aeson.Types.FromJSON.FromJSON (Michelson.Untyped.Instr.InstrAbstract op)


-- | Some simple aliases for Michelson types.
module Michelson.Untyped.Aliases
type Contract = Contract' ExpandedOp
type Value = Value' ExpandedOp
type ExpandedExtInstr = ExtInstrAbstract ExpandedOp

module Michelson.Untyped

module Michelson.Typed.Extract
data TypeConvergeError
TypeConvergeError :: T -> T -> TypeConvergeError
TParameterConvergeError :: TypeConvergeError
TStorageConvergeError :: TypeConvergeError

-- | Extracts <tt>Notes t</tt> type from <a>Type</a> and corresponding
--   singleton.
extractNotes :: Type -> Sing t -> Either TypeConvergeError (Notes t)

-- | Extracts <a>T</a> type from <a>Type</a>.
fromUType :: HasCallStack => Type -> T
mkUType :: Sing x -> Notes x -> Type

-- | Converts from <a>T</a> to <a>Type</a>.
toUType :: T -> Type
instance GHC.Classes.Eq Michelson.Typed.Extract.TypeConvergeError
instance GHC.Show.Show Michelson.Typed.Extract.TypeConvergeError
instance Formatting.Buildable.Buildable Michelson.Typed.Extract.TypeConvergeError


-- | Types printing.
--   
--   Moved in a separate module, because we print via converting to untyped
--   <tt>T</tt> type to avoid duplication.
module Michelson.Typed.Print

-- | Format type stack in a pretty way.
buildStack :: [T] -> Builder
instance Formatting.Buildable.Buildable Michelson.Typed.T.T


-- | <a>TxData</a> type and associated functionality.
module Michelson.Runtime.TxData

-- | Data associated with a particular transaction.
data TxData
TxData :: !Address -> !Value -> !Mutez -> TxData
[tdSenderAddress] :: TxData -> !Address
[tdParameter] :: TxData -> !Value
[tdAmount] :: TxData -> !Mutez
tdSenderAddressL :: Lens' TxData Address
tdParameterL :: Lens' TxData Value
tdAmountL :: Lens' TxData Mutez
instance GHC.Classes.Eq Michelson.Runtime.TxData.TxData
instance GHC.Show.Show Michelson.Runtime.TxData.TxData


-- | Module, containing CValue data type which represents Michelson
--   comparable values.
module Michelson.Typed.CValue

-- | Representation of comparable value in Michelson language.
--   
--   By specification, we're allowed to compare only following types: int,
--   nat, string, bytes, mutez, bool, key_hash, timestamp, address.
--   
--   Only these values can be used as map keys or set elements.
data CValue t
[CvInt] :: Integer -> CValue  'CInt
[CvNat] :: Natural -> CValue  'CNat
[CvString] :: MText -> CValue  'CString
[CvBytes] :: ByteString -> CValue  'CBytes
[CvMutez] :: Mutez -> CValue  'CMutez
[CvBool] :: Bool -> CValue  'CBool
[CvKeyHash] :: KeyHash -> CValue  'CKeyHash
[CvTimestamp] :: Timestamp -> CValue  'CTimestamp
[CvAddress] :: Address -> CValue  'CAddress
instance GHC.Show.Show (Michelson.Typed.CValue.CValue t)
instance GHC.Classes.Eq (Michelson.Typed.CValue.CValue t)
instance GHC.Classes.Ord (Michelson.Typed.CValue.CValue t)


-- | Module, containing data types for Michelson value.
module Michelson.Typed.Value

-- | Representation of Michelson value.
--   
--   Type parameter <tt>instr</tt> stands for Michelson instruction type,
--   i.e. data type to represent an instruction of language.
data Value' instr t
[VC] :: CValue t -> Value' instr ( 'Tc t)
[VKey] :: PublicKey -> Value' instr  'TKey
[VUnit] :: Value' instr  'TUnit
[VSignature] :: Signature -> Value' instr  'TSignature
[VOption] :: forall t instr. Maybe (Value' instr t) -> Value' instr ( 'TOption t)
[VList] :: forall t instr. [Value' instr t] -> Value' instr ( 'TList t)
[VSet] :: forall t instr. Set (CValue t) -> Value' instr ( 'TSet t)
[VOp] :: Operation' instr -> Value' instr  'TOperation
[VContract] :: forall p instr. Address -> Value' instr ( 'TContract p)
[VPair] :: forall l r instr. (Value' instr l, Value' instr r) -> Value' instr ( 'TPair l r)
[VOr] :: forall l r instr. Either (Value' instr l) (Value' instr r) -> Value' instr ( 'TOr l r)
[VLam] :: forall inp out instr. (Show (instr '[inp] '[out]), Eq (instr '[inp] '[out])) => instr (inp : '[]) (out : '[]) -> Value' instr ( 'TLambda inp out)
[VMap] :: forall k v instr. Map (CValue k) (Value' instr v) -> Value' instr ( 'TMap k v)
[VBigMap] :: forall k v instr. Map (CValue k) (Value' instr v) -> Value' instr ( 'TBigMap k v)
data SomeValue' instr
[SomeValue] :: (Typeable t, SingI t) => Value' instr t -> SomeValue' instr
type ContractInp1 param st =  'TPair param st
type ContractInp param st = '[ContractInp1 param st]
type ContractOut1 st =  'TPair ( 'TList  'TOperation) st
type ContractOut st = '[ContractOut1 st]
data CreateAccount
CreateAccount :: !KeyHash -> !Maybe KeyHash -> !Bool -> !Mutez -> CreateAccount
[caManager] :: CreateAccount -> !KeyHash
[caDelegate] :: CreateAccount -> !Maybe KeyHash
[caSpendable] :: CreateAccount -> !Bool
[caBalance] :: CreateAccount -> !Mutez
data CreateContract instr cp st
CreateContract :: !KeyHash -> !Maybe KeyHash -> !Bool -> !Bool -> !Mutez -> !Value' instr st -> !instr (ContractInp cp st) (ContractOut st) -> CreateContract instr cp st
[ccManager] :: CreateContract instr cp st -> !KeyHash
[ccDelegate] :: CreateContract instr cp st -> !Maybe KeyHash
[ccSpendable] :: CreateContract instr cp st -> !Bool
[ccDelegatable] :: CreateContract instr cp st -> !Bool
[ccBalance] :: CreateContract instr cp st -> !Mutez
[ccStorageVal] :: CreateContract instr cp st -> !Value' instr st
[ccContractCode] :: CreateContract instr cp st -> !instr (ContractInp cp st) (ContractOut st)

-- | Representation of comparable value in Michelson language.
--   
--   By specification, we're allowed to compare only following types: int,
--   nat, string, bytes, mutez, bool, key_hash, timestamp, address.
--   
--   Only these values can be used as map keys or set elements.
data CValue t
[CvInt] :: Integer -> CValue  'CInt
[CvNat] :: Natural -> CValue  'CNat
[CvString] :: MText -> CValue  'CString
[CvBytes] :: ByteString -> CValue  'CBytes
[CvMutez] :: Mutez -> CValue  'CMutez
[CvBool] :: Bool -> CValue  'CBool
[CvKeyHash] :: KeyHash -> CValue  'CKeyHash
[CvTimestamp] :: Timestamp -> CValue  'CTimestamp
[CvAddress] :: Address -> CValue  'CAddress

-- | Data type, representing operation, list of which is returned by
--   Michelson contract (according to calling convention).
--   
--   These operations are to be further executed against system state after
--   the contract execution.
data Operation' instr
[OpTransferTokens] :: (Typeable p, SingI p, HasNoOp p) => TransferTokens instr p -> Operation' instr
[OpSetDelegate] :: SetDelegate -> Operation' instr
[OpCreateAccount] :: CreateAccount -> Operation' instr
[OpCreateContract] :: (Show (instr (ContractInp cp st) (ContractOut st)), SingI cp, SingI st, Typeable instr, Typeable cp, Typeable st, HasNoOp cp, HasNoOp st) => CreateContract instr cp st -> Operation' instr
data SetDelegate
SetDelegate :: !Maybe KeyHash -> SetDelegate
[sdMbKeyHash] :: SetDelegate -> !Maybe KeyHash
data TransferTokens instr p
TransferTokens :: !Value' instr p -> !Mutez -> !Value' instr ( 'TContract p) -> TransferTokens instr p
[ttContractParameter] :: TransferTokens instr p -> !Value' instr p
[ttAmount] :: TransferTokens instr p -> !Mutez
[ttContract] :: TransferTokens instr p -> !Value' instr ( 'TContract p)
instance GHC.Classes.Eq (Michelson.Typed.Value.TransferTokens instr p)
instance GHC.Show.Show (Michelson.Typed.Value.TransferTokens instr p)
instance GHC.Classes.Eq Michelson.Typed.Value.CreateAccount
instance GHC.Show.Show Michelson.Typed.Value.CreateAccount
instance GHC.Classes.Eq Michelson.Typed.Value.SetDelegate
instance GHC.Show.Show Michelson.Typed.Value.SetDelegate
instance GHC.Show.Show (Michelson.Typed.Value.Operation' instr)
instance GHC.Show.Show (Michelson.Typed.Value.CreateContract instr cp st)
instance GHC.Classes.Eq (Michelson.Typed.Value.CreateContract instr cp st)
instance GHC.Show.Show (Michelson.Typed.Value.Value' instr t)
instance GHC.Classes.Eq (Michelson.Typed.Value.Value' instr t)
instance GHC.Show.Show (Michelson.Typed.Value.SomeValue' instr)
instance GHC.Classes.Eq (Michelson.Typed.Value.SomeValue' instr)
instance Formatting.Buildable.Buildable (Michelson.Typed.Value.Operation' instr)
instance GHC.Classes.Eq (Michelson.Typed.Value.Operation' instr)
instance Formatting.Buildable.Buildable (Michelson.Typed.Value.TransferTokens instr p)
instance Formatting.Buildable.Buildable (Michelson.Typed.Value.CreateContract instr cp st)
instance Formatting.Buildable.Buildable Michelson.Typed.Value.CreateAccount
instance Formatting.Buildable.Buildable Michelson.Typed.Value.SetDelegate


-- | Module, containing type classes for operating with Michelson values in
--   the context of polymorphic stack type operations.
module Michelson.Typed.Polymorphic
class EDivOp (n :: CT) (m :: CT) where {
    type family EDivOpRes n m :: CT;
    type family EModOpRes n m :: CT;
}
evalEDivOp :: EDivOp n m => CValue n -> CValue m -> Value' instr ( 'TOption ( 'TPair ( 'Tc (EDivOpRes n m)) ( 'Tc (EModOpRes n m))))
class MemOp (c :: T) where {
    type family MemOpKey c :: CT;
}
evalMem :: MemOp c => CValue (MemOpKey c) -> Value' cp c -> Bool
class MapOp (c :: T) where {
    type family MapOpInp c :: T;
    type family MapOpRes c :: T -> T;
}
mapOpToList :: MapOp c => Value' instr c -> [Value' instr (MapOpInp c)]
mapOpFromList :: MapOp c => Value' instr c -> [Value' instr b] -> Value' instr (MapOpRes c b)
class IterOp (c :: T) where {
    type family IterOpEl c :: T;
}
iterOpDetachOne :: IterOp c => Value' instr c -> (Maybe (Value' instr (IterOpEl c)), Value' instr c)
class SizeOp (c :: T)
evalSize :: SizeOp c => Value' cp c -> Int
class GetOp (c :: T) where {
    type family GetOpKey c :: CT;
    type family GetOpVal c :: T;
}
evalGet :: GetOp c => CValue (GetOpKey c) -> Value' cp c -> Maybe (Value' cp (GetOpVal c))
class UpdOp (c :: T) where {
    type family UpdOpKey c :: CT;
    type family UpdOpParams c :: T;
}
evalUpd :: UpdOp c => CValue (UpdOpKey c) -> Value' cp (UpdOpParams c) -> Value' cp c -> Value' cp c
class SliceOp (c :: T)
evalSlice :: SliceOp c => Natural -> Natural -> Value' cp c -> Maybe (Value' cp c)
class ConcatOp (c :: T)
evalConcat :: ConcatOp c => Value' cp c -> Value' cp c -> Value' cp c
evalConcat' :: ConcatOp c => [Value' cp c] -> Value' cp c
instance Michelson.Typed.Polymorphic.EDivOp 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Polymorphic.EDivOp 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Polymorphic.EDivOp 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Polymorphic.EDivOp 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Polymorphic.EDivOp 'Michelson.Untyped.Type.CMutez 'Michelson.Untyped.Type.CMutez
instance Michelson.Typed.Polymorphic.EDivOp 'Michelson.Untyped.Type.CMutez 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Polymorphic.SliceOp ('Michelson.Typed.T.Tc 'Michelson.Untyped.Type.CString)
instance Michelson.Typed.Polymorphic.SliceOp ('Michelson.Typed.T.Tc 'Michelson.Untyped.Type.CBytes)
instance Michelson.Typed.Polymorphic.ConcatOp ('Michelson.Typed.T.Tc 'Michelson.Untyped.Type.CString)
instance Michelson.Typed.Polymorphic.ConcatOp ('Michelson.Typed.T.Tc 'Michelson.Untyped.Type.CBytes)
instance Michelson.Typed.Polymorphic.GetOp ('Michelson.Typed.T.TBigMap k v)
instance Michelson.Typed.Polymorphic.GetOp ('Michelson.Typed.T.TMap k v)
instance Michelson.Typed.Polymorphic.UpdOp ('Michelson.Typed.T.TMap k v)
instance Michelson.Typed.Polymorphic.UpdOp ('Michelson.Typed.T.TBigMap k v)
instance Michelson.Typed.Polymorphic.UpdOp ('Michelson.Typed.T.TSet a)
instance Michelson.Typed.Polymorphic.SizeOp ('Michelson.Typed.T.Tc 'Michelson.Untyped.Type.CString)
instance Michelson.Typed.Polymorphic.SizeOp ('Michelson.Typed.T.Tc 'Michelson.Untyped.Type.CBytes)
instance Michelson.Typed.Polymorphic.SizeOp ('Michelson.Typed.T.TSet a)
instance Michelson.Typed.Polymorphic.SizeOp ('Michelson.Typed.T.TList a)
instance Michelson.Typed.Polymorphic.SizeOp ('Michelson.Typed.T.TMap k v)
instance Michelson.Typed.Polymorphic.IterOp ('Michelson.Typed.T.TMap k v)
instance Michelson.Typed.Polymorphic.IterOp ('Michelson.Typed.T.TList e)
instance Michelson.Typed.Polymorphic.IterOp ('Michelson.Typed.T.TSet e)
instance Michelson.Typed.Polymorphic.MapOp ('Michelson.Typed.T.TMap k v)
instance Michelson.Typed.Polymorphic.MapOp ('Michelson.Typed.T.TList e)
instance Michelson.Typed.Polymorphic.MemOp ('Michelson.Typed.T.TSet e)
instance Michelson.Typed.Polymorphic.MemOp ('Michelson.Typed.T.TMap k v)
instance Michelson.Typed.Polymorphic.MemOp ('Michelson.Typed.T.TBigMap k v)


-- | Module, containing some boilerplate for support of arithmetic
--   operations in Michelson language.
module Michelson.Typed.Arith

-- | Class for binary arithmetic operation.
--   
--   Takes binary operation marker as <tt>op</tt> parameter, types of left
--   operand <tt>n</tt> and right operand <tt>m</tt>.
class ArithOp aop (n :: CT) (m :: CT) where {
    
    -- | Type family <tt>ArithRes</tt> denotes the type resulting from
    --   computing operation <tt>op</tt> from operands of types <tt>n</tt> and
    --   <tt>m</tt>.
    --   
    --   For instance, adding integer to natural produces integer, which is
    --   reflected in following instance of type family: <tt>ArithRes Add CNat
    --   CInt = CInt</tt>.
    type family ArithRes aop n m :: CT;
}

-- | Evaluate arithmetic operation on given operands.
evalOp :: ArithOp aop n m => proxy aop -> CValue n -> CValue m -> Either (ArithError (CValue n) (CValue m)) (CValue (ArithRes aop n m))

-- | Marker data type for add operation.
class UnaryArithOp aop (n :: CT) where {
    type family UnaryArithRes aop n :: CT;
}
evalUnaryArithOp :: UnaryArithOp aop n => proxy aop -> CValue n -> CValue (UnaryArithRes aop n)

-- | Represents an arithmetic error of the operation.
data ArithError n m
MutezArithError :: ArithErrorType -> n -> m -> ArithError n m
ShiftArithError :: ArithErrorType -> n -> m -> ArithError n m

-- | Denotes the error type occured in the arithmetic operation.
data ArithErrorType
AddOverflow :: ArithErrorType
MulOverflow :: ArithErrorType
SubUnderflow :: ArithErrorType
LslOverflow :: ArithErrorType
LsrUnderflow :: ArithErrorType

-- | Class for comparison operations, special case of <a>ArithOp</a>.
class CompareOp n

-- | Evaluate compare operation.
compareOp :: CompareOp n => CValue n -> CValue n -> Integer
data Add
data Sub
data Mul
data Abs
data Neg
data Or
data And
data Xor
data Not
data Lsl
data Lsr
data Compare
data Eq'
data Neq
data Lt
data Gt
data Le
data Ge
instance (GHC.Classes.Ord n, GHC.Classes.Ord m) => GHC.Classes.Ord (Michelson.Typed.Arith.ArithError n m)
instance (GHC.Classes.Eq n, GHC.Classes.Eq m) => GHC.Classes.Eq (Michelson.Typed.Arith.ArithError n m)
instance (GHC.Show.Show n, GHC.Show.Show m) => GHC.Show.Show (Michelson.Typed.Arith.ArithError n m)
instance GHC.Classes.Ord Michelson.Typed.Arith.ArithErrorType
instance GHC.Classes.Eq Michelson.Typed.Arith.ArithErrorType
instance GHC.Show.Show Michelson.Typed.Arith.ArithErrorType
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Ge 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Le 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Gt 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Lt 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Neq 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Eq' 'Michelson.Untyped.Type.CInt
instance (n Data.Type.Equality.~ m, Michelson.Typed.Arith.CompareOp n) => Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Compare n m
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Lsr 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Lsl 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Not 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Not 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Not 'Michelson.Untyped.Type.CBool
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Xor 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Xor 'Michelson.Untyped.Type.CBool 'Michelson.Untyped.Type.CBool
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.And 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.And 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.And 'Michelson.Untyped.Type.CBool 'Michelson.Untyped.Type.CBool
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Or 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Or 'Michelson.Untyped.Type.CBool 'Michelson.Untyped.Type.CBool
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Neg 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Neg 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.UnaryArithOp Michelson.Typed.Arith.Abs 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Mul 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Mul 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Mul 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Mul 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Mul 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CMutez
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Mul 'Michelson.Untyped.Type.CMutez 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CTimestamp 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CTimestamp 'Michelson.Untyped.Type.CTimestamp
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Sub 'Michelson.Untyped.Type.CMutez 'Michelson.Untyped.Type.CMutez
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CNat 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CTimestamp 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CInt 'Michelson.Untyped.Type.CTimestamp
instance Michelson.Typed.Arith.ArithOp Michelson.Typed.Arith.Add 'Michelson.Untyped.Type.CMutez 'Michelson.Untyped.Type.CMutez
instance (GHC.Show.Show n, GHC.Show.Show m) => Formatting.Buildable.Buildable (Michelson.Typed.Arith.ArithError n m)
instance Formatting.Buildable.Buildable Michelson.Typed.Arith.ArithErrorType
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CBool
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CAddress
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CNat
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CInt
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CString
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CBytes
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CTimestamp
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CMutez
instance Michelson.Typed.Arith.CompareOp 'Michelson.Untyped.Type.CKeyHash


-- | Module, containing data types for Michelson value.
module Michelson.Typed.Instr

-- | Representation of Michelson instruction or sequence of instructions.
--   
--   Each Michelson instruction is represented by exactly one constructor
--   of this data type. Sequence of instructions is represented with use of
--   <tt>Seq</tt> constructor in following way: <tt>SWAP; DROP ; DUP;</tt>
--   -&gt; <tt>SWAP <a>Instr</a> DROP <a>Instr</a> DUP</tt>. Special case
--   where there are no instructions is represented by constructor
--   <tt>Nop</tt>, e.g. <tt>IF_NONE {} { SWAP; DROP; }</tt> -&gt;
--   <tt>IF_NONE Nop (SWAP <a>Instr</a> DROP)</tt>.
--   
--   Type parameter <tt>inp</tt> states for input stack type. That is, type
--   of the stack that is required for operation to execute.
--   
--   Type parameter <tt>out</tt> states for output stack type or type of
--   stack that will be left after instruction's execution.
data Instr (inp :: [T]) (out :: [T])

-- | A wrapper for instruction that also contain annotations for the top
--   type on the result stack.
--   
--   As of now, when converting from untyped representation, we only
--   preserve field annotations and type annotations. Variable annotations
--   are not preserved.
[InstrWithNotes] :: PackedNotes b -> Instr a b -> Instr a b
[Seq] :: Instr a b -> Instr b c -> Instr a c

-- | Nop operation. Missing in Michelson spec, added to parse construction
--   like `IF {} { SWAP; DROP; }`.
[Nop] :: Instr s s
[Ext] :: ExtInstr s -> Instr s s

-- | Nested wrapper is going to wrap a sequence of instructions with { }.
--   It is crucial because serialisation of a contract depends on precise
--   structure of its code.
[Nested] :: Instr inp out -> Instr inp out

-- | Places documentation generated for given instruction under some group.
--   This is not part of <a>ExtInstr</a> because it does not behave like
--   <a>Nop</a>; instead, it inherits behaviour of instruction put within
--   it.
[DocGroup] :: DocGrouping -> Instr inp out -> Instr inp out

-- | Variants of CAR/CDR to retain field annotations as they relate to the
--   input stack, and hence won't be available from the annotation notes
--   from the result stack we pack with the instructions during type check.
[AnnCAR] :: FieldAnn -> Instr ( 'TPair a b : s) (a : s)
[AnnCDR] :: FieldAnn -> Instr ( 'TPair a b : s) (b : s)
[DROP] :: Instr (a : s) s
[DUP] :: Instr (a : s) (a : (a : s))
[SWAP] :: Instr (a : (b : s)) (b : (a : s))
[PUSH] :: forall t s. (SingI t, HasNoOp t, HasNoBigMap t) => Value' Instr t -> Instr s (t : s)
[SOME] :: Instr (a : s) ( 'TOption a : s)
[NONE] :: forall a s. SingI a => Instr s ( 'TOption a : s)
[UNIT] :: Instr s ( 'TUnit : s)
[IF_NONE] :: Instr s s' -> Instr (a : s) s' -> Instr ( 'TOption a : s) s'
[PAIR] :: Instr (a : (b : s)) ( 'TPair a b : s)
[LEFT] :: forall b a s. SingI b => Instr (a : s) ( 'TOr a b : s)
[RIGHT] :: forall a b s. SingI a => Instr (b : s) ( 'TOr a b : s)
[IF_LEFT] :: Instr (a : s) s' -> Instr (b : s) s' -> Instr ( 'TOr a b : s) s'
[NIL] :: SingI p => Instr s ( 'TList p : s)
[CONS] :: Instr (a : ( 'TList a : s)) ( 'TList a : s)
[IF_CONS] :: Instr (a : ( 'TList a : s)) s' -> Instr s s' -> Instr ( 'TList a : s) s'
[SIZE] :: SizeOp c => Instr (c : s) ( 'Tc  'CNat : s)
[EMPTY_SET] :: (Typeable e, SingI e) => Instr s ( 'TSet e : s)
[EMPTY_MAP] :: (Typeable a, Typeable b, SingI a, SingI b) => Instr s ( 'TMap a b : s)
[MAP] :: MapOp c => Instr (MapOpInp c : s) (b : s) -> Instr (c : s) (MapOpRes c b : s)
[ITER] :: IterOp c => Instr (IterOpEl c : s) s -> Instr (c : s) s
[MEM] :: MemOp c => Instr ( 'Tc (MemOpKey c) : (c : s)) ( 'Tc  'CBool : s)
[GET] :: GetOp c => Instr ( 'Tc (GetOpKey c) : (c : s)) ( 'TOption (GetOpVal c) : s)
[UPDATE] :: UpdOp c => Instr ( 'Tc (UpdOpKey c) : (UpdOpParams c : (c : s))) (c : s)
[IF] :: Instr s s' -> Instr s s' -> Instr ( 'Tc  'CBool : s) s'
[LOOP] :: Instr s ( 'Tc  'CBool : s) -> Instr ( 'Tc  'CBool : s) s
[LOOP_LEFT] :: Instr (a : s) ( 'TOr a b : s) -> Instr ( 'TOr a b : s) (b : s)
[LAMBDA] :: forall i o s. Each [Typeable, SingI] [i, o] => Value' Instr ( 'TLambda i o) -> Instr s ( 'TLambda i o : s)
[EXEC] :: Instr (t1 : ( 'TLambda t1 t2 : s)) (t2 : s)
[DIP] :: Instr a c -> Instr (b : a) (b : c)
[FAILWITH] :: (Typeable a, SingI a) => Instr (a : s) t
[CAST] :: forall a s. SingI a => Instr (a : s) (a : s)
[RENAME] :: Instr (a : s) (a : s)
[PACK] :: (SingI a, HasNoOp a, HasNoBigMap a) => Instr (a : s) ( 'Tc  'CBytes : s)
[UNPACK] :: (SingI a, HasNoOp a, HasNoBigMap a) => Instr ( 'Tc  'CBytes : s) ( 'TOption a : s)
[CONCAT] :: ConcatOp c => Instr (c : (c : s)) (c : s)
[CONCAT'] :: ConcatOp c => Instr ( 'TList c : s) (c : s)
[SLICE] :: SliceOp c => Instr ( 'Tc  'CNat : ( 'Tc  'CNat : (c : s))) ( 'TOption c : s)
[ISNAT] :: Instr ( 'Tc  'CInt : s) ( 'TOption ( 'Tc  'CNat) : s)
[ADD] :: (ArithOp Add n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Add n m) : s)
[SUB] :: (ArithOp Sub n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Sub n m) : s)
[MUL] :: (ArithOp Mul n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Mul n m) : s)
[EDIV] :: EDivOp n m => Instr ( 'Tc n : ( 'Tc m : s)) ( 'TOption ( 'TPair ( 'Tc (EDivOpRes n m)) ( 'Tc (EModOpRes n m))) : s)
[ABS] :: UnaryArithOp Abs n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Abs n) : s)
[NEG] :: UnaryArithOp Neg n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Neg n) : s)
[LSL] :: (ArithOp Lsl n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Lsl n m) : s)
[LSR] :: (ArithOp Lsr n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Lsr n m) : s)
[OR] :: (ArithOp Or n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Or n m) : s)
[AND] :: (ArithOp And n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes And n m) : s)
[XOR] :: (ArithOp Xor n m, Typeable n, Typeable m) => Instr ( 'Tc n : ( 'Tc m : s)) ( 'Tc (ArithRes Xor n m) : s)
[NOT] :: UnaryArithOp Not n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Not n) : s)
[COMPARE] :: (ArithOp Compare n n, Typeable n) => Instr ( 'Tc n : ( 'Tc n : s)) ( 'Tc (ArithRes Compare n n) : s)
[EQ] :: UnaryArithOp Eq' n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Eq' n) : s)
[NEQ] :: UnaryArithOp Neq n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Neq n) : s)
[LT] :: UnaryArithOp Lt n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Lt n) : s)
[GT] :: UnaryArithOp Gt n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Gt n) : s)
[LE] :: UnaryArithOp Le n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Le n) : s)
[GE] :: UnaryArithOp Ge n => Instr ( 'Tc n : s) ( 'Tc (UnaryArithRes Ge n) : s)
[INT] :: Instr ( 'Tc  'CNat : s) ( 'Tc  'CInt : s)
[SELF] :: forall (cp :: T) s. Instr s ( 'TContract cp : s)
[CONTRACT] :: (SingI p, Typeable p) => Notes p -> Instr ( 'Tc  'CAddress : s) ( 'TOption ( 'TContract p) : s)
[TRANSFER_TOKENS] :: (Typeable p, SingI p, HasNoOp p, HasNoBigMap p) => Instr (p : ( 'Tc  'CMutez : ( 'TContract p : s))) ( 'TOperation : s)
[SET_DELEGATE] :: Instr ( 'TOption ( 'Tc  'CKeyHash) : s) ( 'TOperation : s)
[CREATE_ACCOUNT] :: Instr ( 'Tc  'CKeyHash : ( 'TOption ( 'Tc  'CKeyHash) : ( 'Tc  'CBool : ( 'Tc  'CMutez : s)))) ( 'TOperation : ( 'Tc  'CAddress : s))
[CREATE_CONTRACT] :: (Each [Typeable, SingI, HasNoOp] [p, g], HasNoBigMap p, BigMapConstraint g) => Instr '[ 'TPair p g] '[ 'TPair ( 'TList  'TOperation) g] -> Instr ( 'Tc  'CKeyHash : ( 'TOption ( 'Tc  'CKeyHash) : ( 'Tc  'CBool : ( 'Tc  'CBool : ( 'Tc  'CMutez : (g : s)))))) ( 'TOperation : ( 'Tc  'CAddress : s))
[IMPLICIT_ACCOUNT] :: Instr ( 'Tc  'CKeyHash : s) ( 'TContract  'TUnit : s)
[NOW] :: Instr s ( 'Tc  'CTimestamp : s)
[AMOUNT] :: Instr s ( 'Tc  'CMutez : s)
[BALANCE] :: Instr s ( 'Tc  'CMutez : s)
[CHECK_SIGNATURE] :: Instr ( 'TKey : ( 'TSignature : ( 'Tc  'CBytes : s))) ( 'Tc  'CBool : s)
[SHA256] :: Instr ( 'Tc  'CBytes : s) ( 'Tc  'CBytes : s)
[SHA512] :: Instr ( 'Tc  'CBytes : s) ( 'Tc  'CBytes : s)
[BLAKE2B] :: Instr ( 'Tc  'CBytes : s) ( 'Tc  'CBytes : s)
[HASH_KEY] :: Instr ( 'TKey : s) ( 'Tc  'CKeyHash : s)
[STEPS_TO_QUOTA] :: Instr s ( 'Tc  'CNat : s)
[SOURCE] :: Instr s ( 'Tc  'CAddress : s)
[SENDER] :: Instr s ( 'Tc  'CAddress : s)
[ADDRESS] :: Instr ( 'TContract a : s) ( 'Tc  'CAddress : s)
data ExtInstr s
TEST_ASSERT :: TestAssert s -> ExtInstr s
PRINT :: PrintComment s -> ExtInstr s
DOC_ITEM :: SomeDocItem -> ExtInstr s

-- | A reference into the stack of a given type.
data StackRef (st :: [T])

-- | Keeps 0-based index to a stack element counting from the top.
[StackRef] :: (KnownPeano idx, LongerThan st idx) => Sing (idx :: Peano) -> StackRef st

-- | Create a stack reference, performing checks at compile time.
mkStackRef :: forall (gn :: Nat) st n. (n ~ ToPeano gn, SingI n, KnownPeano n, RequireLongerThan st n) => StackRef st

-- | A print format with references into the stack
newtype PrintComment (st :: [T])
PrintComment :: [Either Text (StackRef st)] -> PrintComment
[unPrintComment] :: PrintComment -> [Either Text (StackRef st)]
data TestAssert (s :: [T])
[TestAssert] :: Typeable out => Text -> PrintComment inp -> Instr inp ( 'Tc  'CBool : out) -> TestAssert inp
type Contract cp st = Instr (ContractInp cp st) (ContractOut st)

-- | Typed contract and information about annotations which is not present
--   in the contract code.
data FullContract cp st
FullContract :: Contract cp st -> Sing (ContractInp1 cp st) -> Notes (ContractInp1 cp st) -> FullContract cp st
[fcContract] :: FullContract cp st -> Contract cp st
[fcInpSing] :: FullContract cp st -> Sing (ContractInp1 cp st)
[fcInpNotes] :: FullContract cp st -> Notes (ContractInp1 cp st)

-- | Lift a contract to <a>FullContract</a> without proving any additional
--   information.
toFullContract :: Each [Typeable, SingI] [cp, st] => Contract cp st -> FullContract cp st
pattern CAR :: Instr ( 'TPair a b : s) (a : s)
pattern CDR :: Instr ( 'TPair a b : s) (b : s)

-- | A wrapper to wrap annotations and corresponding singleton. Apart from
--   packing notes along with the corresponding Singleton, this wrapper
--   type, when included with <a>Instr</a> also helps to derive the
--   <a>Show</a> instance for <a>Instr</a> as `Sing a` does not have a
--   <a>Show</a> instance on its own.
data PackedNotes a
[PackedNotes] :: Notes a -> Sing a -> PackedNotes (a : s)
instance GHC.Show.Show (Michelson.Typed.Instr.ExtInstr s)
instance GHC.Base.Monoid (Michelson.Typed.Instr.PrintComment st)
instance GHC.Base.Semigroup (Michelson.Typed.Instr.PrintComment st)
instance GHC.Generics.Generic (Michelson.Typed.Instr.PrintComment st)
instance GHC.Show.Show (Michelson.Typed.Instr.PrintComment st)
instance GHC.Classes.Eq (Michelson.Typed.Instr.PrintComment st)
instance GHC.Show.Show (Michelson.Typed.Instr.Instr inp out)
instance GHC.Show.Show (Michelson.Typed.Instr.TestAssert s)
instance Data.String.IsString (Michelson.Typed.Instr.PrintComment st)
instance GHC.Classes.Eq (Michelson.Typed.Instr.StackRef st)
instance GHC.Show.Show (Michelson.Typed.Instr.StackRef st)
instance GHC.Show.Show (Michelson.Typed.Instr.PackedNotes a)


-- | General-purpose utility functions for typed types.
module Michelson.Typed.Util

-- | Traverse a typed instruction in depth-first order. <a>&lt;&gt;</a> is
--   used to concatenate intermediate results. First argument specifies
--   whether this function should go into values which contains other
--   instructions: lambdas and constant contracts (which can be passed to
--   <tt>CREATE_CONTRACT</tt>). Each instructions can be changed using the
--   supplied function. It does not consider extra instructions (not
--   present in Michelson).
dfsInstr :: forall x inp out. Semigroup x => Bool -> (forall i o. Instr i o -> (Instr i o, x)) -> Instr inp out -> (Instr inp out, x)


-- | Extracting documentation from instructions set.
module Michelson.Typed.DocScan

-- | Assemble contract documentation.
buildInstrDoc :: Instr inp out -> ContractDoc

-- | Recursevly traverse an instruction and modify documentation items
--   matching given type.
modifyInstrDoc :: DocItem i => (i -> i) -> Instr inp out -> Instr inp out

module Michelson.Typed.Convert
convertContract :: forall param store. (SingI param, SingI store) => Contract param store -> Contract
convertFullContract :: forall param store. (SingI param, SingI store) => FullContract param store -> Contract
instrToOps :: HasCallStack => Instr inp out -> [ExpandedOp]

-- | Convert a typed <tt>Val</tt> to an untyped <tt>Value</tt>.
--   
--   For full isomorphism type of the given <tt>Val</tt> should not contain
--   <a>TOperation</a> - a compile error will be raised otherwise. You can
--   analyse its presence with <a>checkOpPresence</a> function.
untypeValue :: forall t. (SingI t, HasNoOp t) => Value' Instr t -> Value
instance GHC.Classes.Eq (Michelson.Typed.Instr.Instr inp out)
instance Data.Typeable.Internal.Typeable s => GHC.Classes.Eq (Michelson.Typed.Instr.TestAssert s)

module Michelson.Typed.Aliases
type Value = Value' Instr
type SomeValue = SomeValue' Instr
type Operation = Operation' Instr


-- | Conversions between haskell types/values and Michelson ones.
module Michelson.Typed.Haskell.Value

-- | Isomorphism between Michelson primitive values and plain Haskell
--   types.
class IsoCValue a where {
    
    -- | Type function that converts a regular Haskell type into a comparable
    --   type (which has kind <tt>CT</tt>).
    type family ToCT a :: CT;
}

-- | Converts a single Haskell value into <tt>CVal</tt> representation.
toCVal :: IsoCValue a => a -> CValue (ToCT a)

-- | Converts a <tt>CVal</tt> value into a single Haskell value.
fromCVal :: IsoCValue a => CValue (ToCT a) -> a

-- | Isomorphism between Michelson values and plain Haskell types.
--   
--   Default implementation of this typeclass converts ADTs to Michelson
--   "pair"s and "or"s.
class IsoValue a where {
    
    -- | Type function that converts a regular Haskell type into a <tt>T</tt>
    --   type.
    type family ToT a :: T;
    type ToT a = GValueType (Rep a);
}

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: IsoValue a => a -> Value (ToT a)

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: (IsoValue a, Generic a, GIsoValue (Rep a), ToT a ~ GValueType (Rep a)) => a -> Value (ToT a)

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: IsoValue a => Value (ToT a) -> a

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: (IsoValue a, Generic a, GIsoValue (Rep a), ToT a ~ GValueType (Rep a)) => Value (ToT a) -> a

-- | Implements ADT conversion to Michelson value.
--   
--   Thanks to Generic, Michelson representation will be a balanced tree;
--   this reduces average access time in general case.
--   
--   A drawback of such approach is that, in theory, in new GHC version
--   generified representation may change; however, chances are small and I
--   (martoon) believe that contract versions will change much faster
--   anyway.
class GIsoValue (x :: Type -> Type) where {
    type family GValueType x :: T;
}

-- | Overloaded version of <a>ToT</a> to work on Haskell and <tt>T</tt>
--   types.
type family ToT' (t :: k) :: T

-- | Hides some Haskell value put in line with Michelson <a>Value</a>.
data SomeIsoValue
[SomeIsoValue] :: (Typeable a, IsoValue a) => a -> SomeIsoValue

-- | Any Haskell value which can be converted to Michelson <a>Value</a>.
newtype AnyIsoValue
AnyIsoValue :: (forall a. IsoValue a => a) -> AnyIsoValue

-- | A useful property which holds for all <a>CT</a> types.
type IsComparable c = ToT c ~  'Tc (ToCT c)

-- | Whether Michelson representation of the type is derived via Generics.
type IsGenericIsoValue t = (IsoValue t, Generic t, ToT t ~ GValueType (Rep t))

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
newtype ContractAddr (cp :: Type)
ContractAddr :: Address -> ContractAddr
[unContractAddress] :: ContractAddr -> Address
newtype BigMap k v
BigMap :: Map k v -> BigMap k v
[unBigMap] :: BigMap k v -> Map k v

-- | Type function to convert a Haskell stack type to <tt>T</tt>-based one.
type family ToTs (ts :: [Type]) :: [T]

-- | Overloaded version of <a>ToTs</a> to work on Haskell and <tt>T</tt>
--   stacks.
type family ToTs' (t :: [k]) :: [T]

-- | Isomorphism between Michelson stack and its Haskell reflection.
class IsoValuesStack (ts :: [Type])
toValStack :: IsoValuesStack ts => Rec Identity ts -> Rec Value (ToTs ts)
fromValStack :: IsoValuesStack ts => Rec Value (ToTs ts) -> Rec Identity ts
instance GHC.Classes.Ord k => GHC.Base.Monoid (Michelson.Typed.Haskell.Value.BigMap k v)
instance GHC.Classes.Ord k => GHC.Base.Semigroup (Michelson.Typed.Haskell.Value.BigMap k v)
instance Data.Default.Class.Default (Michelson.Typed.Haskell.Value.BigMap k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Michelson.Typed.Haskell.Value.BigMap k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Michelson.Typed.Haskell.Value.BigMap k v)
instance Formatting.Buildable.Buildable (Michelson.Typed.Haskell.Value.ContractAddr cp)
instance GHC.Classes.Eq (Michelson.Typed.Haskell.Value.ContractAddr cp)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Data.Functor.Identity.Identity a)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Named.Internal.NamedF Data.Functor.Identity.Identity a name)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Named.Internal.NamedF GHC.Maybe.Maybe a name)
instance Michelson.Typed.Haskell.Value.IsoValuesStack '[]
instance (Michelson.Typed.Haskell.Value.IsoValue t, Michelson.Typed.Haskell.Value.IsoValuesStack st) => Michelson.Typed.Haskell.Value.IsoValuesStack (t : st)
instance Michelson.Typed.Haskell.Value.IsoValue GHC.Integer.Type.Integer
instance Michelson.Typed.Haskell.Value.IsoValue GHC.Natural.Natural
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Text.MText
instance Michelson.Text.DoNotUseTextError => Michelson.Typed.Haskell.Value.IsoValue Data.Text.Internal.Text
instance Michelson.Typed.Haskell.Value.IsoValue GHC.Types.Bool
instance Michelson.Typed.Haskell.Value.IsoValue Data.ByteString.Internal.ByteString
instance Michelson.Typed.Haskell.Value.IsoValue Tezos.Core.Mutez
instance Michelson.Typed.Haskell.Value.IsoValue Tezos.Crypto.KeyHash
instance Michelson.Typed.Haskell.Value.IsoValue Tezos.Core.Timestamp
instance Michelson.Typed.Haskell.Value.IsoValue Tezos.Address.Address
instance Michelson.Typed.Haskell.Value.IsoValue Tezos.Crypto.PublicKey
instance Michelson.Typed.Haskell.Value.IsoValue Tezos.Crypto.Signature
instance Michelson.Typed.Haskell.Value.IsoValue ()
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue [a]
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (GHC.Maybe.Maybe a)
instance (Michelson.Typed.Haskell.Value.IsoValue l, Michelson.Typed.Haskell.Value.IsoValue r) => Michelson.Typed.Haskell.Value.IsoValue (Data.Either.Either l r)
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Haskell.Value.IsoValue b) => Michelson.Typed.Haskell.Value.IsoValue (a, b)
instance (GHC.Classes.Ord c, Michelson.Typed.Haskell.Value.IsoCValue c) => Michelson.Typed.Haskell.Value.IsoValue (Data.Set.Internal.Set c)
instance (GHC.Classes.Ord k, Michelson.Typed.Haskell.Value.IsoCValue k, Michelson.Typed.Haskell.Value.IsoValue v) => Michelson.Typed.Haskell.Value.IsoValue (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Typed.Aliases.Operation
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Haskell.Value.IsoValue b, Michelson.Typed.Haskell.Value.IsoValue c) => Michelson.Typed.Haskell.Value.IsoValue (a, b, c)
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Haskell.Value.IsoValue b, Michelson.Typed.Haskell.Value.IsoValue c, Michelson.Typed.Haskell.Value.IsoValue d) => Michelson.Typed.Haskell.Value.IsoValue (a, b, c, d)
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Haskell.Value.IsoValue b, Michelson.Typed.Haskell.Value.IsoValue c, Michelson.Typed.Haskell.Value.IsoValue d, Michelson.Typed.Haskell.Value.IsoValue e) => Michelson.Typed.Haskell.Value.IsoValue (a, b, c, d, e)
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Haskell.Value.IsoValue b, Michelson.Typed.Haskell.Value.IsoValue c, Michelson.Typed.Haskell.Value.IsoValue d, Michelson.Typed.Haskell.Value.IsoValue e, Michelson.Typed.Haskell.Value.IsoValue f) => Michelson.Typed.Haskell.Value.IsoValue (a, b, c, d, e, f)
instance (Michelson.Typed.Haskell.Value.IsoValue a, Michelson.Typed.Haskell.Value.IsoValue b, Michelson.Typed.Haskell.Value.IsoValue c, Michelson.Typed.Haskell.Value.IsoValue d, Michelson.Typed.Haskell.Value.IsoValue e, Michelson.Typed.Haskell.Value.IsoValue f, Michelson.Typed.Haskell.Value.IsoValue g) => Michelson.Typed.Haskell.Value.IsoValue (a, b, c, d, e, f, g)
instance Michelson.Typed.Haskell.Value.IsoValue (Michelson.Typed.Haskell.Value.ContractAddr cp)
instance (GHC.Classes.Ord k, Michelson.Typed.Haskell.Value.IsoCValue k, Michelson.Typed.Haskell.Value.IsoValue v) => Michelson.Typed.Haskell.Value.IsoValue (Michelson.Typed.Haskell.Value.BigMap k v)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.GIsoValue (GHC.Generics.Rec0 a)
instance Michelson.Typed.Haskell.Value.GIsoValue x => Michelson.Typed.Haskell.Value.GIsoValue (GHC.Generics.M1 t i x)
instance (Michelson.Typed.Haskell.Value.GIsoValue x, Michelson.Typed.Haskell.Value.GIsoValue y) => Michelson.Typed.Haskell.Value.GIsoValue (x GHC.Generics.:+: y)
instance (Michelson.Typed.Haskell.Value.GIsoValue x, Michelson.Typed.Haskell.Value.GIsoValue y) => Michelson.Typed.Haskell.Value.GIsoValue (x GHC.Generics.:*: y)
instance Michelson.Typed.Haskell.Value.GIsoValue GHC.Generics.U1
instance Michelson.Typed.Haskell.Value.IsoCValue GHC.Integer.Type.Integer
instance Michelson.Typed.Haskell.Value.IsoCValue GHC.Natural.Natural
instance Michelson.Typed.Haskell.Value.IsoCValue Michelson.Text.MText
instance Michelson.Text.DoNotUseTextError => Michelson.Typed.Haskell.Value.IsoCValue Data.Text.Internal.Text
instance Michelson.Typed.Haskell.Value.IsoCValue GHC.Types.Bool
instance Michelson.Typed.Haskell.Value.IsoCValue Data.ByteString.Internal.ByteString
instance Michelson.Typed.Haskell.Value.IsoCValue Tezos.Core.Mutez
instance Michelson.Typed.Haskell.Value.IsoCValue Tezos.Address.Address
instance Michelson.Typed.Haskell.Value.IsoCValue Tezos.Crypto.KeyHash
instance Michelson.Typed.Haskell.Value.IsoCValue Tezos.Core.Timestamp


-- | Instructions working on product types derived from Haskell ones.
module Michelson.Typed.Haskell.Instr.Product

-- | Constraint for <a>instrGetField</a>.
type InstrGetFieldC dt name = (IsoValue dt, Generic dt, GInstrGet name (Rep dt) (LnrBranch (GetNamed name dt)) (LnrFieldType (GetNamed name dt)), GValueType (Rep dt) ~ ToT dt)

-- | Constraint for <a>instrSetField</a>.
type InstrSetFieldC dt name = (IsoValue dt, Generic dt, GInstrSetField name (Rep dt) (LnrBranch (GetNamed name dt)) (LnrFieldType (GetNamed name dt)), GValueType (Rep dt) ~ ToT dt)

-- | Constraint for <a>instrConstruct</a>.
type InstrConstructC dt = (IsoValue dt, Generic dt, GInstrConstruct (Rep dt), GValueType (Rep dt) ~ ToT dt)

-- | Make an instruction which accesses given field of the given datatype.
instrGetField :: forall dt name st. InstrGetFieldC dt name => Label name -> Instr (ToT dt : st) (ToT (GetFieldType dt name) : st)

-- | For given complex type <tt>dt</tt> and its field <tt>fieldTy</tt>
--   update the field value.
instrSetField :: forall dt name st. InstrSetFieldC dt name => Label name -> Instr (ToT (GetFieldType dt name) : (ToT dt : st)) (ToT dt : st)

-- | For given complex type <tt>dt</tt> and its field <tt>fieldTy</tt>
--   update the field value.
instrConstruct :: forall dt st. InstrConstructC dt => Rec (FieldConstructor st) (ConstructorFieldTypes dt) -> Instr st (ToT dt : st)

-- | Get type of field by datatype it is contained in and field name.
type GetFieldType dt name = LnrFieldType (GetNamed name dt)

-- | Types of all fields in a datatype.
type ConstructorFieldTypes dt = GFieldTypes (Rep dt)

-- | Way to construct one of the fields in a complex datatype.
newtype FieldConstructor (st :: [k]) (field :: Type)
FieldConstructor :: Instr (ToTs' st) (ToT field : ToTs' st) -> FieldConstructor
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Typed.Haskell.Instr.Product.MyType2
instance GHC.Generics.Generic Michelson.Typed.Haskell.Instr.Product.MyType2
instance Michelson.Typed.Haskell.Instr.Product.GInstrConstruct x => Michelson.Typed.Haskell.Instr.Product.GInstrConstruct (GHC.Generics.M1 t i x)
instance (Michelson.Typed.Haskell.Instr.Product.GInstrConstruct x, Michelson.Typed.Haskell.Instr.Product.GInstrConstruct y, Michelson.Typed.Haskell.Instr.Helpers.RSplit (Michelson.Typed.Haskell.Instr.Product.GFieldTypes x) (Michelson.Typed.Haskell.Instr.Product.GFieldTypes y)) => Michelson.Typed.Haskell.Instr.Product.GInstrConstruct (x GHC.Generics.:*: y)
instance Michelson.Typed.Haskell.Instr.Product.GInstrConstruct GHC.Generics.U1
instance ((TypeError ...), Michelson.Typed.Haskell.Value.GIsoValue x, Michelson.Typed.Haskell.Value.GIsoValue y) => Michelson.Typed.Haskell.Instr.Product.GInstrConstruct (x GHC.Generics.:+: y)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Instr.Product.GInstrConstruct (GHC.Generics.Rec0 a)
instance Michelson.Typed.Haskell.Instr.Product.GInstrSetField name x path f => Michelson.Typed.Haskell.Instr.Product.GInstrSetField name (GHC.Generics.M1 t i x) path f
instance (Michelson.Typed.Haskell.Value.IsoValue f, Michelson.Typed.Haskell.Value.ToT f Data.Type.Equality.~ Michelson.Typed.Haskell.Value.ToT f') => Michelson.Typed.Haskell.Instr.Product.GInstrSetField name (GHC.Generics.Rec0 f) '[] f'
instance (Michelson.Typed.Haskell.Instr.Product.GInstrSetField name x path f, Michelson.Typed.Haskell.Value.GIsoValue y) => Michelson.Typed.Haskell.Instr.Product.GInstrSetField name (x GHC.Generics.:*: y) ('Michelson.Typed.Haskell.Instr.Helpers.L : path) f
instance (Michelson.Typed.Haskell.Instr.Product.GInstrSetField name y path f, Michelson.Typed.Haskell.Value.GIsoValue x) => Michelson.Typed.Haskell.Instr.Product.GInstrSetField name (x GHC.Generics.:*: y) ('Michelson.Typed.Haskell.Instr.Helpers.R : path) f
instance Michelson.Typed.Haskell.Instr.Product.GInstrGet name x path f => Michelson.Typed.Haskell.Instr.Product.GInstrGet name (GHC.Generics.M1 t i x) path f
instance (Michelson.Typed.Haskell.Value.IsoValue f, Michelson.Typed.Haskell.Value.ToT f Data.Type.Equality.~ Michelson.Typed.Haskell.Value.ToT f') => Michelson.Typed.Haskell.Instr.Product.GInstrGet name (GHC.Generics.Rec0 f) '[] f'
instance (Michelson.Typed.Haskell.Instr.Product.GInstrGet name x path f, Michelson.Typed.Haskell.Value.GIsoValue y) => Michelson.Typed.Haskell.Instr.Product.GInstrGet name (x GHC.Generics.:*: y) ('Michelson.Typed.Haskell.Instr.Helpers.L : path) f
instance (Michelson.Typed.Haskell.Instr.Product.GInstrGet name y path f, Michelson.Typed.Haskell.Value.GIsoValue x) => Michelson.Typed.Haskell.Instr.Product.GInstrGet name (x GHC.Generics.:*: y) ('Michelson.Typed.Haskell.Instr.Helpers.R : path) f


-- | Representation of Haskell sum types via loosy typed Michelson values,
--   useful for e.g. errors and enums.
--   
--   In particular, ADT sum can be represented as constructor name + data
--   it carries. Such expression does not have particular type because
--   different constructors may carry different data, and we avoid lifting
--   this data to a union in order to keep only the significant parts (and
--   thus not to confuse the client).
module Michelson.Typed.Haskell.LooseSum

-- | Possible outcomes of an attempt to construct a Haskell ADT value from
--   constructor name and relevant data.
data ComposeResult a

-- | Composed fine.
ComposeOk :: a -> ComposeResult a

-- | No constructor with such name.
ComposeCtorNotFound :: ComposeResult a

-- | Found required constructor, but type of data does not correspond to
--   provided one.
ComposeFieldTypeMismatch :: TypeRep -> TypeRep -> ComposeResult a

-- | Inverse to <a>toTaggedVal</a>.
fromTaggedVal :: LooseSumC dt => (Text, SomeValue) -> ComposeResult dt

-- | Decompose Haskell type into constructor name and data it carries,
--   converting the latter into Michelson <a>Value</a>.
toTaggedVal :: LooseSumC dt => dt -> (Text, SomeValue)

-- | Constraint for <tt>hsDecompose</tt> and <tt>hsCompose</tt>.
type LooseSumC dt = (Generic dt, GLooseSum (Rep dt))
instance GHC.Base.Functor Michelson.Typed.Haskell.LooseSum.ComposeResult
instance (Michelson.Typed.Haskell.LooseSum.GAccessField x, GHC.TypeLits.KnownSymbol ctor) => Michelson.Typed.Haskell.LooseSum.GLooseSum (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor f o) x)
instance Michelson.Typed.Haskell.LooseSum.GAccessField x => Michelson.Typed.Haskell.LooseSum.GAccessField (GHC.Generics.S1 i x)
instance (Data.Typeable.Internal.Typeable a, Michelson.Typed.Haskell.Value.IsoValue a, Data.Typeable.Internal.Typeable (Michelson.Typed.Haskell.Value.ToT a), Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToT a)) => Michelson.Typed.Haskell.LooseSum.GAccessField (GHC.Generics.Rec0 a)
instance Michelson.Typed.Haskell.LooseSum.GAccessField GHC.Generics.U1
instance (TypeError ...) => Michelson.Typed.Haskell.LooseSum.GAccessField (x GHC.Generics.:*: y)
instance Michelson.Typed.Haskell.LooseSum.GLooseSum x => Michelson.Typed.Haskell.LooseSum.GLooseSum (GHC.Generics.D1 i x)
instance (Michelson.Typed.Haskell.LooseSum.GLooseSum x, Michelson.Typed.Haskell.LooseSum.GLooseSum y) => Michelson.Typed.Haskell.LooseSum.GLooseSum (x GHC.Generics.:+: y)
instance Michelson.Typed.Haskell.LooseSum.GLooseSum GHC.Generics.V1
instance GHC.Base.Semigroup (Michelson.Typed.Haskell.LooseSum.ComposeResult a)
instance GHC.Base.Monoid (Michelson.Typed.Haskell.LooseSum.ComposeResult a)


-- | Documentation of types appearing in contracts.
module Michelson.Typed.Haskell.Doc

-- | Stands for representation of some Haskell ADT corresponding to
--   Michelson value. Type parameter <tt>a</tt> is what you put in place of
--   each field of the datatype, e.g. information about field type.
--   
--   Outer list layer corresponds to union, and the inner one corresponds
--   to products within constructors. Constructors and fields names are
--   present.
type ADTRep a = NonEmpty (Text, [(Maybe Text, a)])

-- | Whether given text should be rendered grouped in parentheses (if they
--   make sense).
newtype WithinParens
WithinParens :: Bool -> WithinParens

-- | Description for a Haskell type appearing in documentation.
class TypeHasDoc a

-- | Name of type as it appears in definitions section.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: TypeHasDoc a => Proxy a -> Text

-- | Name of type as it appears in definitions section.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: (TypeHasDoc a, Generic a, KnownSymbol (GenericTypeName a)) => Proxy a -> Text

-- | Explanation of a type. Markdown formatting is allowed.
typeDocMdDescription :: TypeHasDoc a => Builder

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: TypeHasDoc a => Proxy a -> WithinParens -> Builder

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: (TypeHasDoc a, Typeable a, IsHomomorphic a) => Proxy a -> WithinParens -> Builder

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: TypeHasDoc a => Proxy a -> [SomeTypeWithDoc]

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: (TypeHasDoc a, Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: TypeHasDoc a => TypeDocHaskellRep a

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: (TypeHasDoc a, Generic a, GTypeHasDoc (Rep a), IsHomomorphic a) => TypeDocHaskellRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: TypeHasDoc a => TypeDocMichelsonRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: (TypeHasDoc a, SingI (ToT a), IsHomomorphic a) => TypeDocMichelsonRep a

-- | Signature of <a>typeDocHaskellRep</a> function.
--   
--   When value is <a>Just</a>, it contains types which this type is built
--   from.
--   
--   First element of provided pair may contain name a concrete type which
--   has the same type constructor as <tt>a</tt> (or just <tt>a</tt> for
--   homomorphic types), and the second element of the pair - its unfolding
--   in Haskell.
--   
--   For example, for some <tt>newtype MyNewtype = MyNewtype (Integer,
--   Natural)</tt> we would not specify the first element in the pair
--   because <tt>MyNewtype</tt> is already a concrete type, and second
--   element would contain <tt>(Integer, Natural)</tt>. For polymorhpic
--   types like <tt>newtype MyPolyNewtype a = MyPolyNewtype (Text, a)</tt>,
--   we want to describe its representation on some example of <tt>a</tt>,
--   because working with type variables is too non-trivial; so the first
--   element of the pair may be e.g. <tt>"MyPolyNewType Integer"</tt>, and
--   the second one shows that it unfolds to <tt>(Text, Integer)</tt>.
--   
--   When rendered, values of this type look like: * <tt>(Integer,
--   Natural)</tt> - for homomorphic type. * <tt>MyError Integer = (Text,
--   Integer)</tt> - concrete sample for polymorhpic type.
type TypeDocHaskellRep a = Proxy a -> Maybe (Maybe DocTypeRepLHS, ADTRep SomeTypeWithDoc)

-- | Signature of <a>typeDocMichelsonRep</a> function.
--   
--   As in <a>TypeDocHaskellRep</a>, set the first element of the pair to
--   <a>Nothing</a> for primitive types, otherwise it stands as some
--   instantiation of a type, and its Michelson representation is given in
--   the second element of the pair.
--   
--   Examples of rendered representation: * <tt>pair int nat</tt> - for
--   homomorphic type. * <tt>MyError Integer = pair string int</tt> -
--   concrete sample for polymorhpic type.
type TypeDocMichelsonRep a = Proxy a -> (Maybe DocTypeRepLHS, T)

-- | Constraint, required when deriving <a>TypeHasDoc</a> for polymorphic
--   type with the least possible number of methods defined manually.
type PolyTypeHasDocC ts = Each '[TypeHasDoc] ts

-- | Data hides some type implementing <a>TypeHasDoc</a>.
data SomeTypeWithDoc
[SomeTypeWithDoc] :: TypeHasDoc td => Proxy td -> SomeTypeWithDoc

-- | Require two types to be built from the same type constructor.
--   
--   E.g. <tt>HaveCommonTypeCtor (Maybe Integer) (Maybe Natural)</tt> is
--   defined, while <tt>HaveCmmonTypeCtor (Maybe Integer) [Integer]</tt> is
--   not.
class HaveCommonTypeCtor a b

-- | Require this type to be homomorphic.
class IsHomomorphic a

-- | Implement <a>typeDocDependencies</a> via getting all immediate fields
--   of a datatype.
--   
--   Note: this will not include phantom types, I'm not sure yet how this
--   scenario should be handled (@martoon).
genericTypeDocDependencies :: forall a. (Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | Render a reference to a type which consists of type constructor (you
--   have to provide name of this type constructor and documentation for
--   the whole type) and zero or more type arguments.
customTypeDocMdReference :: (Text, DType) -> [DType] -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for homomorphic types only.
homomorphicTypeDocMdReference :: forall (t :: Type). (Typeable t, TypeHasDoc t, IsHomomorphic t) => Proxy t -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with one type
--   argument, like <tt>Maybe Integer</tt>.
poly1TypeDocMdReference :: forall t (r :: Type) (a :: Type). (r ~ t a, Typeable t, Each '[TypeHasDoc] [r, a], IsHomomorphic t) => Proxy r -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with two type
--   arguments, like <tt>Lambda Integer Natural</tt>.
poly2TypeDocMdReference :: forall t (r :: Type) (a :: Type) (b :: Type). (r ~ t a b, Typeable t, Each '[TypeHasDoc] [r, a, b], IsHomomorphic t) => Proxy r -> WithinParens -> Builder

-- | Implement <a>typeDocHaskellRep</a> for a homomorphic type.
--   
--   Note that it does not require your type to be of <a>IsHomomorphic</a>
--   instance, which can be useful for some polymorhpic types which, for
--   documentation purposes, we want to consider homomorphic. Example:
--   <a>Operation</a> is in fact polymorhpic, but we don't want this fact
--   to be reflected in the documentation.
homomorphicTypeDocHaskellRep :: forall a. (Generic a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep a

-- | Implement <a>typeDocHaskellRep</a> on example of given concrete type.
--   
--   This is a best effort attempt to implement <a>typeDocHaskellRep</a>
--   for polymorhpic types, as soon as there is no simple way to preserve
--   type variables when automatically deriving Haskell representation of a
--   type.
concreteTypeDocHaskellRep :: forall a b. (Typeable a, IsoValue a, Generic a, GTypeHasDoc (Rep a), HaveCommonTypeCtor b a) => TypeDocHaskellRep b

-- | Erase fields from Haskell datatype representation.
--   
--   Use this when rendering fields names is undesired.
haskellRepNoFields :: TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Cut fields prefixes which we use according to the style guide.
--   
--   E.g. <tt>cmMyField</tt> field will be transformed to <tt>myField</tt>.
haskellRepStripFieldPrefix :: HasCallStack => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Implement <a>typeDocMichelsonRep</a> for homomorphic type.
homomorphicTypeDocMichelsonRep :: forall a. SingI (ToT a) => TypeDocMichelsonRep a

-- | Implement <a>typeDocMichelsonRep</a> on example of given concrete
--   type.
--   
--   This function exists for the same reason as
--   <a>concreteTypeDocHaskellRep</a>.
concreteTypeDocMichelsonRep :: forall a b. (Typeable a, SingI (ToT a), HaveCommonTypeCtor b a) => TypeDocMichelsonRep b

-- | Doc element with description of a type.
data DType
[DType] :: TypeHasDoc a => Proxy a -> DType

-- | Generic traversal for automatic deriving of some methods in
--   <a>TypeHasDoc</a>.
class GTypeHasDoc (x :: Type -> Type)

-- | Show given <a>ADTRep</a> in a neat way.
buildADTRep :: forall a. (WithinParens -> a -> Builder) -> ADTRep a -> Builder
applyWithinParens :: WithinParens -> Builder -> Builder
instance Formatting.Buildable.Buildable Michelson.Typed.Haskell.Doc.DocTypeRepLHS
instance Data.String.IsString Michelson.Typed.Haskell.Doc.DocTypeRepLHS
instance Michelson.Typed.Haskell.Doc.PolyCTypeHasDocC '[a] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Data.Set.Internal.Set a)
instance (Michelson.Typed.Haskell.Doc.PolyCTypeHasDocC '[k], Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[v], GHC.Classes.Ord k) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Data.Map.Internal.Map k v)
instance (Michelson.Typed.Haskell.Doc.PolyCTypeHasDocC '[k], Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[v], GHC.Classes.Ord k) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Michelson.Typed.Haskell.Value.BigMap k v)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a] => Michelson.Typed.Haskell.Doc.TypeHasDoc [a]
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a] => Michelson.Typed.Haskell.Doc.TypeHasDoc (GHC.Maybe.Maybe a)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[l, r] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Data.Either.Either l r)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a, b] => Michelson.Typed.Haskell.Doc.TypeHasDoc (a, b)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[cp] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Michelson.Typed.Haskell.Value.ContractAddr cp)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a, b, c] => Michelson.Typed.Haskell.Doc.TypeHasDoc (a, b, c)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a, b, c, d] => Michelson.Typed.Haskell.Doc.TypeHasDoc (a, b, c, d)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a, b, c, d, e] => Michelson.Typed.Haskell.Doc.TypeHasDoc (a, b, c, d, e)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a, b, c, d, e, f] => Michelson.Typed.Haskell.Doc.TypeHasDoc (a, b, c, d, e, f)
instance Michelson.Typed.Haskell.Doc.PolyTypeHasDocC '[a, b, c, d, e, f, g] => Michelson.Typed.Haskell.Doc.TypeHasDoc (a, b, c, d, e, f, g)
instance (Michelson.Typed.Haskell.Doc.GProductHasDoc x, GHC.TypeLits.KnownSymbol ctor) => Michelson.Typed.Haskell.Doc.GTypeHasDoc (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance (Michelson.Typed.Haskell.Doc.GProductHasDoc x, Michelson.Typed.Haskell.Doc.GProductHasDoc y) => Michelson.Typed.Haskell.Doc.GProductHasDoc (x GHC.Generics.:*: y)
instance Michelson.Typed.Haskell.Doc.TypeHasDoc a => Michelson.Typed.Haskell.Doc.GProductHasDoc (GHC.Generics.S1 ('GHC.Generics.MetaSel 'GHC.Maybe.Nothing _1 _2 _3) (GHC.Generics.Rec0 a))
instance (Michelson.Typed.Haskell.Doc.TypeHasDoc a, GHC.TypeLits.KnownSymbol field) => Michelson.Typed.Haskell.Doc.GProductHasDoc (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) _1 _2 _3) (GHC.Generics.Rec0 a))
instance Michelson.Typed.Haskell.Doc.GProductHasDoc GHC.Generics.U1
instance Michelson.Typed.Doc.DocItem Michelson.Typed.Haskell.Doc.DType
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Michelson.Text.MText
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Michelson.Typed.Aliases.Operation
instance GHC.Show.Show Michelson.Typed.Haskell.Doc.SomeTypeWithDoc
instance Michelson.Typed.Haskell.Doc.GTypeHasDoc x => Michelson.Typed.Haskell.Doc.GTypeHasDoc (GHC.Generics.D1 i x)
instance (Michelson.Typed.Haskell.Doc.GTypeHasDoc x, Michelson.Typed.Haskell.Doc.GTypeHasDoc y) => Michelson.Typed.Haskell.Doc.GTypeHasDoc (x GHC.Generics.:+: y)
instance (TypeError ...) => Michelson.Typed.Haskell.Doc.GTypeHasDoc GHC.Generics.V1
instance Michelson.Typed.Haskell.Doc.TypeHasDoc GHC.Integer.Type.Integer
instance Michelson.Typed.Haskell.Doc.TypeHasDoc GHC.Natural.Natural
instance Michelson.Typed.Haskell.Doc.TypeHasDoc GHC.Types.Bool
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Data.ByteString.Internal.ByteString
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Tezos.Core.Mutez
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Tezos.Crypto.KeyHash
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Tezos.Core.Timestamp
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Tezos.Address.Address
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Tezos.Crypto.PublicKey
instance Michelson.Typed.Haskell.Doc.TypeHasDoc Tezos.Crypto.Signature
instance Michelson.Typed.Haskell.Doc.TypeHasDoc ()
instance (Michelson.Typed.Haskell.Doc.TypeHasDoc a, GHC.TypeLits.KnownSymbol n) => Michelson.Typed.Haskell.Doc.TypeHasDoc (n Named.Internal.:! a)
instance (Data.Typeable.Internal.Typeable a, Michelson.Typed.Haskell.Doc.TypeHasDoc (GHC.Maybe.Maybe a), GHC.TypeLits.KnownSymbol n) => Michelson.Typed.Haskell.Doc.TypeHasDoc (n Named.Internal.:? a)
instance forall k1 k2 (a :: k1 -> k2) (b :: k1). (TypeError ...) => Michelson.Typed.Haskell.Doc.IsHomomorphic (a b)
instance forall k (a :: k). Michelson.Typed.Haskell.Doc.IsHomomorphic a
instance forall k1 k2 k3 k4 (ac :: k3 -> k4) (bc :: k1 -> k2) (a :: k3) (b :: k1). Michelson.Typed.Haskell.Doc.HaveCommonTypeCtor ac bc => Michelson.Typed.Haskell.Doc.HaveCommonTypeCtor (ac a) (bc b)
instance forall k (a :: k). Michelson.Typed.Haskell.Doc.HaveCommonTypeCtor a a


-- | Optimizer for typed instructions.
--   
--   It's quite experimental and incomplete. List of possible improvements:
--   1. See comment to <a>optimizeWithRule</a>, it is not quite correct. 2.
--   <a>pushDrop</a>, <a>dupDrop</a>, <a>unitDrop</a> rules are essentially
--   the same. It would be good to generalize them into one rule. The same
--   applies to <a>pushDip</a>. 3. Also we completely ignore <a>Nested</a>.
--   4. Some rules make break right-linear structure (e. g. pushDip) and
--   currently we use <a>linearizeRight</a> to account for that. It
--   probably can be done more efficiently.
module Michelson.Optimizer

-- | Optimize a typed instruction by replacing some sequences of
--   instructions with smaller equivalent sequences. Applies default set of
--   rewrite rules.
optimize :: Instr inp out -> Instr inp out

-- | Optimize a typed instruction using a custom set of rules.
optimizeWithRules :: (forall inp1 out1. Rules inp1 out1) -> Instr inp out -> Instr inp out

-- | Optimize a typed instruction using a specific rule.
--   
--   It applies all rules to head (first few instructions) while they
--   successfully apply. Then it applies them to instructions after the
--   first one and so on.
--   
--   It's probably not the most efficient solution and it's not quite
--   correct, because if we have instructions `a; b; c` and optimize `b; c`
--   then we should return to optimizing sequence which starts with
--   <tt>a</tt>.
optimizeWithRule :: Rule -> Instr a b -> Instr a b

-- | There are many ways to represent a sequence of more than 2
--   instructions. E. g. for `i1; i2; i3` it can be <tt>Seq i1 $ Seq i2
--   i3</tt> or <tt>Seq i1 i2 $ i3</tt>. This function enforces a
--   particular structure. Specifically, it makes each <a>Instr</a> have a
--   single instruction (i. e. not <a>Instr</a>) in its first argument. It
--   makes it easier to implement optimizer. This function also erases
--   redundant <a>Nop</a>.
--   
--   TODO: currently it doesn't go deeper into instructions like <a>IF</a>.
--   We should try reusing <a>deepRule</a> for this purpose.
--   
--   TODO: it also has bad worst-case performance, it should be carefully
--   rewritten.
linearizeRight :: Instr a b -> Instr a b
defaultRules :: Rules inp out

module Lorentz.UStore.Common
fieldNameToMText :: forall field. KnownSymbol field => MText

module Util.TypeTuple.Class

-- | Building a record from tuple.
--   
--   It differs from similar typeclass in <a>FromTuple</a> module in that
--   it allows type inference outside-in - knowing desired <tt>Rec</tt> you
--   know which tuple should be provided - this improves error messages
--   when constructing concrete <tt>Rec</tt> objects.
class RecFromTuple r where {
    type family IsoRecTuple r :: Type;
}
recFromTuple :: RecFromTuple r => IsoRecTuple r -> r


-- | Template haskell generator for <a>RecFromTuple</a>, in a separate
--   module because of staging restrictions.
module Util.TypeTuple.TH

-- | Produce <a>RecFromTuple</a> instance for tuple of the given length.
deriveRecFromTuple :: Word -> Q [Dec]

module Util.TypeTuple.Instances
instance forall u (f :: u -> *). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[])
instance forall u (f :: u -> *) (x :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u) (x15 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u) (x15 :: u) (x16 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u) (x15 :: u) (x16 :: u) (x17 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u) (x15 :: u) (x16 :: u) (x17 :: u) (x18 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u) (x15 :: u) (x16 :: u) (x17 :: u) (x18 :: u) (x19 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19])
instance forall u (f :: u -> *) (x1 :: u) (x2 :: u) (x3 :: u) (x4 :: u) (x5 :: u) (x6 :: u) (x7 :: u) (x8 :: u) (x9 :: u) (x10 :: u) (x11 :: u) (x12 :: u) (x13 :: u) (x14 :: u) (x15 :: u) (x16 :: u) (x17 :: u) (x18 :: u) (x19 :: u) (x20 :: u). Util.TypeTuple.Class.RecFromTuple (Data.Vinyl.Core.Rec f '[x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20])


-- | Conversions between tuples and list-like types.
module Util.TypeTuple

-- | Building a record from tuple.
--   
--   It differs from similar typeclass in <a>FromTuple</a> module in that
--   it allows type inference outside-in - knowing desired <tt>Rec</tt> you
--   know which tuple should be provided - this improves error messages
--   when constructing concrete <tt>Rec</tt> objects.
class RecFromTuple r where {
    type family IsoRecTuple r :: Type;
}
recFromTuple :: RecFromTuple r => IsoRecTuple r -> r


-- | Instructions working on sum types derived from Haskell ones.
module Michelson.Typed.Haskell.Instr.Sum
type InstrWrapC dt name = (IsoValue dt, Generic dt, GInstrWrap (Rep dt) (LnrBranch (GetNamed name dt)) (LnrFieldType (GetNamed name dt)), GValueType (Rep dt) ~ ToT dt)
type InstrCaseC dt inp out = (IsoValue dt, GInstrCase (Rep dt), GValueType (Rep dt) ~ ToT dt)
type InstrUnwrapC dt name = (IsoValue dt, Generic dt, GInstrUnwrap (Rep dt) (LnrBranch (GetNamed name dt)) (CtorOnlyField name dt), GValueType (Rep dt) ~ ToT dt)

-- | Wrap given element into a constructor with the given name.
--   
--   Mentioned constructor must have only one field.
--   
--   Since labels interpretable by <a>OverloadedLabels</a> extension cannot
--   start with capital latter, prepend constructor name with letter "c"
--   (see examples below).
instrWrap :: forall dt name st. InstrWrapC dt name => Label name -> Instr (AppendCtorField (GetCtorField dt name) st) (ToT dt : st)

-- | Wrap a haskell value into a constructor with the given name.
--   
--   This is symmetric to <a>instrWrap</a>.
hsWrap :: forall dt name. InstrWrapC dt name => Label name -> ExtractCtorField (GetCtorField dt name) -> dt

-- | Pattern-match on the given datatype.
instrCase :: forall dt out inp. InstrCaseC dt inp out => Rec (CaseClause inp out) (CaseClauses dt) -> Instr (ToT dt : inp) out

-- | Lift an instruction to case clause.
--   
--   You should write out constructor name corresponding to the clause
--   explicitly. Prefix constructor name with "c" letter, otherwise your
--   label will not be recognized by Haskell parser. Passing constructor
--   name can be circumvented but doing so is not recomended as mentioning
--   contructor name improves readability and allows avoiding some
--   mistakes.
(//->) :: Label ("c" `AppendSymbol` ctor) -> Instr (AppendCtorField x inp) out -> CaseClause inp out ( 'CaseClauseParam ctor x)
infixr 8 //->

-- | Unwrap a constructor with the given name.
--   
--   Rules which apply to <a>instrWrap</a> function work here as well.
--   Although, unlike <tt>instrWrap</tt>, this function does not work for
--   nullary constructors.
instrUnwrapUnsafe :: forall dt name st. InstrUnwrapC dt name => Label name -> Instr (ToT dt : st) (ToT (CtorOnlyField name dt) : st)

-- | Try to unwrap a constructor with the given name.
hsUnwrap :: forall dt name. InstrUnwrapC dt name => Label name -> dt -> Maybe (CtorOnlyField name dt)

-- | In what different case branches differ - related constructor name and
--   input stack type which the branch starts with.
data CaseClauseParam
CaseClauseParam :: Symbol -> CtorField -> CaseClauseParam

-- | Type information about single case clause.
data CaseClause (inp :: [T]) (out :: [T]) (param :: CaseClauseParam)
[CaseClause] :: Instr (AppendCtorField x inp) out -> CaseClause inp out ( 'CaseClauseParam ctor x)

-- | List of <a>CaseClauseParam</a>s required to pattern match on the given
--   type.
type CaseClauses a = GCaseClauses (Rep a)
type family GCaseClauses x :: [CaseClauseParam]
type family GCaseBranchInput ctor x :: CaseClauseParam

-- | Which branch to choose in generic tree representation: left, straight
--   or right. <a>S</a> is used when there is one constructor with one
--   field (something newtype-like).
--   
--   The reason why we need <a>S</a> can be explained by this example: data
--   A = A1 B | A2 Integer data B = B Bool Now we may search for A1
--   constructor or B constructor. Without <a>S</a> in both cases path will
--   be the same ([L]).
data Branch
L :: Branch
S :: Branch
R :: Branch

-- | Path to a leaf (some field or constructor) in generic tree
--   representation.
type Path = [Branch]

-- | We support only two scenarious - constructor with one field and
--   without fields. Nonetheless, it's not that sad since for sum types we
--   can't even assign names to fields if there are many (the style guide
--   prohibits partial records).
data CtorField
OneField :: Type -> CtorField
NoFields :: CtorField

-- | Get <i>something</i> as field of the given constructor.
type family ExtractCtorField (cf :: CtorField)

-- | Push field to stack, if any.
type family AppendCtorField (cf :: CtorField) (l :: [k]) :: [k]

-- | To use <a>AppendCtorField</a> not only here for <a>T</a>-based stacks,
--   but also later in Lorentz with <a>Type</a>-based stacks we need the
--   following property.
type AppendCtorFieldAxiom (cf :: CtorField) (st :: [Type]) = ToTs (AppendCtorField cf st) ~ AppendCtorField cf (ToTs st)

-- | Proof of <a>AppendCtorFieldAxiom</a>.
appendCtorFieldAxiom :: (AppendCtorFieldAxiom ( 'OneField Word) '[Int], AppendCtorFieldAxiom  'NoFields '[Int]) => Dict (AppendCtorFieldAxiom cf st)

-- | Get type of constructor fields (one or zero) referred by given
--   datatype and name.
type GetCtorField dt ctor = LnrFieldType (GetNamed ctor dt)

-- | Expect referred constructor to have only one field (in form of
--   constraint) and extract its type.
type CtorHasOnlyField ctor dt f = GetCtorField dt ctor ~  'OneField f

-- | Expect referred constructor to have only one field (otherwise compile
--   error is raised) and extract its type.
type CtorOnlyField name dt = RequireOneField name (GetCtorField dt name)
data MyCompoundType

-- | Whether given type represents an atomic Michelson value.
type family IsPrimitiveValue (x :: Type) :: Bool
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Typed.Haskell.Instr.Sum.MyEnum
instance GHC.Generics.Generic Michelson.Typed.Haskell.Instr.Sum.MyEnum
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Typed.Haskell.Instr.Sum.MyCompoundType
instance GHC.Generics.Generic Michelson.Typed.Haskell.Instr.Sum.MyCompoundType
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Typed.Haskell.Instr.Sum.MyType'
instance GHC.Generics.Generic Michelson.Typed.Haskell.Instr.Sum.MyType'
instance Michelson.Typed.Haskell.Value.IsoValue Michelson.Typed.Haskell.Instr.Sum.MyType
instance GHC.Generics.Generic Michelson.Typed.Haskell.Instr.Sum.MyType
instance Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap x path e => Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap (GHC.Generics.D1 i x) path e
instance (Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap x path e, Michelson.Typed.Haskell.Value.GIsoValue y, Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.GValueType y)) => Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap (x GHC.Generics.:+: y) ('Michelson.Typed.Haskell.Instr.Helpers.L : path) e
instance (Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap y path e, Michelson.Typed.Haskell.Value.GIsoValue x, Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.GValueType x)) => Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap (x GHC.Generics.:+: y) ('Michelson.Typed.Haskell.Instr.Helpers.R : path) e
instance Michelson.Typed.Haskell.Value.IsoValue e => Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap (GHC.Generics.C1 c (GHC.Generics.S1 i (GHC.Generics.Rec0 e))) '[ 'Michelson.Typed.Haskell.Instr.Helpers.S] e
instance (path Data.Type.Equality.~ (x : xs), Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap (GHC.Generics.Rep sub) path e, GHC.Generics.Generic sub, Michelson.Typed.Haskell.Value.GIsoValue (GHC.Generics.Rep sub), Michelson.Typed.Haskell.Value.IsoValue sub, Michelson.Typed.Haskell.Value.GValueType (GHC.Generics.Rep sub) Data.Type.Equality.~ Michelson.Typed.Haskell.Value.ToT sub) => Michelson.Typed.Haskell.Instr.Sum.GInstrUnwrap (GHC.Generics.C1 c (GHC.Generics.S1 i (GHC.Generics.Rec0 sub))) ('Michelson.Typed.Haskell.Instr.Helpers.S : x : xs) e
instance Michelson.Typed.Haskell.Instr.Sum.GInstrCaseBranch ctor x => Michelson.Typed.Haskell.Instr.Sum.GInstrCase (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance (Michelson.Typed.Haskell.Value.GIsoValue x, Michelson.Typed.Haskell.Value.GIsoValue y, (TypeError ...)) => Michelson.Typed.Haskell.Instr.Sum.GInstrCaseBranch ctor (x GHC.Generics.:*: y)
instance Michelson.Typed.Haskell.Instr.Sum.GInstrCaseBranch ctor x => Michelson.Typed.Haskell.Instr.Sum.GInstrCaseBranch ctor (GHC.Generics.S1 i x)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Instr.Sum.GInstrCaseBranch ctor (GHC.Generics.Rec0 a)
instance Michelson.Typed.Haskell.Instr.Sum.GInstrCaseBranch ctor GHC.Generics.U1
instance Michelson.Typed.Haskell.Instr.Sum.GInstrCase x => Michelson.Typed.Haskell.Instr.Sum.GInstrCase (GHC.Generics.D1 i x)
instance (Michelson.Typed.Haskell.Instr.Sum.GInstrCase x, Michelson.Typed.Haskell.Instr.Sum.GInstrCase y, Michelson.Typed.Haskell.Instr.Helpers.RSplit (Michelson.Typed.Haskell.Instr.Sum.GCaseClauses x) (Michelson.Typed.Haskell.Instr.Sum.GCaseClauses y)) => Michelson.Typed.Haskell.Instr.Sum.GInstrCase (x GHC.Generics.:+: y)
instance Michelson.Typed.Haskell.Instr.Sum.GInstrWrap x path e => Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (GHC.Generics.D1 i x) path e
instance (Michelson.Typed.Haskell.Instr.Sum.GInstrWrap x path e, Michelson.Typed.Haskell.Value.GIsoValue y, Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.GValueType y)) => Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (x GHC.Generics.:+: y) ('Michelson.Typed.Haskell.Instr.Helpers.L : path) e
instance (Michelson.Typed.Haskell.Instr.Sum.GInstrWrap y path e, Michelson.Typed.Haskell.Value.GIsoValue x, Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.GValueType x)) => Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (x GHC.Generics.:+: y) ('Michelson.Typed.Haskell.Instr.Helpers.R : path) e
instance Michelson.Typed.Haskell.Value.IsoValue e => Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (GHC.Generics.C1 c (GHC.Generics.S1 i (GHC.Generics.Rec0 e))) '[ 'Michelson.Typed.Haskell.Instr.Helpers.S] ('Michelson.Typed.Haskell.Instr.Sum.OneField e)
instance (path Data.Type.Equality.~ (x : xs), Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (GHC.Generics.Rep sub) path e, GHC.Generics.Generic sub, Michelson.Typed.Haskell.Value.GIsoValue (GHC.Generics.Rep sub), Michelson.Typed.Haskell.Value.IsoValue sub, Michelson.Typed.Haskell.Value.GValueType (GHC.Generics.Rep sub) Data.Type.Equality.~ Michelson.Typed.Haskell.Value.ToT sub) => Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (GHC.Generics.C1 c (GHC.Generics.S1 i (GHC.Generics.Rec0 sub))) ('Michelson.Typed.Haskell.Instr.Helpers.S : x : xs) e
instance Michelson.Typed.Haskell.Instr.Sum.GInstrWrap (GHC.Generics.C1 c GHC.Generics.U1) '[ 'Michelson.Typed.Haskell.Instr.Helpers.S] 'Michelson.Typed.Haskell.Instr.Sum.NoFields

module Michelson.Typed.Haskell.Instr


-- | Haskell-Michelson conversions.
module Michelson.Typed.Haskell

-- | Path to a leaf (some field or constructor) in generic tree
--   representation.
type Path = [Branch]

-- | Which branch to choose in generic tree representation: left, straight
--   or right. <a>S</a> is used when there is one constructor with one
--   field (something newtype-like).
--   
--   The reason why we need <a>S</a> can be explained by this example: data
--   A = A1 B | A2 Integer data B = B Bool Now we may search for A1
--   constructor or B constructor. Without <a>S</a> in both cases path will
--   be the same ([L]).
data Branch
L :: Branch
S :: Branch
R :: Branch

-- | Isomorphism between Michelson stack and its Haskell reflection.
class IsoValuesStack (ts :: [Type])
toValStack :: IsoValuesStack ts => Rec Identity ts -> Rec Value (ToTs ts)
fromValStack :: IsoValuesStack ts => Rec Value (ToTs ts) -> Rec Identity ts

-- | Overloaded version of <a>ToTs</a> to work on Haskell and <tt>T</tt>
--   stacks.
type family ToTs' (t :: [k]) :: [T]

-- | Type function to convert a Haskell stack type to <tt>T</tt>-based one.
type family ToTs (ts :: [Type]) :: [T]

-- | Whether Michelson representation of the type is derived via Generics.
type IsGenericIsoValue t = (IsoValue t, Generic t, ToT t ~ GValueType (Rep t))
newtype BigMap k v
BigMap :: Map k v -> BigMap k v
[unBigMap] :: BigMap k v -> Map k v

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
newtype ContractAddr (cp :: Type)
ContractAddr :: Address -> ContractAddr
[unContractAddress] :: ContractAddr -> Address

-- | A useful property which holds for all <a>CT</a> types.
type IsComparable c = ToT c ~  'Tc (ToCT c)

-- | Any Haskell value which can be converted to Michelson <a>Value</a>.
newtype AnyIsoValue
AnyIsoValue :: (forall a. IsoValue a => a) -> AnyIsoValue

-- | Hides some Haskell value put in line with Michelson <a>Value</a>.
data SomeIsoValue
[SomeIsoValue] :: (Typeable a, IsoValue a) => a -> SomeIsoValue

-- | Overloaded version of <a>ToT</a> to work on Haskell and <tt>T</tt>
--   types.
type family ToT' (t :: k) :: T

-- | Isomorphism between Michelson values and plain Haskell types.
--   
--   Default implementation of this typeclass converts ADTs to Michelson
--   "pair"s and "or"s.
class IsoValue a where {
    
    -- | Type function that converts a regular Haskell type into a <tt>T</tt>
    --   type.
    type family ToT a :: T;
    type ToT a = GValueType (Rep a);
}

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: IsoValue a => a -> Value (ToT a)

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: (IsoValue a, Generic a, GIsoValue (Rep a), ToT a ~ GValueType (Rep a)) => a -> Value (ToT a)

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: IsoValue a => Value (ToT a) -> a

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: (IsoValue a, Generic a, GIsoValue (Rep a), ToT a ~ GValueType (Rep a)) => Value (ToT a) -> a

-- | Isomorphism between Michelson primitive values and plain Haskell
--   types.
class IsoCValue a where {
    
    -- | Type function that converts a regular Haskell type into a comparable
    --   type (which has kind <tt>CT</tt>).
    type family ToCT a :: CT;
}

-- | Converts a single Haskell value into <tt>CVal</tt> representation.
toCVal :: IsoCValue a => a -> CValue (ToCT a)

-- | Converts a <tt>CVal</tt> value into a single Haskell value.
fromCVal :: IsoCValue a => CValue (ToCT a) -> a

-- | Constraint for <a>instrConstruct</a>.
type InstrConstructC dt = (IsoValue dt, Generic dt, GInstrConstruct (Rep dt), GValueType (Rep dt) ~ ToT dt)

-- | Types of all fields in a datatype.
type ConstructorFieldTypes dt = GFieldTypes (Rep dt)

-- | Way to construct one of the fields in a complex datatype.
newtype FieldConstructor (st :: [k]) (field :: Type)
FieldConstructor :: Instr (ToTs' st) (ToT field : ToTs' st) -> FieldConstructor

-- | Constraint for <a>instrSetField</a>.
type InstrSetFieldC dt name = (IsoValue dt, Generic dt, GInstrSetField name (Rep dt) (LnrBranch (GetNamed name dt)) (LnrFieldType (GetNamed name dt)), GValueType (Rep dt) ~ ToT dt)

-- | Constraint for <a>instrGetField</a>.
type InstrGetFieldC dt name = (IsoValue dt, Generic dt, GInstrGet name (Rep dt) (LnrBranch (GetNamed name dt)) (LnrFieldType (GetNamed name dt)), GValueType (Rep dt) ~ ToT dt)

-- | Get type of field by datatype it is contained in and field name.
type GetFieldType dt name = LnrFieldType (GetNamed name dt)

-- | Make an instruction which accesses given field of the given datatype.
instrGetField :: forall dt name st. InstrGetFieldC dt name => Label name -> Instr (ToT dt : st) (ToT (GetFieldType dt name) : st)

-- | For given complex type <tt>dt</tt> and its field <tt>fieldTy</tt>
--   update the field value.
instrSetField :: forall dt name st. InstrSetFieldC dt name => Label name -> Instr (ToT (GetFieldType dt name) : (ToT dt : st)) (ToT dt : st)

-- | For given complex type <tt>dt</tt> and its field <tt>fieldTy</tt>
--   update the field value.
instrConstruct :: forall dt st. InstrConstructC dt => Rec (FieldConstructor st) (ConstructorFieldTypes dt) -> Instr st (ToT dt : st)

-- | Constraint for <tt>hsDecompose</tt> and <tt>hsCompose</tt>.
type LooseSumC dt = (Generic dt, GLooseSum (Rep dt))

-- | Possible outcomes of an attempt to construct a Haskell ADT value from
--   constructor name and relevant data.
data ComposeResult a

-- | Composed fine.
ComposeOk :: a -> ComposeResult a

-- | No constructor with such name.
ComposeCtorNotFound :: ComposeResult a

-- | Found required constructor, but type of data does not correspond to
--   provided one.
ComposeFieldTypeMismatch :: TypeRep -> TypeRep -> ComposeResult a

-- | Decompose Haskell type into constructor name and data it carries,
--   converting the latter into Michelson <a>Value</a>.
toTaggedVal :: LooseSumC dt => dt -> (Text, SomeValue)

-- | Inverse to <a>toTaggedVal</a>.
fromTaggedVal :: LooseSumC dt => (Text, SomeValue) -> ComposeResult dt

-- | Constraint, required when deriving <a>TypeHasDoc</a> for polymorphic
--   type with the least possible number of methods defined manually.
type PolyTypeHasDocC ts = Each '[TypeHasDoc] ts

-- | Generic traversal for automatic deriving of some methods in
--   <a>TypeHasDoc</a>.
class GTypeHasDoc (x :: Type -> Type)

-- | Require this type to be homomorphic.
class IsHomomorphic a

-- | Require two types to be built from the same type constructor.
--   
--   E.g. <tt>HaveCommonTypeCtor (Maybe Integer) (Maybe Natural)</tt> is
--   defined, while <tt>HaveCmmonTypeCtor (Maybe Integer) [Integer]</tt> is
--   not.
class HaveCommonTypeCtor a b

-- | Doc element with description of a type.
data DType
[DType] :: TypeHasDoc a => Proxy a -> DType

-- | Data hides some type implementing <a>TypeHasDoc</a>.
data SomeTypeWithDoc
[SomeTypeWithDoc] :: TypeHasDoc td => Proxy td -> SomeTypeWithDoc

-- | Signature of <a>typeDocMichelsonRep</a> function.
--   
--   As in <a>TypeDocHaskellRep</a>, set the first element of the pair to
--   <a>Nothing</a> for primitive types, otherwise it stands as some
--   instantiation of a type, and its Michelson representation is given in
--   the second element of the pair.
--   
--   Examples of rendered representation: * <tt>pair int nat</tt> - for
--   homomorphic type. * <tt>MyError Integer = pair string int</tt> -
--   concrete sample for polymorhpic type.
type TypeDocMichelsonRep a = Proxy a -> (Maybe DocTypeRepLHS, T)

-- | Signature of <a>typeDocHaskellRep</a> function.
--   
--   When value is <a>Just</a>, it contains types which this type is built
--   from.
--   
--   First element of provided pair may contain name a concrete type which
--   has the same type constructor as <tt>a</tt> (or just <tt>a</tt> for
--   homomorphic types), and the second element of the pair - its unfolding
--   in Haskell.
--   
--   For example, for some <tt>newtype MyNewtype = MyNewtype (Integer,
--   Natural)</tt> we would not specify the first element in the pair
--   because <tt>MyNewtype</tt> is already a concrete type, and second
--   element would contain <tt>(Integer, Natural)</tt>. For polymorhpic
--   types like <tt>newtype MyPolyNewtype a = MyPolyNewtype (Text, a)</tt>,
--   we want to describe its representation on some example of <tt>a</tt>,
--   because working with type variables is too non-trivial; so the first
--   element of the pair may be e.g. <tt>"MyPolyNewType Integer"</tt>, and
--   the second one shows that it unfolds to <tt>(Text, Integer)</tt>.
--   
--   When rendered, values of this type look like: * <tt>(Integer,
--   Natural)</tt> - for homomorphic type. * <tt>MyError Integer = (Text,
--   Integer)</tt> - concrete sample for polymorhpic type.
type TypeDocHaskellRep a = Proxy a -> Maybe (Maybe DocTypeRepLHS, ADTRep SomeTypeWithDoc)

-- | Description for a Haskell type appearing in documentation.
class TypeHasDoc a

-- | Name of type as it appears in definitions section.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: TypeHasDoc a => Proxy a -> Text

-- | Name of type as it appears in definitions section.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: (TypeHasDoc a, Generic a, KnownSymbol (GenericTypeName a)) => Proxy a -> Text

-- | Explanation of a type. Markdown formatting is allowed.
typeDocMdDescription :: TypeHasDoc a => Builder

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: TypeHasDoc a => Proxy a -> WithinParens -> Builder

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: (TypeHasDoc a, Typeable a, IsHomomorphic a) => Proxy a -> WithinParens -> Builder

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: TypeHasDoc a => Proxy a -> [SomeTypeWithDoc]

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: (TypeHasDoc a, Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: TypeHasDoc a => TypeDocHaskellRep a

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: (TypeHasDoc a, Generic a, GTypeHasDoc (Rep a), IsHomomorphic a) => TypeDocHaskellRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: TypeHasDoc a => TypeDocMichelsonRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: (TypeHasDoc a, SingI (ToT a), IsHomomorphic a) => TypeDocMichelsonRep a

-- | Whether given text should be rendered grouped in parentheses (if they
--   make sense).
newtype WithinParens
WithinParens :: Bool -> WithinParens

-- | Stands for representation of some Haskell ADT corresponding to
--   Michelson value. Type parameter <tt>a</tt> is what you put in place of
--   each field of the datatype, e.g. information about field type.
--   
--   Outer list layer corresponds to union, and the inner one corresponds
--   to products within constructors. Constructors and fields names are
--   present.
type ADTRep a = NonEmpty (Text, [(Maybe Text, a)])

-- | Show given <a>ADTRep</a> in a neat way.
buildADTRep :: forall a. (WithinParens -> a -> Builder) -> ADTRep a -> Builder
applyWithinParens :: WithinParens -> Builder -> Builder

-- | Render a reference to a type which consists of type constructor (you
--   have to provide name of this type constructor and documentation for
--   the whole type) and zero or more type arguments.
customTypeDocMdReference :: (Text, DType) -> [DType] -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for homomorphic types only.
homomorphicTypeDocMdReference :: forall (t :: Type). (Typeable t, TypeHasDoc t, IsHomomorphic t) => Proxy t -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with one type
--   argument, like <tt>Maybe Integer</tt>.
poly1TypeDocMdReference :: forall t (r :: Type) (a :: Type). (r ~ t a, Typeable t, Each '[TypeHasDoc] [r, a], IsHomomorphic t) => Proxy r -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with two type
--   arguments, like <tt>Lambda Integer Natural</tt>.
poly2TypeDocMdReference :: forall t (r :: Type) (a :: Type) (b :: Type). (r ~ t a b, Typeable t, Each '[TypeHasDoc] [r, a, b], IsHomomorphic t) => Proxy r -> WithinParens -> Builder

-- | Implement <a>typeDocDependencies</a> via getting all immediate fields
--   of a datatype.
--   
--   Note: this will not include phantom types, I'm not sure yet how this
--   scenario should be handled (@martoon).
genericTypeDocDependencies :: forall a. (Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | Implement <a>typeDocHaskellRep</a> for a homomorphic type.
--   
--   Note that it does not require your type to be of <a>IsHomomorphic</a>
--   instance, which can be useful for some polymorhpic types which, for
--   documentation purposes, we want to consider homomorphic. Example:
--   <a>Operation</a> is in fact polymorhpic, but we don't want this fact
--   to be reflected in the documentation.
homomorphicTypeDocHaskellRep :: forall a. (Generic a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep a

-- | Implement <a>typeDocHaskellRep</a> on example of given concrete type.
--   
--   This is a best effort attempt to implement <a>typeDocHaskellRep</a>
--   for polymorhpic types, as soon as there is no simple way to preserve
--   type variables when automatically deriving Haskell representation of a
--   type.
concreteTypeDocHaskellRep :: forall a b. (Typeable a, IsoValue a, Generic a, GTypeHasDoc (Rep a), HaveCommonTypeCtor b a) => TypeDocHaskellRep b

-- | Erase fields from Haskell datatype representation.
--   
--   Use this when rendering fields names is undesired.
haskellRepNoFields :: TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Cut fields prefixes which we use according to the style guide.
--   
--   E.g. <tt>cmMyField</tt> field will be transformed to <tt>myField</tt>.
haskellRepStripFieldPrefix :: HasCallStack => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Implement <a>typeDocMichelsonRep</a> for homomorphic type.
homomorphicTypeDocMichelsonRep :: forall a. SingI (ToT a) => TypeDocMichelsonRep a

-- | Implement <a>typeDocMichelsonRep</a> on example of given concrete
--   type.
--   
--   This function exists for the same reason as
--   <a>concreteTypeDocHaskellRep</a>.
concreteTypeDocMichelsonRep :: forall a b. (Typeable a, SingI (ToT a), HaveCommonTypeCtor b a) => TypeDocMichelsonRep b
type InstrUnwrapC dt name = (IsoValue dt, Generic dt, GInstrUnwrap (Rep dt) (LnrBranch (GetNamed name dt)) (CtorOnlyField name dt), GValueType (Rep dt) ~ ToT dt)
type family GCaseBranchInput ctor x :: CaseClauseParam
type family GCaseClauses x :: [CaseClauseParam]

-- | List of <a>CaseClauseParam</a>s required to pattern match on the given
--   type.
type CaseClauses a = GCaseClauses (Rep a)

-- | Type information about single case clause.
data CaseClause (inp :: [T]) (out :: [T]) (param :: CaseClauseParam)
[CaseClause] :: Instr (AppendCtorField x inp) out -> CaseClause inp out ( 'CaseClauseParam ctor x)

-- | In what different case branches differ - related constructor name and
--   input stack type which the branch starts with.
data CaseClauseParam
CaseClauseParam :: Symbol -> CtorField -> CaseClauseParam
type InstrCaseC dt inp out = (IsoValue dt, GInstrCase (Rep dt), GValueType (Rep dt) ~ ToT dt)
data MyCompoundType
type InstrWrapC dt name = (IsoValue dt, Generic dt, GInstrWrap (Rep dt) (LnrBranch (GetNamed name dt)) (LnrFieldType (GetNamed name dt)), GValueType (Rep dt) ~ ToT dt)

-- | Expect referred constructor to have only one field (otherwise compile
--   error is raised) and extract its type.
type CtorOnlyField name dt = RequireOneField name (GetCtorField dt name)

-- | Expect referred constructor to have only one field (in form of
--   constraint) and extract its type.
type CtorHasOnlyField ctor dt f = GetCtorField dt ctor ~  'OneField f

-- | Get type of constructor fields (one or zero) referred by given
--   datatype and name.
type GetCtorField dt ctor = LnrFieldType (GetNamed ctor dt)

-- | Whether given type represents an atomic Michelson value.
type family IsPrimitiveValue (x :: Type) :: Bool

-- | To use <a>AppendCtorField</a> not only here for <a>T</a>-based stacks,
--   but also later in Lorentz with <a>Type</a>-based stacks we need the
--   following property.
type AppendCtorFieldAxiom (cf :: CtorField) (st :: [Type]) = ToTs (AppendCtorField cf st) ~ AppendCtorField cf (ToTs st)

-- | Push field to stack, if any.
type family AppendCtorField (cf :: CtorField) (l :: [k]) :: [k]

-- | Get <i>something</i> as field of the given constructor.
type family ExtractCtorField (cf :: CtorField)

-- | We support only two scenarious - constructor with one field and
--   without fields. Nonetheless, it's not that sad since for sum types we
--   can't even assign names to fields if there are many (the style guide
--   prohibits partial records).
data CtorField
OneField :: Type -> CtorField
NoFields :: CtorField

-- | Proof of <a>AppendCtorFieldAxiom</a>.
appendCtorFieldAxiom :: (AppendCtorFieldAxiom ( 'OneField Word) '[Int], AppendCtorFieldAxiom  'NoFields '[Int]) => Dict (AppendCtorFieldAxiom cf st)

-- | Wrap given element into a constructor with the given name.
--   
--   Mentioned constructor must have only one field.
--   
--   Since labels interpretable by <a>OverloadedLabels</a> extension cannot
--   start with capital latter, prepend constructor name with letter "c"
--   (see examples below).
instrWrap :: forall dt name st. InstrWrapC dt name => Label name -> Instr (AppendCtorField (GetCtorField dt name) st) (ToT dt : st)

-- | Wrap a haskell value into a constructor with the given name.
--   
--   This is symmetric to <a>instrWrap</a>.
hsWrap :: forall dt name. InstrWrapC dt name => Label name -> ExtractCtorField (GetCtorField dt name) -> dt

-- | Pattern-match on the given datatype.
instrCase :: forall dt out inp. InstrCaseC dt inp out => Rec (CaseClause inp out) (CaseClauses dt) -> Instr (ToT dt : inp) out

-- | Lift an instruction to case clause.
--   
--   You should write out constructor name corresponding to the clause
--   explicitly. Prefix constructor name with "c" letter, otherwise your
--   label will not be recognized by Haskell parser. Passing constructor
--   name can be circumvented but doing so is not recomended as mentioning
--   contructor name improves readability and allows avoiding some
--   mistakes.
(//->) :: Label ("c" `AppendSymbol` ctor) -> Instr (AppendCtorField x inp) out -> CaseClause inp out ( 'CaseClauseParam ctor x)
infixr 8 //->

-- | Unwrap a constructor with the given name.
--   
--   Rules which apply to <a>instrWrap</a> function work here as well.
--   Although, unlike <tt>instrWrap</tt>, this function does not work for
--   nullary constructors.
instrUnwrapUnsafe :: forall dt name st. InstrUnwrapC dt name => Label name -> Instr (ToT dt : st) (ToT (CtorOnlyField name dt) : st)

-- | Try to unwrap a constructor with the given name.
hsUnwrap :: forall dt name. InstrUnwrapC dt name => Label name -> dt -> Maybe (CtorOnlyField name dt)

module Michelson.Typed

module Michelson.TypeCheck.Types

-- | Data type holding type information for stack (Heterogeneous Stack
--   Type).
--   
--   This data type is used along with instruction data type <tt>Instr</tt>
--   to carry information about its input and output stack types.
--   
--   That is, if there is value <tt>instr :: Instr inp out</tt>, along with
--   this <tt>instr</tt> one may carry <tt>inpHST :: HST inp</tt> and
--   <tt>outHST :: HST out</tt> which will contain whole information about
--   input and output stack types for <tt>instr</tt>.
--   
--   Data type <tt>HST</tt> is very similar to <tt>Data.Vinyl.Rec</tt>, but
--   is specialized for a particular purpose. In particular, definition of
--   <tt>HST (t1 ': t2 ': ... tn ': '[])</tt> requires constraints
--   <tt>(Typeable t1, Typeable t2, ..., Typeable tn)</tt> as well as
--   constraints <tt>(Typeable '[ t1 ], Typeable '[ t1, t2 ], ...)</tt>.
--   These applications of <tt>Typeable</tt> class are required for
--   convenient usage of type encoded by <tt>HST ts</tt> with some
--   functions from <tt>Data.Typeable</tt>.
--   
--   Data type <tt>HST</tt> (Heterogeneous Stack Type) is a heterogenuous
--   list of triples. First element of triple is a type singleton which is
--   due to main motivation behind <tt>HST</tt>, namely for it to be used
--   as representation of <tt>Instr</tt> type data for pattern-matching.
--   Second element of triple is a structure, holding field and type
--   annotations for a given type. Third element of triple is an optional
--   variable annotation for the stack element.
data HST (ts :: [T])
[SNil] :: HST '[]
[::&] :: (Typeable xs, Typeable x, SingI x) => (Sing x, Notes x, VarAnn) -> HST xs -> HST (x : xs)
infixr 7 ::&

-- | Append a type to <a>HST</a>, assuming that notes and annotations for
--   this type are unknown.
(-:&) :: (Typeable xs, Typeable x, SingI x) => Sing x -> HST xs -> HST (x : xs)
infixr 7 -:&

-- | No-argument type wrapper for <tt>HST</tt> data type.
data SomeHST
[SomeHST] :: Typeable ts => HST ts -> SomeHST

-- | This data type keeps part of type check result - instruction and
--   corresponding output stack.
data SomeInstrOut inp

-- | Type-check result with concrete output stack, most common case.
--   
--   Output stack type is wrapped inside the type and <tt>Typeable</tt>
--   constraint is provided to allow convenient unwrapping.
[:::] :: Typeable out => Instr inp out -> HST out -> SomeInstrOut inp

-- | Type-check result which matches against arbitrary output stack.
--   Information about annotations in the output stack is absent.
--   
--   This case is only possible when the corresponding code terminates with
--   <tt>FAILWITH</tt> instruction in all possible executions. The opposite
--   may be not true though (example: you push always-failing lambda and
--   immediatelly execute it - stack type is known).
[AnyOutInstr] :: (forall out. Instr inp out) -> SomeInstrOut inp
infix 9 :::

-- | Data type keeping the whole type check result: instruction and type
--   representations of instruction's input and output.
data SomeInstr inp
[:/] :: HST inp -> SomeInstrOut inp -> SomeInstr inp
infix 8 :/

-- | Data type, holding strictly-typed Michelson value along with its type
--   singleton.
data SomeNotedValue
[::::] :: (SingI t, Typeable t) => Value t -> (Sing t, Notes t) -> SomeNotedValue
data SomeContract
[SomeContract] :: (Each [Typeable, SingI, HasNoOp] [st, cp], HasNoBigMap cp, BigMapConstraint st) => Contract cp st -> HST (ContractInp cp st) -> HST (ContractOut st) -> SomeContract

-- | Data type, holding strictly-typed Michelson value along with its type
--   singleton.
data SomeCValue
[:--:] :: (SingI t, Typeable t) => CValue t -> Sing t -> SomeCValue

-- | Datatype used in <tt>typeCheckStorageOrParameter</tt> instead of
--   simple <a>Bool</a> for more convenience.
data StorageOrParameter
Storage :: StorageOrParameter
Parameter :: StorageOrParameter

-- | Set of variables defined in a let-block.
data BoundVars
BoundVars :: Map Var Type -> Maybe SomeHST -> BoundVars

-- | State for type checking <tt>nop</tt>
type TcExtFrames = [BoundVars]
mapSomeContract :: (forall inp out. Instr inp out -> Instr inp out) -> SomeContract -> SomeContract
noBoundVars :: BoundVars
instance GHC.Classes.Eq Michelson.TypeCheck.Types.StorageOrParameter
instance GHC.Show.Show Michelson.TypeCheck.Types.SomeHST
instance GHC.Show.Show Michelson.TypeCheck.Types.SomeContract
instance GHC.Show.Show Michelson.TypeCheck.Types.SomeNotedValue
instance GHC.Show.Show (Michelson.Typed.Instr.ExtInstr inp) => GHC.Show.Show (Michelson.TypeCheck.Types.SomeInstr inp)
instance GHC.Show.Show (Michelson.Typed.Instr.ExtInstr inp) => GHC.Show.Show (Michelson.TypeCheck.Types.SomeInstrOut inp)
instance GHC.Classes.Eq Michelson.TypeCheck.Types.SomeHST
instance GHC.Show.Show (Michelson.TypeCheck.Types.HST ts)
instance GHC.Classes.Eq (Michelson.TypeCheck.Types.HST ts)

module Michelson.TypeCheck.Error

-- | Data type that represents various errors which are related to type
--   system. These errors are used to specify info about type check errors
--   in <tt>TCError</tt> data type.
data TCTypeError

-- | Annotation unify error
AnnError :: AnnConvergeError -> TCTypeError

-- | Notes extraction error
ExtractionTypeMismatch :: TypeConvergeError -> TCTypeError

-- | Type equality error
TypeEqError :: T -> T -> TCTypeError

-- | Stacks equality error
StackEqError :: [T] -> [T] -> TCTypeError

-- | Error that happens when some instruction doesn't have support for some
--   types
UnsupportedTypes :: [T] -> TCTypeError

-- | Error that happens when we meet unknown type
UnknownType :: T -> TCTypeError

-- | Type check error
data TCError
TCFailedOnInstr :: ExpandedInstr -> SomeHST -> Text -> InstrCallStack -> Maybe TCTypeError -> TCError
TCFailedOnValue :: Value -> T -> Text -> InstrCallStack -> Maybe TCTypeError -> TCError
TCContractError :: Text -> Maybe TCTypeError -> TCError
TCUnreachableCode :: InstrCallStack -> NonEmpty ExpandedOp -> TCError
TCExtError :: SomeHST -> InstrCallStack -> ExtError -> TCError

-- | Various type errors possible when checking Morley extension commands
data ExtError
LengthMismatch :: StackTypePattern -> ExtError
VarError :: Text -> StackFn -> ExtError
TypeMismatch :: StackTypePattern -> Int -> TCTypeError -> ExtError
TyVarMismatch :: Var -> Type -> StackTypePattern -> Int -> TCTypeError -> ExtError
StkRestMismatch :: StackTypePattern -> SomeHST -> SomeHST -> TCTypeError -> ExtError
TestAssertError :: Text -> ExtError
InvalidStackReference :: StackRef -> StackSize -> ExtError
newtype StackSize
StackSize :: Natural -> StackSize
instance GHC.Classes.Eq Michelson.TypeCheck.Error.TCError
instance GHC.Classes.Eq Michelson.TypeCheck.Error.ExtError
instance GHC.Classes.Eq Michelson.TypeCheck.Error.StackSize
instance GHC.Show.Show Michelson.TypeCheck.Error.StackSize
instance GHC.Classes.Eq Michelson.TypeCheck.Error.TCTypeError
instance GHC.Show.Show Michelson.TypeCheck.Error.TCTypeError
instance Formatting.Buildable.Buildable Michelson.TypeCheck.Error.TCError
instance Formatting.Buildable.Buildable Michelson.Untyped.Instr.ExpandedInstr => GHC.Show.Show Michelson.TypeCheck.Error.TCError
instance Formatting.Buildable.Buildable Michelson.Untyped.Instr.ExpandedInstr => GHC.Exception.Type.Exception Michelson.TypeCheck.Error.TCError
instance Formatting.Buildable.Buildable Michelson.TypeCheck.Error.ExtError
instance Formatting.Buildable.Buildable Michelson.TypeCheck.Error.TCTypeError

module Michelson.TypeCheck.TypeCheck
type TcInstrHandler = forall inp. Typeable inp => ExpandedInstr -> HST inp -> TypeCheckInstr (SomeInstr inp)
type TcOriginatedContracts = Map Address Type
type TcResult inp = Either TCError (SomeInstr inp)

-- | The typechecking state
data TypeCheckEnv
TypeCheckEnv :: TcExtFrames -> Type -> TcOriginatedContracts -> TypeCheckEnv
[tcExtFrames] :: TypeCheckEnv -> TcExtFrames
[tcContractParam] :: TypeCheckEnv -> Type
[tcContracts] :: TypeCheckEnv -> TcOriginatedContracts
type TypeCheck a = ExceptT TCError (State TypeCheckEnv) a
runTypeCheck :: Type -> TcOriginatedContracts -> TypeCheck a -> Either TCError a
type TypeCheckInstr a = ReaderT InstrCallStack (ExceptT TCError (State TypeCheckEnv)) a

-- | Run type checker as if it worked isolated from other world - no access
--   to environment of the current contract is allowed.
--   
--   Use this function for test purposes only or for some utilities when
--   environment does not matter. In particular, it is assumed that
--   whatever we typecheck does not depend on the parameter type of the
--   contract which is being typechecked (because there is no contract that
--   we are typechecking).
runTypeCheckIsolated :: TypeCheck a -> Either TCError a
tcContractParamL :: Lens' TypeCheckEnv Type
tcContractsL :: Lens' TypeCheckEnv TcOriginatedContracts
tcExtFramesL :: Lens' TypeCheckEnv TcExtFrames

module Michelson.TypeCheck.Helpers
onLeft :: Either a c -> (a -> b) -> Either b c

-- | Function which derives special annotations for CDR / CAR instructions.
deriveSpecialVN :: VarAnn -> FieldAnn -> VarAnn -> VarAnn

-- | Function which derives special annotations for PAIR instruction.
--   
--   Namely, it does following transformation: <tt> PAIR %</tt><tt>
--   %</tt><tt> [ </tt><tt>p.a int : </tt><tt>p.b int : .. ] ~ [ </tt><tt>p
--   (pair (int %a) (int %b) : .. ] </tt>
--   
--   All relevant cases (e.g. <tt>PAIR %myf %</tt><tt> </tt>) are handled
--   as they should be according to spec.
deriveSpecialFNs :: FieldAnn -> FieldAnn -> VarAnn -> VarAnn -> (VarAnn, FieldAnn, FieldAnn)

-- | Append suffix to variable annotation (if it's not empty)
deriveVN :: VarAnn -> VarAnn -> VarAnn

-- | Function which extracts annotations for <tt>or</tt> type (for left and
--   right parts).
--   
--   It extracts field/type annotations and also auto-generates variable
--   annotations if variable annotation is not provided as second argument.
deriveNsOr :: Notes ( 'TOr a b) -> VarAnn -> (Notes a, Notes b, VarAnn, VarAnn)

-- | Function which extracts annotations for <tt>option t</tt> type.
--   
--   It extracts field/type annotations and also auto-generates variable
--   annotation for <tt>Some</tt> case if it is not provided as second
--   argument.
deriveNsOption :: Notes ( 'TOption a) -> VarAnn -> (Notes a, VarAnn)
convergeHSTEl :: (Sing t, Notes t, VarAnn) -> (Sing t, Notes t, VarAnn) -> Either AnnConvergeError (Sing t, Notes t, VarAnn)

-- | Combine annotations from two given stack types
convergeHST :: HST ts -> HST ts -> Either AnnConvergeError (HST ts)

-- | Extract singleton for each single type of the given stack.
hstToTs :: HST st -> [T]

-- | Check whether the given stack types are equal.
eqHST :: forall as bs. (Typeable as, Typeable bs) => HST as -> HST bs -> Either TCTypeError (as :~: bs)

-- | Check whether the given stack has size 1 and its only element matches
--   the given type. This function is a specialized version of
--   <a>eqHST</a>.
eqHST1 :: forall t st. (Typeable st, Typeable t, SingI t) => HST st -> Either TCTypeError (st :~: '[t])
lengthHST :: HST xs -> Natural

-- | Check whether elements go in strictly ascending order and return the
--   original list (to keep only one pass on the original list).
ensureDistinctAsc :: (Ord b, Show a) => (a -> b) -> [a] -> Either Text [a]

-- | Function <tt>eqType</tt> is a simple wrapper around
--   <tt>Data.Typeable.eqT</tt> suited for use within <tt>Either
--   TCTypeError a</tt> applicative.
eqType :: forall (a :: T) (b :: T). Each [Typeable, SingI] [a, b] => Either TCTypeError (a :~: b)
checkEqT :: forall (a :: T) (b :: T) ts m. (Each [Typeable, SingI] [a, b], Typeable ts, MonadReader InstrCallStack m, MonadError TCError m) => ExpandedInstr -> HST ts -> Text -> m (a :~: b)
checkEqHST :: forall (a :: [T]) (b :: [T]) ts m. (Typeable a, Typeable b, Typeable ts, MonadReader InstrCallStack m, MonadError TCError m) => HST a -> HST b -> ExpandedInstr -> HST ts -> Text -> m (a :~: b)
onTypeCheckInstrAnnErr :: (MonadReader InstrCallStack m, MonadError TCError m, Typeable ts) => ExpandedInstr -> HST ts -> Text -> Either AnnConvergeError a -> m a
onTypeCheckInstrTypeErr :: (MonadReader InstrCallStack m, MonadError TCError m, Typeable ts) => ExpandedInstr -> HST ts -> Text -> Either TypeConvergeError a -> m a
onTypeCheckInstrErr :: (MonadReader InstrCallStack m, MonadError TCError m) => ExpandedInstr -> SomeHST -> Text -> Either TCTypeError a -> m a
typeCheckInstrErr :: (MonadReader InstrCallStack m, MonadError TCError m) => ExpandedInstr -> SomeHST -> Text -> m a
typeCheckImpl :: forall inp. Typeable inp => TcInstrHandler -> [ExpandedOp] -> HST inp -> TypeCheckInstr (SomeInstr inp)

-- | Check whether typed and untyped types converge
compareTypes :: forall t. (Typeable t, SingI t) => (Sing t, Notes t) -> Type -> Either TCTypeError ()

-- | Generic implementation for MEMeration
memImpl :: forall (q :: CT) (c :: T) ts inp m. (MonadReader InstrCallStack m, MonadError TCError m, Typeable ts, Typeable (MemOpKey c), SingI (MemOpKey c), MemOp c, inp ~ ( 'Tc q : (c : ts))) => ExpandedInstr -> HST inp -> VarAnn -> m (SomeInstr inp)
getImpl :: forall c getKey rs inp m. (GetOp c, Typeable (GetOpKey c), Typeable (GetOpVal c), SingI (GetOpVal c), SingI (GetOpKey c), inp ~ (getKey : (c : rs)), MonadReader InstrCallStack m, MonadError TCError m) => ExpandedInstr -> HST (getKey : (c : rs)) -> Sing (GetOpVal c) -> Notes (GetOpVal c) -> VarAnn -> m (SomeInstr inp)
updImpl :: forall c updKey updParams rs inp m. (UpdOp c, Typeable (UpdOpKey c), SingI (UpdOpKey c), Typeable (UpdOpParams c), SingI (UpdOpParams c), inp ~ (updKey : (updParams : (c : rs))), MonadReader InstrCallStack m, MonadError TCError m) => ExpandedInstr -> HST (updKey : (updParams : (c : rs))) -> m (SomeInstr inp)
sliceImpl :: (SliceOp c, Typeable c, inp ~ ( 'Tc  'CNat : ( 'Tc  'CNat : (c : rs))), Monad m) => HST inp -> VarAnn -> m (SomeInstr inp)
concatImpl :: (ConcatOp c, Typeable c, inp ~ (c : (c : rs)), MonadReader InstrCallStack m, MonadError TCError m) => HST inp -> VarAnn -> m (SomeInstr inp)
concatImpl' :: (ConcatOp c, Typeable c, inp ~ ( 'TList c : rs), Monad m) => HST inp -> VarAnn -> m (SomeInstr inp)
sizeImpl :: (SizeOp c, inp ~ (c : rs), Monad m) => HST inp -> VarAnn -> m (SomeInstr inp)

-- | Helper function to construct instructions for binary arithmetic
--   operations.
arithImpl :: (Typeable (ArithRes aop n m), SingI (ArithRes aop n m), Typeable ( 'Tc (ArithRes aop n m) : s), inp ~ ( 'Tc n : ( 'Tc m : s)), Monad t) => Instr inp ( 'Tc (ArithRes aop n m) : s) -> HST inp -> VarAnn -> t (SomeInstr inp)
addImpl :: forall a b inp rs m. (Typeable rs, Each [Typeable, SingI] [a, b], inp ~ ( 'Tc a : ( 'Tc b : rs)), MonadReader InstrCallStack m, MonadError TCError m) => Sing a -> Sing b -> HST inp -> VarAnn -> m (SomeInstr inp)
subImpl :: forall a b inp rs m. (Typeable rs, Each [Typeable, SingI] [a, b], inp ~ ( 'Tc a : ( 'Tc b : rs)), MonadReader InstrCallStack m, MonadError TCError m) => Sing a -> Sing b -> HST inp -> VarAnn -> m (SomeInstr inp)
mulImpl :: forall a b inp rs m. (Typeable rs, Each [Typeable, SingI] [a, b], inp ~ ( 'Tc a : ( 'Tc b : rs)), MonadReader InstrCallStack m, MonadError TCError m) => Sing a -> Sing b -> HST inp -> VarAnn -> m (SomeInstr inp)
edivImpl :: forall a b inp rs m. (Typeable rs, Each [Typeable, SingI] [a, b], inp ~ ( 'Tc a : ( 'Tc b : rs)), MonadReader InstrCallStack m, MonadError TCError m) => Sing a -> Sing b -> HST inp -> VarAnn -> m (SomeInstr inp)
compareImpl :: forall a b inp rs m. (Typeable rs, Each [Typeable, SingI] [a, b], inp ~ ( 'Tc a : ( 'Tc b : rs)), MonadReader InstrCallStack m, MonadError TCError m) => Sing a -> Sing b -> HST inp -> VarAnn -> m (SomeInstr inp)

-- | Helper function to construct instructions for binary arithmetic
--   operations.
unaryArithImpl :: (Typeable (UnaryArithRes aop n), SingI (UnaryArithRes aop n), Typeable ( 'Tc (UnaryArithRes aop n) : s), inp ~ ( 'Tc n : s), Monad t) => Instr inp ( 'Tc (UnaryArithRes aop n) : s) -> HST inp -> VarAnn -> t (SomeInstr inp)

module Michelson.TypeCheck.Value

-- | Function <tt>typeCheckValImpl</tt> converts a single Michelson value
--   given in representation from <tt>Michelson.Type</tt> module to
--   representation in strictly typed GADT.
--   
--   As a third argument, <tt>typeCheckValImpl</tt> accepts expected type
--   of value.
--   
--   Type checking algorithm pattern-matches on parse value representation,
--   expected type <tt>t</tt> and constructs <tt>Val t</tt> value.
--   
--   If there was no match on a given pair of value and expected type, that
--   is interpreted as input of wrong type and type check finishes with
--   error.
typeCheckValImpl :: TcInstrHandler -> Value -> (Sing t, Notes t) -> TypeCheckInstr SomeNotedValue
typeCheckCValue :: Value' op -> CT -> Either (Value' op, TCTypeError) SomeCValue


-- | Type-checking of Morley extension.
module Michelson.TypeCheck.Ext
typeCheckExt :: forall s. Typeable s => TypeCheckListHandler s -> ExpandedExtInstr -> HST s -> TypeCheckInstr (SomeInstr s)


-- | Module, providing functions for conversion from instruction and value
--   representation from <tt>Michelson.Type</tt> module to strictly-typed
--   GADT-based representation from <tt>Michelson.Value</tt> module.
--   
--   This conversion is labeled as type check because that's what we are
--   obliged to do on our way.
--   
--   Type check algorithm relies on the property of Michelson language that
--   each instruction on a given input stack type produces a definite
--   output stack type. Michelson contract defines concrete types for
--   storage and parameter, from which input stack type is deduced. Then
--   this type is being combined with each subsequent instruction,
--   producing next stack type after each application.
--   
--   Function <tt>typeCheck</tt> takes list of instructions and returns
--   value of type <tt>Instr inp out</tt> along with <tt>HST inp</tt> and
--   <tt>HST out</tt> all wrapped into <tt>SomeInstr</tt> data type. This
--   wrapping is done to satsify Haskell type system (which has no support
--   for dependent types). Functions <tt>typeCheckInstr</tt>,
--   <tt>typeCheckValue</tt> behave similarly.
--   
--   When a recursive call is made within <tt>typeCheck</tt>,
--   <tt>typeCheckInstr</tt> or <tt>typeCheckValue</tt>, result of a call
--   is unwrapped from <tt>SomeInstr</tt> and type information from <tt>HST
--   inp</tt> and <tt>HST out</tt> is being used to assert that recursive
--   call returned instruction of expected type (error is thrown
--   otherwise).
module Michelson.TypeCheck.Instr
typeCheckContract :: TcOriginatedContracts -> Contract -> Either TCError SomeContract

-- | Function <tt>typeCheckValue</tt> converts a single Michelson value
--   given in representation from <tt>Michelson.Untyped</tt> module
--   hierarchy to representation in strictly typed GADT.
--   
--   As a second argument, <tt>typeCheckValue</tt> accepts expected type of
--   value.
--   
--   Type checking algorithm pattern-matches on parse value representation,
--   expected type <tt>t</tt> and constructs <tt>Val t</tt> value.
--   
--   If there was no match on a given pair of value and expected type, that
--   is interpreted as input of wrong type and type check finishes with
--   error.
typeCheckValue :: Value -> (Sing t, Notes t) -> TypeCheckInstr SomeNotedValue

-- | Like <a>typeCheckValue</a>, but returns value of a desired type.
typeVerifyValue :: forall t. (Typeable t, SingI t) => Value -> TypeCheckInstr (Value t)

-- | Function <tt>typeCheckList</tt> converts list of Michelson
--   instructions given in representation from <tt>Michelson.Type</tt>
--   module to representation in strictly typed GADT.
--   
--   Types are checked along the way which is neccessary to construct a
--   strictly typed value.
--   
--   As a second argument, <tt>typeCheckList</tt> accepts input stack type
--   representation.
typeCheckList :: Typeable inp => [ExpandedOp] -> HST inp -> TypeCheck (SomeInstr inp)
typeCheckStorageOrParameter :: StorageOrParameter -> Value -> TcOriginatedContracts -> Contract -> Either TCError SomeValue

-- | Datatype used in <tt>typeCheckStorageOrParameter</tt> instead of
--   simple <a>Bool</a> for more convenience.
data StorageOrParameter
Storage :: StorageOrParameter
Parameter :: StorageOrParameter

module Michelson.TypeCheck
typeCheckContract :: TcOriginatedContracts -> Contract -> Either TCError SomeContract
typeCheckStorageOrParameter :: StorageOrParameter -> Value -> TcOriginatedContracts -> Contract -> Either TCError SomeValue

-- | Function <tt>typeCheckValue</tt> converts a single Michelson value
--   given in representation from <tt>Michelson.Untyped</tt> module
--   hierarchy to representation in strictly typed GADT.
--   
--   As a second argument, <tt>typeCheckValue</tt> accepts expected type of
--   value.
--   
--   Type checking algorithm pattern-matches on parse value representation,
--   expected type <tt>t</tt> and constructs <tt>Val t</tt> value.
--   
--   If there was no match on a given pair of value and expected type, that
--   is interpreted as input of wrong type and type check finishes with
--   error.
typeCheckValue :: Value -> (Sing t, Notes t) -> TypeCheckInstr SomeNotedValue

-- | Like <a>typeCheckValue</a>, but returns value of a desired type.
typeVerifyValue :: forall t. (Typeable t, SingI t) => Value -> TypeCheckInstr (Value t)

-- | Function <tt>typeCheckList</tt> converts list of Michelson
--   instructions given in representation from <tt>Michelson.Type</tt>
--   module to representation in strictly typed GADT.
--   
--   Types are checked along the way which is neccessary to construct a
--   strictly typed value.
--   
--   As a second argument, <tt>typeCheckList</tt> accepts input stack type
--   representation.
typeCheckList :: Typeable inp => [ExpandedOp] -> HST inp -> TypeCheck (SomeInstr inp)
typeCheckCValue :: Value' op -> CT -> Either (Value' op, TCTypeError) SomeCValue
typeCheckExt :: forall s. Typeable s => TypeCheckListHandler s -> ExpandedExtInstr -> HST s -> TypeCheckInstr (SomeInstr s)

-- | Function <tt>eqType</tt> is a simple wrapper around
--   <tt>Data.Typeable.eqT</tt> suited for use within <tt>Either
--   TCTypeError a</tt> applicative.
eqType :: forall (a :: T) (b :: T). Each [Typeable, SingI] [a, b] => Either TCTypeError (a :~: b)

-- | Check whether typed and untyped types converge
compareTypes :: forall t. (Typeable t, SingI t) => (Sing t, Notes t) -> Type -> Either TCTypeError ()


-- | Utilities for arbitrary data generation in property tests.
module Michelson.Test.Gen

-- | Minimal (earliest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
minTimestamp :: Timestamp

-- | Maximal (latest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
maxTimestamp :: Timestamp

-- | Median of <a>minTimestamp</a> and <a>maxTimestamp</a>. Useful for
--   testing (exactly half of generated dates will be before and after this
--   date).
midTimestamp :: Timestamp
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.CValue.CValue 'Michelson.Untyped.Type.CKeyHash)
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.CValue.CValue 'Michelson.Untyped.Type.CMutez)
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.CValue.CValue 'Michelson.Untyped.Type.CInt)
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.CValue.CValue a) => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr ('Michelson.Typed.T.Tc a))
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr a) => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr ('Michelson.Typed.T.TList a))
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr 'Michelson.Typed.T.TUnit)
instance (Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr a), Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr b)) => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.Value.Value' instr ('Michelson.Typed.T.TPair a b))
instance Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Typed.CValue.CValue 'Michelson.Untyped.Type.CTimestamp)
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Core.Mutez
instance Test.QuickCheck.Arbitrary.Arbitrary Tezos.Core.Timestamp


-- | Global blockchain state (emulated).
module Michelson.Runtime.GState

-- | State of a contract with code.
data ContractState
ContractState :: !Mutez -> !Value -> !Contract -> !Maybe SomeContract -> !Maybe SomeValue -> ContractState

-- | Amount of mutez owned by this contract.
[csBalance] :: ContractState -> !Mutez

-- | Storage value associated with this contract.
[csStorage] :: ContractState -> !Value

-- | Contract itself (untyped).
[csContract] :: ContractState -> !Contract
[csTypedContract] :: ContractState -> !Maybe SomeContract

-- | We keep typed representation of contract code and storage in form,
--   that hides their actual type in order to simplify the rest of the code
--   (e.g. avoid type parameters for <a>ContractState</a> and so on). They
--   are made optional in order to perform safe parsing from JSON (we
--   simply return <a>Nothing</a> in this parser and use
--   <a>getTypedStorage</a> or <a>getTypedContract</a> that optionally
--   typecheck storage or contract code).
[csTypedStorage] :: ContractState -> !Maybe SomeValue
getTypedContract :: GState -> ContractState -> Either TCError SomeContract
getTypedStorage :: GState -> ContractState -> Either TCError SomeValue

-- | State of an arbitrary address.
data AddressState

-- | For contracts without code we store only its balance.
ASSimple :: !Mutez -> AddressState

-- | For contracts with code we store more state represented by
--   <a>ContractState</a>.
ASContract :: !ContractState -> AddressState

-- | Extract balance from <a>AddressState</a>.
asBalance :: AddressState -> Mutez

-- | Persistent data passed to Morley contracts which can be updated as
--   result of contract execution.
data GState
GState :: Map Address AddressState -> GState

-- | All known addresses and their state.
[gsAddresses] :: GState -> Map Address AddressState

-- | Initially these addresses have a lot of money.
genesisAddresses :: NonEmpty Address

-- | KeyHash of genesis address.
genesisKeyHashes :: NonEmpty KeyHash

-- | One of genesis addresses.
genesisAddress :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress1 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress2 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress3 :: Address
genesisAddress4 :: Address
genesisAddress5 :: Address
genesisAddress6 :: Address

-- | One of genesis key hashes.
genesisKeyHash :: KeyHash

-- | Initial <a>GState</a>. It's supposed to be used if no <a>GState</a> is
--   provided. It puts plenty of money on each genesis address.
initGState :: GState

-- | Read <a>GState</a> from a file.
readGState :: FilePath -> IO GState

-- | Write <a>GState</a> to a file.
writeGState :: FilePath -> GState -> IO ()

-- | Updates that can be applied to <a>GState</a>.
data GStateUpdate
GSAddAddress :: !Address -> !AddressState -> GStateUpdate
GSSetStorageValue :: !Address -> !Value -> !SomeValue -> GStateUpdate
GSSetBalance :: !Address -> !Mutez -> GStateUpdate
data GStateUpdateError
GStateAddressExists :: !Address -> GStateUpdateError
GStateUnknownAddress :: !Address -> GStateUpdateError
GStateNotContract :: !Address -> GStateUpdateError

-- | Apply <a>GStateUpdate</a> to <a>GState</a>.
applyUpdate :: GStateUpdate -> GState -> Either GStateUpdateError GState

-- | Apply a list of <a>GStateUpdate</a>s to <a>GState</a>.
applyUpdates :: [GStateUpdate] -> GState -> Either GStateUpdateError GState

-- | Retrive all contracts stored in GState
extractAllContracts :: GState -> TcOriginatedContracts
instance GHC.Show.Show Michelson.Runtime.GState.GStateUpdateError
instance GHC.Show.Show Michelson.Runtime.GState.GStateUpdate
instance GHC.Show.Show Michelson.Runtime.GState.GStateParseError
instance Formatting.Buildable.Buildable Michelson.Runtime.GState.GStateUpdateError
instance Formatting.Buildable.Buildable Michelson.Runtime.GState.GStateUpdate
instance GHC.Exception.Type.Exception Michelson.Runtime.GState.GStateParseError
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Runtime.GState.GState
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Runtime.GState.GState
instance GHC.Show.Show Michelson.Runtime.GState.GState
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Runtime.GState.AddressState
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Runtime.GState.AddressState
instance GHC.Generics.Generic Michelson.Runtime.GState.AddressState
instance GHC.Show.Show Michelson.Runtime.GState.AddressState
instance GHC.Show.Show Michelson.Runtime.GState.ContractState
instance Formatting.Buildable.Buildable Michelson.Runtime.GState.AddressState
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Runtime.GState.ContractState
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Runtime.GState.ContractState
instance Formatting.Buildable.Buildable Michelson.Runtime.GState.ContractState

module Michelson.Printer

-- | Generalize converting a type into a Text.PrettyPrint.Leijen.Text.Doc.
--   Used to pretty print Michelson code and define Fmt.Buildable
--   instances.
class RenderDoc a
renderDoc :: RenderDoc a => a -> Doc

-- | Whether a value can be represented in Michelson code. Normally either
--   all values of some type are renderable or not renderable. However, in
--   case of instructions we have extra instructions which should not be
--   rendered. Note: it's not suficcient to just return <a>mempty</a> for
--   such instructions, because sometimes we want to print lists of
--   instructions and we need to ignore them complete (to avoid putting
--   redundant separators).
isRenderable :: RenderDoc a => a -> Bool

-- | Convert <a>Doc</a> to <a>Text</a> with a line width of 80.
printDoc :: Bool -> Doc -> Text

-- | Convert an untyped contract into a textual representation which will
--   be accepted by the OCaml reference client.
printUntypedContract :: RenderDoc op => Bool -> Contract' op -> Text

-- | Convert a typed contract into a textual representation which will be
--   accepted by the OCaml reference client.
printTypedContract :: (SingI p, SingI s) => Bool -> Contract p s -> Text
printTypedFullContract :: (SingI p, SingI s) => Bool -> FullContract p s -> Text
printSomeContract :: Bool -> SomeContract -> Text
printTypedValue :: (SingI t, HasNoOp t) => Bool -> Value t -> Text

module Michelson.Macro
data CadrStruct
A :: CadrStruct
D :: CadrStruct
data PairStruct
F :: (VarAnn, FieldAnn) -> PairStruct
P :: PairStruct -> PairStruct -> PairStruct

-- | Built-in Michelson Macros defined by the specification
data Macro
CASE :: NonEmpty [ParsedOp] -> Macro
TAG :: Natural -> NonEmpty Type -> Macro
ACCESS :: Natural -> Positive -> Macro
SET :: Natural -> Positive -> Macro
CONSTRUCT :: NonEmpty [ParsedOp] -> Macro
VIEW :: [ParsedOp] -> Macro
VOID :: [ParsedOp] -> Macro
CMP :: ParsedInstr -> VarAnn -> Macro
IFX :: ParsedInstr -> [ParsedOp] -> [ParsedOp] -> Macro
IFCMP :: ParsedInstr -> VarAnn -> [ParsedOp] -> [ParsedOp] -> Macro
FAIL :: Macro
PAPAIR :: PairStruct -> TypeAnn -> VarAnn -> Macro
UNPAIR :: PairStruct -> Macro
CADR :: [CadrStruct] -> VarAnn -> FieldAnn -> Macro
SET_CADR :: [CadrStruct] -> VarAnn -> FieldAnn -> Macro
MAP_CADR :: [CadrStruct] -> VarAnn -> FieldAnn -> [ParsedOp] -> Macro
DIIP :: Integer -> [ParsedOp] -> Macro
DUUP :: Integer -> VarAnn -> Macro
ASSERT :: Macro
ASSERTX :: ParsedInstr -> Macro
ASSERT_CMP :: ParsedInstr -> Macro
ASSERT_NONE :: Macro
ASSERT_SOME :: Macro
ASSERT_LEFT :: Macro
ASSERT_RIGHT :: Macro
IF_SOME :: [ParsedOp] -> [ParsedOp] -> Macro
IF_RIGHT :: [ParsedOp] -> [ParsedOp] -> Macro

-- | A programmer-defined macro
data LetMacro
LetMacro :: Text -> StackFn -> [ParsedOp] -> LetMacro
[lmName] :: LetMacro -> Text
[lmSig] :: LetMacro -> StackFn
[lmExpr] :: LetMacro -> [ParsedOp]
type ParsedValue = Value' ParsedOp
type ParsedInstr = InstrAbstract ParsedOp

-- | Unexpanded instructions produced directly by the <tt>ops</tt> parser,
--   which contains primitive Michelson Instructions, inline-able macros
--   and sequences
data ParsedOp

-- | Primitive Michelson instruction
Prim :: ParsedInstr -> SrcPos -> ParsedOp

-- | Built-in Michelson macro defined by the specification
Mac :: Macro -> SrcPos -> ParsedOp

-- | User-defined macro with instructions to be inlined
LMac :: LetMacro -> SrcPos -> ParsedOp

-- | A sequence of instructions
Seq :: [ParsedOp] -> SrcPos -> ParsedOp
type ParsedUTestAssert = TestAssert ParsedOp
type ParsedUExtInstr = ExtInstrAbstract ParsedOp

-- | Expand all macros in parsed contract.
expandContract :: Contract' ParsedOp -> Contract
expandValue :: ParsedValue -> Value
mapLeaves :: [(VarAnn, FieldAnn)] -> PairStruct -> PairStruct
expand :: LetCallStack -> ParsedOp -> ExpandedOp
expandList :: [ParsedOp] -> [ExpandedOp]
expandMacro :: InstrCallStack -> Macro -> [ExpandedOp]
expandPapair :: InstrCallStack -> PairStruct -> TypeAnn -> VarAnn -> [ExpandedOp]
expandUnpapair :: InstrCallStack -> PairStruct -> [ExpandedOp]
expandCadr :: InstrCallStack -> [CadrStruct] -> VarAnn -> FieldAnn -> [ExpandedOp]
expandSetCadr :: InstrCallStack -> [CadrStruct] -> VarAnn -> FieldAnn -> [ExpandedOp]
expandMapCadr :: InstrCallStack -> [CadrStruct] -> VarAnn -> FieldAnn -> [ParsedOp] -> [ExpandedOp]
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Macro.Macro
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Macro.Macro
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Macro.CadrStruct
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Macro.CadrStruct
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Macro.PairStruct
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Macro.PairStruct
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Macro.LetMacro
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Macro.LetMacro
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Macro.ParsedOp
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Macro.ParsedOp
instance GHC.Generics.Generic Michelson.Macro.LetMacro
instance Data.Data.Data Michelson.Macro.LetMacro
instance GHC.Show.Show Michelson.Macro.LetMacro
instance GHC.Classes.Eq Michelson.Macro.LetMacro
instance GHC.Generics.Generic Michelson.Macro.ParsedOp
instance Data.Data.Data Michelson.Macro.ParsedOp
instance GHC.Show.Show Michelson.Macro.ParsedOp
instance GHC.Classes.Eq Michelson.Macro.ParsedOp
instance GHC.Generics.Generic Michelson.Macro.Macro
instance Data.Data.Data Michelson.Macro.Macro
instance GHC.Show.Show Michelson.Macro.Macro
instance GHC.Classes.Eq Michelson.Macro.Macro
instance GHC.Generics.Generic Michelson.Macro.CadrStruct
instance Data.Data.Data Michelson.Macro.CadrStruct
instance GHC.Show.Show Michelson.Macro.CadrStruct
instance GHC.Classes.Eq Michelson.Macro.CadrStruct
instance GHC.Generics.Generic Michelson.Macro.PairStruct
instance Data.Data.Data Michelson.Macro.PairStruct
instance GHC.Show.Show Michelson.Macro.PairStruct
instance GHC.Classes.Eq Michelson.Macro.PairStruct
instance Formatting.Buildable.Buildable Michelson.Macro.LetMacro
instance Michelson.Printer.Util.RenderDoc Michelson.Macro.ParsedOp
instance Formatting.Buildable.Buildable Michelson.Macro.ParsedOp
instance Formatting.Buildable.Buildable Michelson.Macro.Macro
instance Formatting.Buildable.Buildable Michelson.Macro.CadrStruct
instance Formatting.Buildable.Buildable Michelson.Macro.PairStruct

module Michelson.Let

-- | A programmer-defined type-synonym
data LetType
LetType :: Text -> Type -> LetType
[ltName] :: LetType -> Text
[ltSig] :: LetType -> Type

-- | A programmer-defined constant
data LetValue
LetValue :: Text -> Type -> Value' ParsedOp -> LetValue
[lvName] :: LetValue -> Text
[lvSig] :: LetValue -> Type
[lvVal] :: LetValue -> Value' ParsedOp
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Let.LetType
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Let.LetType
instance Data.Aeson.Types.ToJSON.ToJSON Michelson.Let.LetValue
instance Data.Aeson.Types.FromJSON.FromJSON Michelson.Let.LetValue
instance GHC.Show.Show Michelson.Let.LetType
instance GHC.Classes.Eq Michelson.Let.LetType
instance GHC.Show.Show Michelson.Let.LetValue
instance GHC.Classes.Eq Michelson.Let.LetValue


-- | Core parser types
module Michelson.Parser.Types
type Parser = ReaderT LetEnv (Parsec CustomParserException Text)

-- | The environment containing lets from the let-block
data LetEnv
LetEnv :: Map Text LetMacro -> Map Text LetValue -> Map Text LetType -> LetEnv
[letMacros] :: LetEnv -> Map Text LetMacro
[letValues] :: LetEnv -> Map Text LetValue
[letTypes] :: LetEnv -> Map Text LetType
noLetEnv :: LetEnv
instance GHC.Classes.Eq Michelson.Parser.Types.LetEnv
instance GHC.Show.Show Michelson.Parser.Types.LetEnv
instance Data.Default.Class.Default a => Data.Default.Class.Default (Michelson.Parser.Types.Parser a)

module Michelson.Parser.Lexer
lexeme :: Parser a -> Parser a
mSpace :: Parser ()
symbol :: Tokens Text -> Parser ()
symbol' :: Text -> Parser ()
string' :: (MonadParsec e s f, Tokens s ~ Text) => Text -> f Text
parens :: Parser a -> Parser a
braces :: Parser a -> Parser a
brackets :: Parser a -> Parser a
brackets' :: Parser a -> Parser a
semicolon :: Parser ()
comma :: Parser ()
varID :: Parser Var

module Michelson.Parser.Helpers

-- | Make a parser from a string
mkParser :: (a -> Text) -> a -> Parser a
sepEndBy1 :: MonadPlus m => m a -> m sep -> m (NonEmpty a)

-- | <tt>endBy2 p sep</tt> parses two or more occurrences of <tt>p</tt>,
--   separated by <tt>sep</tt>.
sepBy2 :: MonadPlus m => m a -> m sep -> m (NonEmpty a)

-- | Apply given parser and return default value if it fails.
parseDef :: Default a => Parser a -> Parser a

-- | Parse a positive number.
positive :: Parser Positive


-- | Parsing of untyped Michelson values.
module Michelson.Parser.Value

-- | Parse untyped <a>ParsedValue</a>. Take instruction parser as argument
--   to avoid cyclic dependencies between modules, hence ' in its name.
value' :: Parser ParsedOp -> Parser ParsedValue
mkLetVal :: Map Text LetValue -> Parser LetValue
stringLiteral :: Parser ParsedValue
bytesLiteral :: Parser (Value' op)
intLiteral :: Parser (Value' op)

module Michelson.Parser.Annotations
noteV :: Parser VarAnn
noteF :: Parser FieldAnn
noteFDef :: Parser FieldAnn
noteTDef :: Parser TypeAnn
noteVDef :: Parser VarAnn
notesTVF :: Parser (TypeAnn, VarAnn, FieldAnn)
notesTVF2 :: Parser (TypeAnn, VarAnn, (FieldAnn, FieldAnn))
notesTV :: Parser (TypeAnn, VarAnn)
notesVF :: Parser (VarAnn, FieldAnn)
fieldType :: Default a => Parser a -> Parser (a, TypeAnn)
permute2Def :: (Default a, Default b, Monad f, Alternative f) => f a -> f b -> f (a, b)
permute3Def :: (Default a, Default b, Default c, Monad f, Alternative f) => f a -> f b -> f c -> f (a, b, c)


-- | Parsing of Michelson types.
module Michelson.Parser.Type

-- | Parse untyped Michelson <a>Type</a> (i. e. one with annotations).
type_ :: Parser Type

-- | Parse only explicit <a>Type</a>, <a>Parameter</a> and <a>Storage</a>
--   are prohibited
explicitType :: Parser Type
comparable :: Parser Comparable


-- | Parsing logic for extra instructions (Morley extensions)
module Michelson.Parser.Ext
extInstr :: Parser [ParsedOp] -> Parser ParsedUExtInstr
stackType :: Parser StackTypePattern
printComment :: Parser PrintComment


-- | Parsing of Michelson instructions.
module Michelson.Parser.Instr

-- | Parser for primitive Michelson instruction (no macros and extensions).
primInstr :: Parser (Contract' ParsedOp) -> Parser ParsedOp -> Parser ParsedInstr

-- | Parse a sequence of instructions.
ops' :: Parser ParsedOp -> Parser [ParsedOp]
mapOp :: Parser ParsedOp -> Parser ParsedInstr
pairOp :: Parser ParsedInstr
cmpOp :: Parser ParsedInstr


-- | Parsing of built-in Michelson macros.
module Michelson.Parser.Macro
macro :: Parser ParsedOp -> Parser Macro
pairMac :: Parser Macro
ifCmpMac :: Parser ParsedOp -> Parser Macro
mapCadrMac :: Parser ParsedOp -> Parser Macro


-- | Parsing of let blocks
module Michelson.Parser.Let

-- | let block parser
letBlock :: Parser ParsedOp -> Parser LetEnv
mkLetMac :: Map Text LetMacro -> Parser LetMacro
letType :: Parser LetType

module Michelson.Parser
type Parser = ReaderT LetEnv (Parsec CustomParserException Text)

-- | Michelson contract with let definitions
program :: Parsec CustomParserException Text (Contract' ParsedOp)
value :: Parser ParsedValue
data CustomParserException
UnknownTypeException :: CustomParserException
StringLiteralException :: StringLiteralParserException -> CustomParserException
OddNumberBytesException :: CustomParserException
ProhibitedLetType :: Text -> CustomParserException
WrongTagArgs :: Natural -> Positive -> CustomParserException
WrongAccessArgs :: Natural -> Positive -> CustomParserException
WrongSetArgs :: Natural -> Positive -> CustomParserException

-- | A non-empty collection of <a>ParseError</a>s equipped with
--   <a>PosState</a> that allows to pretty-print the errors efficiently and
--   correctly.
data ParseErrorBundle s e
data ParserException
ParserException :: ParseErrorBundle Text CustomParserException -> ParserException
data StringLiteralParserException
InvalidEscapeSequence :: Char -> StringLiteralParserException
InvalidChar :: Char -> StringLiteralParserException

-- | Parse with empty environment
parseNoEnv :: Parser a -> String -> Text -> Either (ParseErrorBundle Text CustomParserException) a

-- | Parse untyped value from text which comes from something that is not a
--   file (which is often the case). So we assume it does not need any
--   parsing environment.
parseValue :: Text -> Either ParserException ParsedValue

-- | Like <a>parseValue</a>, but also expands macros.
parseExpandValue :: Text -> Either ParserException Value

-- | Parses code block after "code" keyword of a contract.
--   
--   This function is part of the module API, its semantics should not
--   change.
codeEntry :: Parser [ParsedOp]

-- | Parse untyped Michelson <a>Type</a> (i. e. one with annotations).
type_ :: Parser Type

-- | Parse only explicit <a>Type</a>, <a>Parameter</a> and <a>Storage</a>
--   are prohibited
explicitType :: Parser Type
letType :: Parser LetType
stringLiteral :: Parser ParsedValue
bytesLiteral :: Parser (Value' op)
intLiteral :: Parser (Value' op)
printComment :: Parser PrintComment


-- | Apply some transformations to Michelson code.
module Michelson.Preprocess

-- | Transform all strings in a typed instructions using given function.
--   The first argument specifies whether we should go into arguments that
--   contain instructions.
transformStrings :: Bool -> (MText -> MText) -> Instr inp out -> Instr inp out


-- | Module, carrying logic of <tt>UNPACK</tt> instruction.
--   
--   This is nearly symmetric to adjacent Pack.hs module.
--   
--   When implementing this the following sources were used:
--   
--   <ul>
--   <li><a>https://pastebin.com/8gfXaRvp</a></li>
--   
--   <li><a>https://gitlab.com/tezos/tezos/blob/master/src/proto_alpha/lib_protocol/script_ir_translator.ml#L2501</a></li>
--   
--   <li><a>https://github.com/tezbridge/tezbridge-crypto/blob/master/src/PsddFKi3/codec.js#L513</a></li>
--   </ul>
module Michelson.Interpret.Unpack

-- | Any decoding error.
newtype UnpackError
UnpackError :: Text -> UnpackError
[unUnpackError] :: UnpackError -> Text

-- | Deserialize bytes into the given value. Suitable for <tt>UNPACK</tt>
--   operation only.
unpackValue :: (SingI t, HasNoOp t, HasNoBigMap t) => UnpackEnv -> LByteString -> Either UnpackError (Value t)

-- | Like <a>unpackValue</a>, for strict byte array.
unpackValue' :: (SingI t, HasNoOp t, HasNoBigMap t) => UnpackEnv -> ByteString -> Either UnpackError (Value t)
data UnpackEnv
UnpackEnv :: TcOriginatedContracts -> UnpackEnv
[ueContracts] :: UnpackEnv -> TcOriginatedContracts

-- | <a>UnpackEnv</a> suitable for simple cases. Mostly for testing
--   purposes.
dummyUnpackEnv :: UnpackEnv
instance GHC.Classes.Eq Michelson.Interpret.Unpack.UnpackError
instance GHC.Show.Show Michelson.Interpret.Unpack.UnpackError
instance Formatting.Buildable.Buildable Michelson.Interpret.Unpack.UnpackError


-- | Module, carrying logic of <tt>PACK</tt> instruction.
--   
--   This is nearly symmetric to adjacent Unpack.hs module.
module Michelson.Interpret.Pack

-- | Serialize a value given to <tt>PACK</tt> instruction.
packValue :: (SingI t, HasNoOp t, HasNoBigMap t) => Value t -> LByteString

-- | Same as <a>packValue</a>, for strict bytestring.
packValue' :: (SingI t, HasNoOp t, HasNoBigMap t) => Value t -> ByteString


-- | Module, containing function to interpret Michelson instructions
--   against given context and input stack.
module Michelson.Interpret

-- | Environment for contract execution.
data ContractEnv
ContractEnv :: !Timestamp -> !RemainingSteps -> !Mutez -> TcOriginatedContracts -> !Address -> !Address -> !Address -> !Mutez -> ContractEnv

-- | Timestamp returned by the <a>NOW</a> instruction.
[ceNow] :: ContractEnv -> !Timestamp

-- | Number of steps after which execution unconditionally terminates.
[ceMaxSteps] :: ContractEnv -> !RemainingSteps

-- | Current amount of mutez of the current contract.
[ceBalance] :: ContractEnv -> !Mutez

-- | Mapping from existing contracts' addresses to their executable
--   representation.
[ceContracts] :: ContractEnv -> TcOriginatedContracts

-- | Address of the interpreted contract.
[ceSelf] :: ContractEnv -> !Address

-- | The contract that initiated the current transaction.
[ceSource] :: ContractEnv -> !Address

-- | The contract that initiated the current internal transaction.
[ceSender] :: ContractEnv -> !Address

-- | Amount of the current transaction.
[ceAmount] :: ContractEnv -> !Mutez
data InterpreterState
InterpreterState :: MorleyLogs -> RemainingSteps -> InterpreterState
[isMorleyLogs] :: InterpreterState -> MorleyLogs
[isRemainingSteps] :: InterpreterState -> RemainingSteps

-- | Represents `[FAILED]` state of a Michelson program. Contains value
--   that was on top of the stack when <a>FAILWITH</a> was called.
data MichelsonFailed
[MichelsonFailedWith] :: (Typeable t, SingI t) => Value t -> MichelsonFailed
[MichelsonArithError] :: (Typeable n, Typeable m) => ArithError (CValue n) (CValue m) -> MichelsonFailed
[MichelsonGasExhaustion] :: MichelsonFailed
[MichelsonFailedTestAssert] :: Text -> MichelsonFailed
newtype RemainingSteps
RemainingSteps :: Word64 -> RemainingSteps
data SomeItStack
[SomeItStack] :: ExtInstr inp -> Rec Value inp -> SomeItStack
type EvalOp a = ExceptT MichelsonFailed (ReaderT ContractEnv (State InterpreterState)) a

-- | Morley interpreter state
newtype MorleyLogs
MorleyLogs :: [Text] -> MorleyLogs
[unMorleyLogs] :: MorleyLogs -> [Text]
noMorleyLogs :: MorleyLogs
interpret :: Contract cp st -> Value cp -> Value st -> ContractEnv -> ContractReturn st

-- | Emulate multiple calls of a contract.
interpretRepeated :: Contract cp st -> [Value cp] -> Value st -> ContractEnv -> ContractReturn st

-- | Interpret an instruction in vacuum, putting no extra contraints on its
--   execution.
--   
--   Mostly for testing purposes.
interpretInstr :: ContractEnv -> Instr inp out -> Rec Value inp -> Either MichelsonFailed (Rec Value out)
type ContractReturn st = (Either MichelsonFailed ([Operation], Value st), InterpreterState)

-- | Interpret a contract without performing any side effects using typed
--   representation of contract, parameter and storage.
interpretSome :: SomeContract -> SomeValue -> SomeValue -> ContractEnv -> Either InterpretError InterpretResult

-- | Interpret a contract without performing any side effects. This
--   function uses untyped representation of contract, parameter and
--   storage. Mostly used for testing.
interpretUntyped :: Contract -> Value -> Value -> ContractEnv -> Either InterpretError InterpretResult
data InterpretError
RuntimeFailure :: (MichelsonFailed, MorleyLogs) -> InterpretError
IllTypedContract :: TCError -> InterpretError
IllTypedParam :: TCError -> InterpretError
IllTypedStorage :: TCError -> InterpretError
UnexpectedParamType :: TCTypeError -> InterpretError
UnexpectedStorageType :: TCTypeError -> InterpretError
data InterpretResult
[InterpretResult] :: (Typeable st, SingI st, HasNoOp st) => {iurOps :: [Operation], iurNewStorage :: Value st, iurNewState :: InterpreterState} -> InterpretResult

-- | Function to change amount of remaining steps stored in State monad
runInstr :: Instr inp out -> Rec Value inp -> EvalOp (Rec Value out)
runInstrNoGas :: forall a b. Instr a b -> Rec Value a -> EvalOp (Rec Value b)

-- | Unpacks given raw data into a typed value.
runUnpack :: forall t. (SingI t, HasNoOp t, HasNoBigMap t) => TcOriginatedContracts -> ByteString -> Either UnpackError (Value t)
instance GHC.Show.Show Michelson.Interpret.InterpreterState
instance GHC.Num.Num Michelson.Interpret.RemainingSteps
instance Formatting.Buildable.Buildable Michelson.Interpret.RemainingSteps
instance GHC.Classes.Ord Michelson.Interpret.RemainingSteps
instance GHC.Classes.Eq Michelson.Interpret.RemainingSteps
instance GHC.Show.Show Michelson.Interpret.RemainingSteps
instance GHC.Generics.Generic Michelson.Interpret.InterpretError
instance Formatting.Buildable.Buildable Michelson.Interpret.MorleyLogs
instance Data.Default.Class.Default Michelson.Interpret.MorleyLogs
instance GHC.Show.Show Michelson.Interpret.MorleyLogs
instance GHC.Classes.Eq Michelson.Interpret.MorleyLogs
instance GHC.Show.Show Michelson.Interpret.MichelsonFailed
instance GHC.Show.Show Michelson.Interpret.InterpretError
instance GHC.Show.Show Michelson.Interpret.InterpretResult
instance Formatting.Buildable.Buildable Michelson.Interpret.InterpretError
instance GHC.Classes.Eq Michelson.Interpret.MichelsonFailed
instance Formatting.Buildable.Buildable Michelson.Interpret.MichelsonFailed


-- | Utility functions for unit testing.
module Michelson.Test.Unit
type ContractReturn st = (Either MichelsonFailed ([Operation], Value st), InterpreterState)

-- | Type for contract execution validation.
--   
--   It's a function which is supplied with contract execution output
--   (failure or new storage with operation list).
--   
--   Function returns a property which type is designated by type variable
--   <tt>prop</tt> and might be <a>Property</a> or <a>Expectation</a> or
--   anything else relevant.
type ContractPropValidator st prop = ContractReturn st -> prop

-- | Contract's property tester against given input. Takes contract
--   environment, initial storage and parameter, interprets contract on
--   this input and invokes validation function.
contractProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st) => Contract cp st -> ContractPropValidator st prop -> ContractEnv -> param -> storage -> prop

-- | Version of <a>contractProp</a> which takes <tt>Val</tt> as arguments
--   instead of regular Haskell values.
contractPropVal :: Contract cp st -> ContractPropValidator st prop -> ContractEnv -> Value cp -> Value st -> prop
contractRepeatedProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st) => Contract cp st -> ContractPropValidator st prop -> ContractEnv -> [param] -> storage -> prop
contractRepeatedPropVal :: Contract cp st -> ContractPropValidator st prop -> ContractEnv -> [Value cp] -> Value st -> prop


-- | Dummy data to be used in tests where it's not essential.
module Michelson.Test.Dummy

-- | Dummy timestamp, can be used to specify current <a>NOW</a> value or
--   maybe something else.
dummyNow :: Timestamp

-- | Dummy value for maximal number of steps a contract can make.
--   Intentionally quite large, because most likely if you use dummy value
--   you don't want the interpreter to stop due to gas exhaustion. On the
--   other hand, it probably still prevents the interpreter from working
--   for eternity.
dummyMaxSteps :: RemainingSteps

-- | Dummy <a>ContractEnv</a> with some reasonable hardcoded values. You
--   can override values you are interested in using record update syntax.
dummyContractEnv :: ContractEnv

-- | <a>OriginationOperation</a> with most data hardcoded to some
--   reasonable values. Contract and initial values must be passed
--   explicitly, because otherwise it hardly makes sense.
dummyOrigination :: Value -> Contract -> OriginationOperation


-- | Interpreter and typechecker of a contract in Morley language.
module Michelson.Runtime

-- | Originate a contract. Returns the address of the originated contract.
originateContract :: FilePath -> OriginationOperation -> ("verbose" :! Bool) -> IO Address

-- | Run a contract. The contract is originated first (if it's not already)
--   and then we pretend that we send a transaction to it.
runContract :: Maybe Timestamp -> Word64 -> Mutez -> FilePath -> Value -> Contract -> TxData -> ("verbose" :! Bool) -> ("dryRun" :! Bool) -> IO ()

-- | Send a transaction to given address with given parameters.
transfer :: Maybe Timestamp -> Word64 -> FilePath -> Address -> TxData -> ("verbose" :! Bool) -> ("dryRun" :? Bool) -> IO ()

-- | Parse a contract from <a>Text</a>.
parseContract :: Maybe FilePath -> Text -> Either ParserException (Contract' ParsedOp)

-- | Parse a contract from <a>Text</a> and expand macros.
parseExpandContract :: Maybe FilePath -> Text -> Either ParserException Contract

-- | Read and parse a contract from give path or <a>stdin</a> (if the
--   argument is <a>Nothing</a>). The contract is not expanded.
readAndParseContract :: Maybe FilePath -> IO (Contract' ParsedOp)

-- | Read a contract using <a>readAndParseContract</a>, expand and flatten.
--   The contract is not type checked.
prepareContract :: Maybe FilePath -> IO Contract
typeCheckWithDb :: FilePath -> Contract -> IO (Either TCError SomeContract)

-- | State of a contract with code.
data ContractState
ContractState :: !Mutez -> !Value -> !Contract -> !Maybe SomeContract -> !Maybe SomeValue -> ContractState

-- | Amount of mutez owned by this contract.
[csBalance] :: ContractState -> !Mutez

-- | Storage value associated with this contract.
[csStorage] :: ContractState -> !Value

-- | Contract itself (untyped).
[csContract] :: ContractState -> !Contract
[csTypedContract] :: ContractState -> !Maybe SomeContract

-- | We keep typed representation of contract code and storage in form,
--   that hides their actual type in order to simplify the rest of the code
--   (e.g. avoid type parameters for <a>ContractState</a> and so on). They
--   are made optional in order to perform safe parsing from JSON (we
--   simply return <a>Nothing</a> in this parser and use
--   <a>getTypedStorage</a> or <a>getTypedContract</a> that optionally
--   typecheck storage or contract code).
[csTypedStorage] :: ContractState -> !Maybe SomeValue

-- | State of an arbitrary address.
data AddressState

-- | For contracts without code we store only its balance.
ASSimple :: !Mutez -> AddressState

-- | For contracts with code we store more state represented by
--   <a>ContractState</a>.
ASContract :: !ContractState -> AddressState

-- | Data associated with a particular transaction.
data TxData
TxData :: !Address -> !Value -> !Mutez -> TxData
[tdSenderAddress] :: TxData -> !Address
[tdParameter] :: TxData -> !Value
[tdAmount] :: TxData -> !Mutez

-- | Operations executed by interpreter. In our model one Michelson's
--   operation (<tt>operation</tt> type in Michelson) corresponds to 0 or 1
--   interpreter operation.
--   
--   Note: <a>Address</a> is not part of <a>TxData</a>, because
--   <a>TxData</a> is supposed to be provided by the user, while
--   <a>Address</a> can be computed by our code.
data InterpreterOp

-- | Originate a contract.
OriginateOp :: !OriginationOperation -> InterpreterOp

-- | Send a transaction to given address which is assumed to be the address
--   of an originated contract.
TransferOp :: Address -> TxData -> InterpreterOp

-- | Result of a single execution of interpreter.
data InterpreterRes
InterpreterRes :: !GState -> [InterpreterOp] -> ![GStateUpdate] -> [(Address, InterpretResult)] -> !Maybe Address -> !RemainingSteps -> InterpreterRes

-- | New <a>GState</a>.
[_irGState] :: InterpreterRes -> !GState

-- | List of operations to be added to the operations queue.
[_irOperations] :: InterpreterRes -> [InterpreterOp]

-- | Updates applied to <a>GState</a>.
[_irUpdates] :: InterpreterRes -> ![GStateUpdate]

-- | During execution a contract can print logs and in the end it returns a
--   pair. All logs and returned values are kept until all called contracts
--   are executed. In the end they are printed.
[_irInterpretResults] :: InterpreterRes -> [(Address, InterpretResult)]

-- | As soon as transfer operation is encountered, this address is set to
--   its input.
[_irSourceAddress] :: InterpreterRes -> !Maybe Address

-- | Now much gas all remaining executions can consume.
[_irRemainingSteps] :: InterpreterRes -> !RemainingSteps

-- | Errors that can happen during contract interpreting. Type parameter
--   <tt>a</tt> determines how contracts will be represented in these
--   errors, e.g. <tt>Address</tt>
data InterpreterError' a

-- | The interpreted contract hasn't been originated.
IEUnknownContract :: !a -> InterpreterError' a

-- | Interpretation of Michelson contract failed.
IEInterpreterFailed :: !a -> !InterpretError -> InterpreterError' a

-- | A contract is already originated.
IEAlreadyOriginated :: !a -> !ContractState -> InterpreterError' a

-- | Sender address is unknown.
IEUnknownSender :: !a -> InterpreterError' a

-- | Manager address is unknown.
IEUnknownManager :: !a -> InterpreterError' a

-- | Sender doesn't have enough funds.
IENotEnoughFunds :: !a -> !Mutez -> InterpreterError' a

-- | Failed to apply updates to GState.
IEFailedToApplyUpdates :: !GStateUpdateError -> InterpreterError' a

-- | A contract is ill-typed.
IEIllTypedContract :: !TCError -> InterpreterError' a

-- | Contract storage is ill-typed
IEIllTypedStorage :: !TCError -> InterpreterError' a

-- | Contract parameter is ill-typed
IEIllTypedParameter :: !TCError -> InterpreterError' a
type InterpreterError = InterpreterError' Address

-- | Implementation of interpreter outside <a>IO</a>. It reads operations,
--   interprets them one by one and updates state accordingly. Each
--   operation from the passed list is fully interpreted before the next
--   one is considered.
interpreterPure :: Timestamp -> RemainingSteps -> GState -> [InterpreterOp] -> Either InterpreterError InterpreterRes
irInterpretResults :: Lens' InterpreterRes [(Address, InterpretResult)]
irUpdates :: Lens' InterpreterRes [GStateUpdate]
instance GHC.Show.Show a => GHC.Show.Show (Michelson.Runtime.InterpreterError' a)
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (Michelson.Runtime.InterpreterError' a)
instance (Data.Typeable.Internal.Typeable a, GHC.Show.Show a, Formatting.Buildable.Buildable a) => GHC.Exception.Type.Exception (Michelson.Runtime.InterpreterError' a)
instance GHC.Base.Semigroup Michelson.Runtime.InterpreterRes
instance GHC.Show.Show Michelson.Runtime.InterpreterRes
instance GHC.Show.Show Michelson.Runtime.InterpreterOp


-- | Utilities for integrational testing. Example tests can be found in the
--   'morley-test' test suite.
module Michelson.Test.Integrational

-- | Data associated with a particular transaction.
data TxData
TxData :: !Address -> !Value -> !Mutez -> TxData
[tdSenderAddress] :: TxData -> !Address
[tdParameter] :: TxData -> !Value
[tdAmount] :: TxData -> !Mutez

-- | One of genesis addresses.
genesisAddress :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress1 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress2 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress3 :: Address
genesisAddress4 :: Address
genesisAddress5 :: Address
genesisAddress6 :: Address

-- | Validator for integrational testing. If an error is expected, it
--   should be <a>Left</a> with validator for errors. Otherwise it should
--   check final global state and its updates.
type IntegrationalValidator = Either (InterpreterError -> Bool) SuccessValidator

-- | Validator for integrational testing that expects successful execution.
type SuccessValidator = (InternalState -> GState -> [GStateUpdate] -> Either ValidationError ())

-- | A monad inside which integrational tests can be described using
--   do-notation.
type IntegrationalScenarioM = StateT InternalState (Except ScenarioError)
type IntegrationalScenario = IntegrationalScenarioM Validated
data ValidationError
UnexpectedInterpreterError :: IntegrationalInterpreterError -> ValidationError
UnexpectedTypeCheckError :: TCError -> ValidationError
ExpectingInterpreterToFail :: ValidationError
IncorrectUpdates :: ValidationError -> [GStateUpdate] -> ValidationError
IncorrectStorageUpdate :: AddressName -> Text -> ValidationError
InvalidStorage :: AddressName -> ExpectedStorage -> Text -> ValidationError
InvalidBalance :: AddressName -> ExpectedBalance -> Text -> ValidationError
UnexpectedUpdates :: NonEmpty GStateUpdate -> ValidationError
CustomError :: Text -> ValidationError

-- | Integrational test that executes given operations and validates them
--   using given validator. It can fail using <a>Expectation</a>
--   capability. It starts with <a>initGState</a> and some reasonable dummy
--   values for gas limit and current timestamp. You can update blockchain
--   state by performing some operations.
integrationalTestExpectation :: IntegrationalScenario -> Expectation

-- | Integrational test similar to <a>integrationalTestExpectation</a>. It
--   can fail using <a>Property</a> capability. It can be used with
--   QuickCheck's <tt>forAll</tt> to make a property-based test with
--   arbitrary data.
integrationalTestProperty :: IntegrationalScenario -> Property

-- | Originate a contract with given initial storage and balance. Its
--   address is returned.
originate :: Contract -> Text -> Value -> Mutez -> IntegrationalScenarioM Address

-- | Transfer tokens to given address.
transfer :: TxData -> Address -> IntegrationalScenarioM ()

-- | Execute all operations that were added to the scenarion since last
--   <a>validate</a> call. If validator fails, the execution will be
--   aborted.
validate :: IntegrationalValidator -> IntegrationalScenario

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given gas limit.
setMaxSteps :: RemainingSteps -> IntegrationalScenarioM ()

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given timestamp as the current one.
setNow :: Timestamp -> IntegrationalScenarioM ()

-- | Pretend that given address initiates all the transfers within the code
--   block (i.e. <tt>SENDER</tt> instruction will return this address).
withSender :: Address -> IntegrationalScenarioM a -> IntegrationalScenarioM a

-- | Execute multiple testing scenarios independently, basing them on
--   scenario built till this point.
--   
--   The following property holds for this function:
--   
--   <tt> pre &gt;&gt; branchout [a, b, c] = branchout [pre &gt;&gt; a, pre
--   &gt;&gt; b, pre &gt;&gt; c] </tt>.
--   
--   In case of property failure in one of the branches no following branch
--   is executed.
--   
--   Providing empty list of scenarios to this function causes error; we do
--   not require <a>NonEmpty</a> here though for convenience.
branchout :: HasCallStack => [(Text, IntegrationalScenario)] -> IntegrationalScenario

-- | Make a tuple with name without extra syntactic noise.
(?-) :: Text -> a -> (Text, a)
infixr 0 ?-

-- | Compose two success validators.
--   
--   For example:
--   
--   expectBalance bal addr <a>composeValidators</a>
--   expectStorageUpdateConst addr2 ValueUnit
composeValidators :: SuccessValidator -> SuccessValidator -> SuccessValidator

-- | Compose a list of success validators.
composeValidatorsList :: [SuccessValidator] -> SuccessValidator

-- | <a>SuccessValidator</a> that always passes.
expectAnySuccess :: SuccessValidator

-- | Check that there were no updates.
expectNoUpdates :: SuccessValidator

-- | Check that there were no storage updates.
expectNoStorageUpdates :: SuccessValidator

-- | Check that storage value is updated for given address. Takes a
--   predicate that is used to check the value.
--   
--   It works even if updates are not filtered (i. e. a value can be
--   updated more than once).
expectStorageUpdate :: Address -> (Value -> Either ValidationError ()) -> SuccessValidator

-- | Like <a>expectStorageUpdate</a>, but expects a constant.
expectStorageUpdateConst :: Address -> Value -> SuccessValidator

-- | Check that eventually address has some particular balance.
expectBalance :: Address -> Mutez -> SuccessValidator

-- | Check that eventually address has some particular storage value.
expectStorageConst :: Address -> Value -> SuccessValidator

-- | Check that interpreter failed due to gas exhaustion.
expectGasExhaustion :: InterpreterError -> Bool

-- | Expect that interpretation of contract with given address ended with
--   [FAILED].
expectMichelsonFailed :: (MichelsonFailed -> Bool) -> Address -> InterpreterError -> Bool
instance Formatting.Buildable.Buildable Michelson.Test.Integrational.ScenarioError
instance GHC.Show.Show Michelson.Test.Integrational.ValidationError
instance GHC.Show.Show Michelson.Test.Integrational.AddressName
instance GHC.Show.Show Michelson.Test.Integrational.ExpectedBalance
instance GHC.Show.Show Michelson.Test.Integrational.ExpectedStorage
instance Formatting.Buildable.Buildable Michelson.Test.Integrational.ValidationError
instance GHC.Exception.Type.Exception Michelson.Test.Integrational.ValidationError
instance Formatting.Buildable.Buildable Michelson.Test.Integrational.AddressName
instance Formatting.Buildable.Buildable Michelson.Test.Integrational.ScenarioBranchName


-- | Static analysis of Michelson code.
module Michelson.Analyzer
data AnalyzerRes
AnalyzerRes :: !HashMap MText Word -> !HashMap ByteString Word -> AnalyzerRes

-- | All string constants and number of their occurrences.
[arConstStrings] :: AnalyzerRes -> !HashMap MText Word

-- | All bytes constants and number of their occurrences.
[arConstBytes] :: AnalyzerRes -> !HashMap ByteString Word

-- | Statically analyze an instruction. Typed representation is used
--   because it's easier to analyze. It means that we can't analyze
--   ill-typed contracts, but hopefully it's not a serious limitation.
analyze :: Instr inp out -> AnalyzerRes
instance GHC.Classes.Eq Michelson.Analyzer.AnalyzerRes
instance GHC.Show.Show Michelson.Analyzer.AnalyzerRes
instance Formatting.Buildable.Buildable Michelson.Analyzer.AnalyzerRes
instance GHC.Base.Semigroup Michelson.Analyzer.AnalyzerRes
instance GHC.Base.Monoid Michelson.Analyzer.AnalyzerRes


-- | Re-exports typed Value, CValue, some core types, some helpers and
--   defines aliases for constructors of typed values.
module Lorentz.Value
type Value = Value' Instr

-- | Isomorphism between Michelson values and plain Haskell types.
--   
--   Default implementation of this typeclass converts ADTs to Michelson
--   "pair"s and "or"s.
class IsoValue a where {
    
    -- | Type function that converts a regular Haskell type into a <tt>T</tt>
    --   type.
    type family ToT a :: T;
    type ToT a = GValueType (Rep a);
}

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: IsoValue a => a -> Value (ToT a)

-- | Converts a Haskell structure into <tt>Value</tt> representation.
toVal :: (IsoValue a, Generic a, GIsoValue (Rep a), ToT a ~ GValueType (Rep a)) => a -> Value (ToT a)

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: IsoValue a => Value (ToT a) -> a

-- | Converts a <tt>Value</tt> into Haskell type.
fromVal :: (IsoValue a, Generic a, GIsoValue (Rep a), ToT a ~ GValueType (Rep a)) => Value (ToT a) -> a

-- | Isomorphism between Michelson primitive values and plain Haskell
--   types.
class IsoCValue a where {
    
    -- | Type function that converts a regular Haskell type into a comparable
    --   type (which has kind <tt>CT</tt>).
    type family ToCT a :: CT;
}

-- | Converts a single Haskell value into <tt>CVal</tt> representation.
toCVal :: IsoCValue a => a -> CValue (ToCT a)

-- | Converts a <tt>CVal</tt> value into a single Haskell value.
fromCVal :: IsoCValue a => CValue (ToCT a) -> a

-- | Representation of comparable value in Michelson language.
--   
--   By specification, we're allowed to compare only following types: int,
--   nat, string, bytes, mutez, bool, key_hash, timestamp, address.
--   
--   Only these values can be used as map keys or set elements.
data CValue t
[CvInt] :: Integer -> CValue  'CInt
[CvNat] :: Natural -> CValue  'CNat
[CvString] :: MText -> CValue  'CString
[CvBytes] :: ByteString -> CValue  'CBytes
[CvMutez] :: Mutez -> CValue  'CMutez
[CvBool] :: Bool -> CValue  'CBool
[CvKeyHash] :: KeyHash -> CValue  'CKeyHash
[CvTimestamp] :: Timestamp -> CValue  'CTimestamp
[CvAddress] :: Address -> CValue  'CAddress

-- | Invariant: <a>Jn#</a> and <a>Jp#</a> are used iff value doesn't fit in
--   <a>S#</a>
--   
--   Useful properties resulting from the invariants:
--   
--   <ul>
--   <li><pre>abs (<a>S#</a> _) &lt;= abs (<a>Jp#</a> _)</pre></li>
--   <li><pre>abs (<a>S#</a> _) &lt; abs (<a>Jn#</a> _)</pre></li>
--   </ul>
data Integer

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><tt>throw</tt>
--   (<tt>Underflow</tt> :: <tt>ArithException</tt>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | Michelson string value.
--   
--   This is basically a mere text with limits imposed by the language:
--   <a>http://tezos.gitlab.io/zeronet/whitedoc/michelson.html#constants</a>
--   Although, this document seems to be not fully correct, and thus we
--   applied constraints deduced empirically.
--   
--   You construct an item of this type using one of the following ways:
--   
--   <ul>
--   <li>With QuasyQuotes when need to create a string literal.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; [mt|Some text|]
--   MTextUnsafe { unMText = "Some text" }
--   </pre>
--   
--   <ul>
--   <li>With <a>mkMText</a> when constructing from a runtime text
--   value.</li>
--   <li>With <a>mkMTextUnsafe</a> or <a>MTextUnsafe</a> when absolutelly
--   sure that given string does not violate invariants.</li>
--   <li>With <a>mkMTextCut</a> when not sure about text contents and want
--   to make it compliant with Michelson constraints.</li>
--   </ul>
data MText
data Bool
False :: Bool
True :: Bool

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | Data type corresponding to address structure in Tezos.
data Address

-- | Mutez is a wrapper over integer data type. 1 mutez is 1 token (μTz).
data Mutez

-- | Time in the real world. Use the functions below to convert it to/from
--   Unix time in seconds.
data Timestamp

-- | b58check of a public key.
data KeyHash

-- | ED25519 public cryptographic key.
data PublicKey

-- | ED25519 cryptographic signature.
data Signature

-- | A set of values <tt>a</tt>.
data Set a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a
newtype BigMap k v
BigMap :: Map k v -> BigMap k v
[unBigMap] :: BigMap k v -> Map k v
type Operation = Operation' Instr

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <tt>error</tt>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a
type List = []

-- | Since <tt>Contract</tt> name is used to designate contract code, lets
--   call analogy of <a>TContract</a> type as follows.
newtype ContractAddr (cp :: Type)
ContractAddr :: Address -> ContractAddr
[unContractAddress] :: ContractAddr -> Address

-- | Safely create <a>Mutez</a>.
--   
--   This is recommended way to create <tt>Mutez</tt> from a numeric
--   literal; you can't construct all valid <tt>Mutez</tt> values using
--   this function but for small values it works neat.
--   
--   Warnings displayed when trying to construct invalid <a>Natural</a> or
--   <a>Word</a> literal are hardcoded for these types in GHC
--   implementation, so we can only exploit these existing rules.
toMutez :: Word32 -> Mutez

-- | QuasyQuoter for constructing Michelson strings.
--   
--   Validity of result will be checked at compile time. Note:
--   
--   <ul>
--   <li>slash must be escaped</li>
--   <li>newline character must appear as '\n'</li>
--   <li>use quotes as is</li>
--   <li>other special characters are not allowed.</li>
--   </ul>
mt :: QuasiQuoter
timestampFromSeconds :: Integer -> Timestamp
timestampFromUTCTime :: UTCTime -> Timestamp

-- | Quote a value of type <a>Timestamp</a> in
--   <tt>yyyy-mm-ddThh:mm:ss[.sss]Z</tt> format.
--   
--   <pre>
--   &gt;&gt;&gt; formatTimestamp [timestampQuote| 2019-02-21T16:54:12.2344523Z |]
--   "2019-02-21T16:54:12Z"
--   </pre>
--   
--   Inspired by 'time-quote' library.
timestampQuote :: QuasiQuoter

-- | A class for types with a default value.
class Default a

-- | The default value for this type.
def :: Default a => a


-- | Type families from <a>Arith</a> lifted to Haskell types.
module Lorentz.Arith

-- | Lifted <tt>AithOp</tt>.
class (ArithOp aop (ToCT n) (ToCT m), IsComparable n, IsComparable m, Typeable (ToCT n), Typeable (ToCT m), ToT (ArithResHs aop n m) ~  'Tc (ArithRes aop (ToCT n) (ToCT m))) => ArithOpHs (aop :: Type) (n :: Type) (m :: Type) where {
    type family ArithResHs aop n m :: Type;
}
class (Typeable (ToCT n), IsComparable n, CompareOp (ToCT n)) => CompareOpHs n

-- | Lifted <tt>UnaryAithOp</tt>.
class (UnaryArithOp aop (ToCT n), IsComparable n, Typeable (ToCT n), ToT (UnaryArithResHs aop n) ~  'Tc (UnaryArithRes aop (ToCT n))) => UnaryArithOpHs (aop :: Type) (n :: Type) where {
    type family UnaryArithResHs aop n :: Type;
}
instance (n Data.Type.Equality.~ m, Lorentz.Arith.CompareOpHs n) => Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Compare n m
instance Lorentz.Arith.CompareOpHs GHC.Types.Bool
instance Lorentz.Arith.CompareOpHs Tezos.Address.Address
instance Lorentz.Arith.CompareOpHs GHC.Natural.Natural
instance Lorentz.Arith.CompareOpHs GHC.Integer.Type.Integer
instance Lorentz.Arith.CompareOpHs Michelson.Text.MText
instance Lorentz.Arith.CompareOpHs Data.ByteString.Internal.ByteString
instance Lorentz.Arith.CompareOpHs Tezos.Core.Timestamp
instance Lorentz.Arith.CompareOpHs Tezos.Core.Mutez
instance Lorentz.Arith.CompareOpHs Tezos.Crypto.KeyHash
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Abs GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Neg GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Neg GHC.Natural.Natural
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Not GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Not GHC.Natural.Natural
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Not GHC.Types.Bool
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Eq' GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Neq GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Lt GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Gt GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Le GHC.Integer.Type.Integer
instance Lorentz.Arith.UnaryArithOpHs Michelson.Typed.Arith.Ge GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add Tezos.Core.Timestamp GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add GHC.Integer.Type.Integer Tezos.Core.Timestamp
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Add Tezos.Core.Mutez Tezos.Core.Mutez
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub Tezos.Core.Timestamp GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub Tezos.Core.Timestamp Tezos.Core.Timestamp
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Sub Tezos.Core.Mutez Tezos.Core.Mutez
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul GHC.Natural.Natural Tezos.Core.Mutez
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Mul Tezos.Core.Mutez GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Or GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Or GHC.Types.Bool GHC.Types.Bool
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.And GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.And GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.And GHC.Types.Bool GHC.Types.Bool
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Xor GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Xor GHC.Types.Bool GHC.Types.Bool
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Lsl GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Arith.ArithOpHs Michelson.Typed.Arith.Lsr GHC.Natural.Natural GHC.Natural.Natural


-- | Type families from <a>Polymorphic</a> lifted to Haskell types.
module Lorentz.Polymorphic

-- | Lifted <a>MemOpKey</a>.
class (MemOp (ToT c), ToT (MemOpKeyHs c) ~  'Tc (MemOpKey (ToT c))) => MemOpHs c where {
    type family MemOpKeyHs c :: Type;
}

-- | Lifted <a>MapOp</a>.
class (MapOp (ToT c), ToT (MapOpInpHs c) ~ MapOpInp (ToT c), ToT (MapOpResHs c ()) ~ MapOpRes (ToT c) (ToT ())) => MapOpHs c where {
    type family MapOpInpHs c :: Type;
    type family MapOpResHs c :: Type -> Type;
}

-- | Lifted <a>IterOp</a>.
class (IterOp (ToT c), ToT (IterOpElHs c) ~ IterOpEl (ToT c)) => IterOpHs c where {
    type family IterOpElHs c :: Type;
}

-- | Lifted <a>SizeOp</a>.
--   
--   This could be just a constraint alias, but to avoid <a>T</a> types
--   appearance in error messages we make a full type class with concrete
--   instances.
class SizeOp (ToT c) => SizeOpHs c

-- | Lifted <a>UpdOp</a>.
class (UpdOp (ToT c), ToT (UpdOpKeyHs c) ~  'Tc (UpdOpKey (ToT c)), ToT (UpdOpParamsHs c) ~ UpdOpParams (ToT c)) => UpdOpHs c where {
    type family UpdOpKeyHs c :: Type;
    type family UpdOpParamsHs c :: Type;
}

-- | Lifted <a>GetOp</a>.
class (GetOp (ToT c), ToT (GetOpKeyHs c) ~  'Tc (GetOpKey (ToT c)), ToT (GetOpValHs c) ~ GetOpVal (ToT c)) => GetOpHs c where {
    type family GetOpKeyHs c :: Type;
    type family GetOpValHs c :: Type;
}

-- | Lifted <a>ConcatOp</a>.
class ConcatOp (ToT c) => ConcatOpHs c

-- | Lifted <a>SliceOp</a>.
class SliceOp (ToT c) => SliceOpHs c

-- | Lifted <a>EDivOp</a>.
class (EDivOp (ToCT n) (ToCT m), IsComparable n, IsComparable m, ToT (EDivOpResHs n m) ~  'Tc (EDivOpRes (ToCT n) (ToCT m)), ToT (EModOpResHs n m) ~  'Tc (EModOpRes (ToCT n) (ToCT m))) => EDivOpHs n m where {
    type family EDivOpResHs n m :: Type;
    type family EModOpResHs n m :: Type;
}

-- | A useful property which holds for reasonable <a>MapOp</a> instances.
--   
--   It's a separate thing from <a>MapOpHs</a> because it mentions
--   <tt>b</tt> type parameter.
type family IsoMapOpRes c b
instance Lorentz.Polymorphic.EDivOpHs GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Lorentz.Polymorphic.EDivOpHs GHC.Integer.Type.Integer GHC.Natural.Natural
instance Lorentz.Polymorphic.EDivOpHs GHC.Natural.Natural GHC.Integer.Type.Integer
instance Lorentz.Polymorphic.EDivOpHs GHC.Natural.Natural GHC.Natural.Natural
instance Lorentz.Polymorphic.EDivOpHs Tezos.Core.Mutez Tezos.Core.Mutez
instance Lorentz.Polymorphic.EDivOpHs Tezos.Core.Mutez GHC.Natural.Natural
instance Lorentz.Polymorphic.SliceOpHs Michelson.Text.MText
instance Lorentz.Polymorphic.SliceOpHs Data.ByteString.Internal.ByteString
instance Lorentz.Polymorphic.ConcatOpHs Michelson.Text.MText
instance Lorentz.Polymorphic.ConcatOpHs Data.ByteString.Internal.ByteString
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.GetOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.GetOpHs (Michelson.Typed.Haskell.Value.BigMap k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.UpdOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.UpdOpHs (Michelson.Typed.Haskell.Value.BigMap k v)
instance Michelson.Typed.Haskell.Value.IsComparable a => Lorentz.Polymorphic.UpdOpHs (Data.Set.Internal.Set a)
instance Lorentz.Polymorphic.SizeOpHs Michelson.Text.MText
instance Lorentz.Polymorphic.SizeOpHs Data.ByteString.Internal.ByteString
instance Lorentz.Polymorphic.SizeOpHs (Data.Set.Internal.Set a)
instance Lorentz.Polymorphic.SizeOpHs [a]
instance Lorentz.Polymorphic.SizeOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.IterOpHs (Data.Map.Internal.Map k v)
instance Lorentz.Polymorphic.IterOpHs [e]
instance Michelson.Typed.Haskell.Value.IsComparable e => Lorentz.Polymorphic.IterOpHs (Data.Set.Internal.Set e)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.MapOpHs (Data.Map.Internal.Map k v)
instance Lorentz.Polymorphic.MapOpHs [e]
instance Michelson.Typed.Haskell.Value.IsComparable e => Lorentz.Polymorphic.MemOpHs (Data.Set.Internal.Set e)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.MemOpHs (Data.Map.Internal.Map k v)
instance Michelson.Typed.Haskell.Value.IsComparable k => Lorentz.Polymorphic.MemOpHs (Michelson.Typed.Haskell.Value.BigMap k v)


-- | <a>UStore</a> definition and common type-level stuff.
module Lorentz.UStore.Types

-- | Gathers multple fields and <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "store template" - a
--   datatype with one constructor and multiple fields, each containing an
--   object of type <a>UStoreField</a> or <a>|~&gt;</a> and corresponding
--   to single virtual field or <a>BigMap</a> respectively. It's also
--   possible to parameterize it with a larger type which is a product of
--   types satisfying the above property.
--   
--   Inside it keeps only one <a>BigMap</a> thus not violating Michelson
--   limitations.
newtype UStore a
UStore :: BigMap ByteString ByteString -> UStore a
[unUStore] :: UStore a -> BigMap ByteString ByteString

-- | Describes one virtual big map in the storage.
newtype k |~> v
UStoreSubMap :: Map k v -> (|~>) k v
[unUStoreSubMap] :: (|~>) k v -> Map k v
newtype UStoreField v
UStoreField :: v -> UStoreField v
[unUStoreField] :: UStoreField v -> v

-- | Get type of submap key.
type GetUStoreKey store name = MSKey (GetUStore name store)

-- | Get type of submap value.
type GetUStoreValue store name = MSValue (GetUStore name store)

-- | Get type of plain field.
type GetUStoreField store name = FSValue (GetUStore name store)

-- | What was found on lookup by constructor name.
--   
--   This keeps either type arguments of <a>|~&gt;</a> or
--   <a>UStoreField</a>.
data ElemSignature
MapSignature :: Type -> Type -> ElemSignature
FieldSignature :: Type -> ElemSignature

-- | Get map signature from the constructor with a given name.
type GetUStore name a = MERequireFound name a (GLookupStore name (Rep a))
type family MSKey ms
type family MSValue ms
type family FSValue ms
instance GHC.Classes.Eq v => GHC.Classes.Eq (Lorentz.UStore.Types.UStoreField v)
instance GHC.Show.Show v => GHC.Show.Show (Lorentz.UStore.Types.UStoreField v)
instance Data.Default.Class.Default (k Lorentz.UStore.Types.|~> v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (k Lorentz.UStore.Types.|~> v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (k Lorentz.UStore.Types.|~> v)
instance forall k (a :: k). Lorentz.Polymorphic.UpdOpHs (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). Lorentz.Polymorphic.GetOpHs (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). Lorentz.Polymorphic.MemOpHs (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). Michelson.Typed.Haskell.Value.IsoValue (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). GHC.Base.Monoid (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). GHC.Base.Semigroup (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). Data.Default.Class.Default (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). GHC.Show.Show (Lorentz.UStore.Types.UStore a)
instance forall k (a :: k). GHC.Classes.Eq (Lorentz.UStore.Types.UStore a)

module Lorentz.Constraints
class AllowBigMap (ToT a) => CanHaveBigMap a

-- | Gathers constraints, commonly required for values.
class (Typeable (ToT a), SingI (ToT a)) => KnownValue a
class (IsoValue a, Typeable (ToCT a), SingI (ToCT a)) => KnownCValue a

-- | Ensure given type does not contain "operation".
class ForbidOp (ToT a) => NoOperation a
class ForbidBigMap (ToT a) => NoBigMap a
instance Michelson.Typed.Scope.AllowBigMap (Michelson.Typed.Haskell.Value.ToT a) => Lorentz.Constraints.CanHaveBigMap a
instance Michelson.Typed.Scope.ForbidBigMap (Michelson.Typed.Haskell.Value.ToT a) => Lorentz.Constraints.NoBigMap a
instance Michelson.Typed.Scope.ForbidOp (Michelson.Typed.Haskell.Value.ToT a) => Lorentz.Constraints.NoOperation a
instance (Michelson.Typed.Haskell.Value.IsoValue a, Data.Typeable.Internal.Typeable (Michelson.Typed.Haskell.Value.ToCT a), Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToCT a)) => Lorentz.Constraints.KnownCValue a
instance (Data.Typeable.Internal.Typeable (Michelson.Typed.Haskell.Value.ToT a), Data.Singletons.Internal.SingI (Michelson.Typed.Haskell.Value.ToT a)) => Lorentz.Constraints.KnownValue a


-- | Conversion between <a>UStore</a> in Haskell and Michelson
--   representation.
module Lorentz.UStore.Haskell

-- | <a>UStore</a> content represented as key-value pairs.
type UStoreContent = [(ByteString, ByteString)]

-- | Given template can be converted to <a>UStore</a> value.
class GUStoreConversible (Rep template) => UStoreConversible template

-- | Make <a>UStore</a> from separate <tt>big_map</tt>s and fields.
mkUStore :: (Generic template, UStoreConversible template) => template -> UStore template

-- | Decompose <a>UStore</a> into separate <tt>big_map</tt>s and fields.
--   
--   Since this function needs to <tt>UNPACK</tt> content of
--   <tt>UStore</tt> to actual keys and values, you have to provide
--   <a>UnpackEnv</a>.
--   
--   Along with resulting value, you get a list of <tt>UStore</tt> entries
--   which were not recognized as belonging to any submap or field
--   according to <tt>UStore</tt>'s template - this should be empty unless
--   <tt>UStore</tt> invariants were violated.
ustoreDecompose :: forall template. (Generic template, UStoreConversible template) => UnpackEnv -> UStore template -> Either Text (UStoreContent, template)

-- | Like <a>ustoreDecompose</a>, but requires all entries from
--   <tt>UStore</tt> to be recognized.
ustoreDecomposeFull :: forall template. (Generic template, UStoreConversible template) => UnpackEnv -> UStore template -> Either Text template
instance GHC.Generics.Generic Lorentz.UStore.Haskell.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.UStore.Haskell.MyStoreTemplate
instance Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.Rep template) => Lorentz.UStore.Haskell.UStoreConversible template
instance (GHC.Generics.Generic template, Lorentz.UStore.Haskell.UStoreConversible template) => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.S1 i (GHC.Generics.Rec0 template))
instance Lorentz.UStore.Haskell.GUStoreConversible x => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.D1 i x)
instance Lorentz.UStore.Haskell.GUStoreConversible x => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.C1 i x)
instance (TypeError ...) => Lorentz.UStore.Haskell.GUStoreConversible (x GHC.Generics.:+: y)
instance (TypeError ...) => Lorentz.UStore.Haskell.GUStoreConversible GHC.Generics.V1
instance (Lorentz.UStore.Haskell.GUStoreConversible x, Lorentz.UStore.Haskell.GUStoreConversible y) => Lorentz.UStore.Haskell.GUStoreConversible (x GHC.Generics.:*: y)
instance Lorentz.UStore.Haskell.GUStoreConversible GHC.Generics.U1
instance (Universum.TypeOps.Each '[Michelson.Typed.Haskell.Value.IsoValue, Lorentz.Constraints.KnownValue, Lorentz.Constraints.NoOperation, Lorentz.Constraints.NoBigMap] '[k, v], GHC.TypeLits.KnownSymbol fieldName, GHC.Classes.Ord k) => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (k Lorentz.UStore.Types.|~> v)))
instance (Universum.TypeOps.Each '[Michelson.Typed.Haskell.Value.IsoValue, Lorentz.Constraints.KnownValue, Lorentz.Constraints.NoOperation, Lorentz.Constraints.NoBigMap] '[v], GHC.TypeLits.KnownSymbol fieldName) => Lorentz.UStore.Haskell.GUStoreConversible (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just fieldName) _1 _2 _3) (GHC.Generics.Rec0 (Lorentz.UStore.Types.UStoreField v)))


-- | Foundation of Lorentz development.
module Lorentz.Base

-- | Alias for instruction which hides inner types representation via
--   <a>T</a>.
newtype (inp :: [Type]) :-> (out :: [Type])
I :: Instr (ToTs inp) (ToTs out) -> (:->)
[unI] :: (:->) -> Instr (ToTs inp) (ToTs out)
infixr 1 :->

-- | Alias for <a>:-&gt;</a>, seems to make signatures more readable
--   sometimes.
--   
--   Let's someday decide which one of these two should remain.
type (%>) = (:->)
infixr 1 %>
type (&) (a :: Type) (b :: [Type]) = a : b
infixr 2 &
(#) :: (a :-> b) -> (b :-> c) -> a :-> c

-- | For use outside of Lorentz.
compileLorentz :: (inp :-> out) -> Instr (ToTs inp) (ToTs out)

-- | Version of <a>compileLorentz</a> specialized to instruction
--   corresponding to contract code.
compileLorentzContract :: forall cp st. (NoOperation cp, NoOperation st, NoBigMap cp, CanHaveBigMap st) => Contract cp st -> Instr '[ToT (cp, st)] '[ToT ([Operation], st)]

-- | Interpret a Lorentz instruction, for test purposes.
interpretLorentzInstr :: (IsoValuesStack inp, IsoValuesStack out) => ContractEnv -> (inp :-> out) -> Rec Identity inp -> Either MichelsonFailed (Rec Identity out)

-- | Parse textual representation of a Michelson value and turn it into
--   corresponding Haskell value.
--   
--   Note: it won't work in some complex cases, e. g. if there is a lambda
--   which uses an instruction which depends on current contract's type.
--   Obviously it can not work, because we don't have any information about
--   a contract to which this value belongs (there is no such contract at
--   all).
parseLorentzValue :: forall v. (IsoValue v, SingI (ToT v), Typeable (ToT v)) => Text -> Either ParseLorentzError v

-- | Lorentz version of analyzer.
analyzeLorentz :: (inp :-> out) -> AnalyzerRes

-- | Lorentz version of <a>transformStrings</a>.
transformStringsLorentz :: Bool -> (MText -> MText) -> (inp :-> out) -> inp :-> out
type ContractOut st = '[([Operation], st)]
type Contract cp st = '[(cp, st)] :-> ContractOut st
data SomeContract
[SomeContract] :: (KnownValue cp, KnownValue st, NoOperation cp, NoOperation st, NoBigMap cp, CanHaveBigMap st) => Contract cp st -> SomeContract
type Lambda i o = '[i] :-> '[o]
instance GHC.Classes.Eq Lorentz.Base.ParseLorentzError
instance GHC.Show.Show Lorentz.Base.ParseLorentzError
instance GHC.Classes.Eq (inp Lorentz.Base.:-> out)
instance GHC.Show.Show (inp Lorentz.Base.:-> out)
instance Formatting.Buildable.Buildable Lorentz.Base.ParseLorentzError
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Base.Lambda inp out)

module Lorentz.Instr
nop :: s :-> s
drop :: (a & s) :-> s
dup :: (a & s) :-> (a & (a & s))
swap :: (a & (b & s)) :-> (b & (a & s))
push :: forall t s. (KnownValue t, NoOperation t, NoBigMap t, IsoValue t) => t -> s :-> (t & s)
some :: (a & s) :-> (Maybe a & s)
none :: forall a s. KnownValue a => s :-> (Maybe a & s)
unit :: s :-> (() & s)
ifNone :: (s :-> s') -> ((a & s) :-> s') -> (Maybe a & s) :-> s'
pair :: (a & (b & s)) :-> ((a, b) & s)
car :: ((a, b) & s) :-> (a & s)
cdr :: ((a, b) & s) :-> (b & s)
left :: forall a b s. KnownValue b => (a & s) :-> (Either a b & s)
right :: forall a b s. KnownValue a => (b & s) :-> (Either a b & s)
ifLeft :: ((a & s) :-> s') -> ((b & s) :-> s') -> (Either a b & s) :-> s'
nil :: KnownValue p => s :-> (List p & s)
cons :: (a & (List a & s)) :-> (List a & s)
size :: SizeOpHs c => (c & s) :-> (Natural & s)
emptySet :: KnownCValue e => s :-> (Set e & s)
emptyMap :: (KnownCValue k, KnownValue v) => s :-> (Map k v & s)
map :: (MapOpHs c, IsoMapOpRes c b) => ((MapOpInpHs c & s) :-> (b & s)) -> (c & s) :-> (MapOpResHs c b & s)
iter :: IterOpHs c => ((IterOpElHs c & s) :-> s) -> (c & s) :-> s
mem :: MemOpHs c => (MemOpKeyHs c & (c & s)) :-> (Bool & s)
get :: GetOpHs c => (GetOpKeyHs c & (c & s)) :-> (Maybe (GetOpValHs c) & s)
update :: UpdOpHs c => (UpdOpKeyHs c & (UpdOpParamsHs c & (c & s))) :-> (c & s)

-- | Helper instruction.
--   
--   Checks whether given key present in the storage and fails if it is.
--   This instruction leaves stack intact.
failingWhenPresent :: forall c k s v st e. (MemOpHs c, k ~ MemOpKeyHs c, KnownValue e, st ~ (k & (v & (c & s)))) => (forall s0. (k : s0) :-> (e : s0)) -> st :-> st

-- | Like <a>update</a>, but throw an error on attempt to overwrite
--   existing entry.
updateNew :: forall c k s e. (UpdOpHs c, MemOpHs c, k ~ UpdOpKeyHs c, k ~ MemOpKeyHs c, KnownValue e) => (forall s0. (k : s0) :-> (e : s0)) -> (k & (UpdOpParamsHs c & (c & s))) :-> (c & s)
if_ :: (s :-> s') -> (s :-> s') -> (Bool & s) :-> s'
ifCons :: ((a & (List a & s)) :-> s') -> (s :-> s') -> (List a & s) :-> s'
loop :: (s :-> (Bool & s)) -> (Bool & s) :-> s
loopLeft :: ((a & s) :-> (Either a b & s)) -> (Either a b & s) :-> (b & s)
lambda :: (KnownValue i, KnownValue o) => Lambda i o -> s :-> (Lambda i o & s)
exec :: (a & (Lambda a b & s)) :-> (b & s)
dip :: forall a s s'. (s :-> s') -> (a & s) :-> (a & s')
failWith :: KnownValue a => (a & s) :-> t
cast :: KnownValue a => (a & s) :-> (a & s)
pack :: forall a s. (KnownValue a, NoOperation a, NoBigMap a) => (a & s) :-> (ByteString & s)
unpack :: forall a s. (KnownValue a, NoOperation a, NoBigMap a) => (ByteString & s) :-> (Maybe a & s)
concat :: ConcatOpHs c => (c & (c & s)) :-> (c & s)
concat' :: ConcatOpHs c => (List c & s) :-> (c & s)
slice :: SliceOpHs c => (Natural & (Natural & (c & s))) :-> (Maybe c & s)
isNat :: (Integer & s) :-> (Maybe Natural & s)
add :: ArithOpHs Add n m => (n & (m & s)) :-> (ArithResHs Add n m & s)
sub :: ArithOpHs Sub n m => (n & (m & s)) :-> (ArithResHs Sub n m & s)
rsub :: ArithOpHs Sub n m => (m & (n & s)) :-> (ArithResHs Sub n m & s)
mul :: ArithOpHs Mul n m => (n & (m & s)) :-> (ArithResHs Mul n m & s)
ediv :: EDivOpHs n m => (n & (m & s)) :-> (Maybe (EDivOpResHs n m, EModOpResHs n m) & s)
abs :: UnaryArithOpHs Abs n => (n & s) :-> (UnaryArithResHs Abs n & s)
neg :: UnaryArithOpHs Neg n => (n & s) :-> (UnaryArithResHs Neg n & s)
lsl :: ArithOpHs Lsl n m => (n & (m & s)) :-> (ArithResHs Lsl n m & s)
lsr :: ArithOpHs Lsr n m => (n & (m & s)) :-> (ArithResHs Lsr n m & s)
or :: ArithOpHs Or n m => (n & (m & s)) :-> (ArithResHs Or n m & s)
and :: ArithOpHs And n m => (n & (m & s)) :-> (ArithResHs And n m & s)
xor :: ArithOpHs Xor n m => (n & (m & s)) :-> (ArithResHs Xor n m & s)
not :: UnaryArithOpHs Not n => (n & s) :-> (UnaryArithResHs Not n & s)
compare :: ArithOpHs Compare n n => (n & (n & s)) :-> (ArithResHs Compare n n & s)
eq0 :: UnaryArithOpHs Eq' n => (n & s) :-> (UnaryArithResHs Eq' n & s)
neq0 :: UnaryArithOpHs Neq n => (n & s) :-> (UnaryArithResHs Neq n & s)
lt0 :: UnaryArithOpHs Lt n => (n & s) :-> (UnaryArithResHs Lt n & s)
gt0 :: UnaryArithOpHs Gt n => (n & s) :-> (UnaryArithResHs Gt n & s)
le0 :: UnaryArithOpHs Le n => (n & s) :-> (UnaryArithResHs Le n & s)
ge0 :: UnaryArithOpHs Ge n => (n & s) :-> (UnaryArithResHs Ge n & s)
int :: (Natural & s) :-> (Integer & s)
self :: forall cp s. s :-> (ContractAddr cp & s)
contract :: KnownValue p => (Address & s) :-> (Maybe (ContractAddr p) & s)
transferTokens :: forall p s. (KnownValue p, NoOperation p, NoBigMap p) => (p & (Mutez & (ContractAddr p & s))) :-> (Operation & s)
setDelegate :: (Maybe KeyHash & s) :-> (Operation & s)

-- | <i>Warning: CREATE_ACCOUNT instruction is deprecated in Michelson
--   005</i>
createAccount :: (KeyHash & (Maybe KeyHash & (Bool & (Mutez & s)))) :-> (Operation & (Address & s))

-- | <i>Warning: CREATE_CONTRACT instruction has different type in
--   Michelson 005</i>
createContract :: forall p g s. (KnownValue p, NoOperation p, KnownValue g, NoOperation g, NoBigMap p, CanHaveBigMap g) => ('[(p, g)] :-> '[(List Operation, g)]) -> (KeyHash & (Maybe KeyHash & (Bool & (Bool & (Mutez & (g & s)))))) :-> (Operation & (Address & s))
implicitAccount :: (KeyHash & s) :-> (ContractAddr () & s)
now :: s :-> (Timestamp & s)
amount :: s :-> (Mutez & s)
balance :: s :-> (Mutez & s)
checkSignature :: (PublicKey & (Signature & (ByteString & s))) :-> (Bool & s)
sha256 :: (ByteString & s) :-> (ByteString & s)
sha512 :: (ByteString & s) :-> (ByteString & s)
blake2B :: (ByteString & s) :-> (ByteString & s)
hashKey :: (PublicKey & s) :-> (KeyHash & s)

-- | <i>Warning: STEPS_TO_QUOTA instruction is deprecated in Michelson
--   005</i>
stepsToQuota :: s :-> (Natural & s)

-- | <i>Warning: Using <a>source</a> is considered a bad practice. Consider
--   using <a>sender</a> instead until further investigation</i>
source :: s :-> (Address & s)
sender :: s :-> (Address & s)
address :: (ContractAddr a & s) :-> (Address & s)
class LorentzFunctor (c :: Type -> Type)
lmap :: (LorentzFunctor c, KnownValue b) => ((a : s) :-> (b : s)) -> (c a : s) :-> (c b : s)

-- | Retain the value only if it is not zero.
nonZero :: NonZero t => (t : s) :-> (Maybe t : s)
instance Lorentz.Instr.NonZero GHC.Integer.Type.Integer
instance Lorentz.Instr.NonZero GHC.Natural.Natural
instance Lorentz.Instr.LorentzFunctor GHC.Maybe.Maybe


-- | Referenced-by-type versions of some instructions.
--   
--   They allow to "dip" into stack or copy elements of stack referring
--   them by type. Their use is justified, because in most cases there is
--   only one element of each type of stack, and in cases when this does
--   not hold (e.g. entry point with multiple parameters of the same type),
--   it might be a good idea to wrap those types into a newtype or to use
--   primitives from <tt>named</tt> package.
--   
--   This module is experimental, i.e. everything here should work but may
--   be removed in favor of better development practices.
--   
--   Each instruction is followed with usage example.
module Lorentz.Referenced

-- | Duplicate an element of stack referring it by type.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dupT :: forall a st. DupT st a st => st :-> (a : st)

-- | Dip repeatedly until element of the given type is on top of the stack.
--   
--   If stack contains multiple entries of this type, compile error is
--   raised.
dipT :: forall a inp dinp dout out. DipT inp a inp dinp dout out => (dinp :-> dout) -> inp :-> out

-- | Remove element with the given type from the stack.
dropT :: forall a inp dinp dout out. (DipT inp a inp dinp dout out, dinp ~ (a : dout)) => inp :-> out
instance ((TypeError ...), dipInp Data.Type.Equality.~ (TypeError ...), out Data.Type.Equality.~ (TypeError ...)) => Lorentz.Referenced.DipT origSt a '[] dipInp dipOut out
instance (Data.Type.Bool.If (Util.Type.IsElem a st) (TypeError ...) (() :: Constraint), dipInp Data.Type.Equality.~ (a : st), dipOut Data.Type.Equality.~ out) => Lorentz.Referenced.DipT origSt a (a : st) dipInp dipOut out
instance (Lorentz.Referenced.DipT origSt a st dipInp dipOut out, out1 Data.Type.Equality.~ (b : out)) => Lorentz.Referenced.DipT origSt a (b : st) dipInp dipOut out1
instance (TypeError ...) => Lorentz.Referenced.DupT origSt a '[]
instance Data.Type.Bool.If (Util.Type.IsElem a st) (TypeError ...) (() :: Constraint) => Lorentz.Referenced.DupT origSt a (a : st)
instance Lorentz.Referenced.DupT origSt a st => Lorentz.Referenced.DupT origSt a (b : st)

module Lorentz.Doc

-- | Put a document item.
doc :: DocItem di => di -> s :-> s

-- | Group documentation built in the given piece of code into block
--   dedicated to one thing, e.g. to one entry point.
docGroup :: DocGrouping -> (inp :-> out) -> inp :-> out
buildLorentzDoc :: (inp :-> out) -> ContractDoc

-- | Give a name to given contract. Apply it to the whole contract code.
contractName :: Text -> (inp :-> out) -> inp :-> out

-- | A piece of documentation describing one property of a thing, be it a
--   name or description of a contract, or an error throwable by given
--   endpoint.
--   
--   Items of the same type appear close to each other in a rendered
--   documentation and form a <i>section</i>.
--   
--   Doc items are later injected into a contract code via a dedicated
--   nop-like instruction. Normally doc items which belong to one section
--   appear in resulting doc in the same order in which they appeared in
--   the contract.
class (Typeable d, KnownNat (DocItemPosition d)) => DocItem d where {
    
    -- | Position of this item in the resulting documentation; the smaller the
    --   value, the higher the section with this element will be placed.
    --   
    --   Documentation structure is not necessarily flat. If some doc item
    --   consolidates a whole documentation block within it, this block will
    --   have its own placement of items independent from outer parts of the
    --   doc.
    type family DocItemPosition d = (pos :: Nat) | pos -> d;
    
    -- | Defines where given doc item should be put. There are two options: 1.
    --   Inline right here (default behaviour); 2. Put into definitions
    --   section.
    type family DocItemPlacement d :: DocItemPlacementKind;
    type DocItemPlacement d =  'DocItemInlined;
}

-- | When multiple items of the same type belong to one section, how this
--   section will be called.
--   
--   If not provided, section will contain just untitled content.
docItemSectionName :: DocItem d => Maybe Text

-- | Description of a section.
--   
--   Can be used to mention some common things about all elements of this
--   section. Markdown syntax is permitted here.
docItemSectionDescription :: DocItem d => Maybe Builder

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: DocItem d => d -> DocItemRef (DocItemPlacement d)

-- | Defines a function which constructs an unique identifier of given doc
--   item, if it has been decided to put the doc item into definitions
--   section.
--   
--   Identifier should be unique both among doc items of the same type and
--   items of other types. Thus, consider using "typeId-contentId" pattern.
docItemRef :: (DocItem d, DocItemPlacement d ~  'DocItemInlined) => d -> DocItemRef (DocItemPlacement d)

-- | Render given doc item to Markdown, preferably one line, optionally
--   with header.
--   
--   Accepts the smallest allowed level of header. (Using smaller value
--   than provided one will interfere with existing headers thus delivering
--   mess).
docItemToMarkdown :: DocItem d => HeaderLevel -> d -> Builder

-- | All doc items which this doc item refers to.
--   
--   They will automatically be put to definitions as soon as given doc
--   item is detected.
docItemDependencies :: DocItem d => d -> [SomeDocDefinitionItem]

-- | This function accepts doc items put under the same section in the
--   order in which they appeared in the contract and returns their new
--   desired order. It's also fine to use this function for filtering or
--   merging doc items.
--   
--   Default implementation * leaves inlined items as is; * for items put
--   to definitions, lexicographically sorts them by their id.
docItemsOrder :: DocItem d => [d] -> [d]

-- | Description for a Haskell type appearing in documentation.
class TypeHasDoc a

-- | Name of type as it appears in definitions section.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: TypeHasDoc a => Proxy a -> Text

-- | Name of type as it appears in definitions section.
--   
--   Default definition derives name from Generics. If it does not fit,
--   consider defining this function manually. (We tried using <a>Data</a>
--   for this, but it produces names including module names which is not do
--   we want).
typeDocName :: (TypeHasDoc a, Generic a, KnownSymbol (GenericTypeName a)) => Proxy a -> Text

-- | Explanation of a type. Markdown formatting is allowed.
typeDocMdDescription :: TypeHasDoc a => Builder

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: TypeHasDoc a => Proxy a -> WithinParens -> Builder

-- | How reference to this type is rendered, in Markdown.
--   
--   Examples: * <tt><a>Integer</a></tt>, * <tt><a>Maybe</a>
--   <a>()</a></tt>.
--   
--   Consider using one of the following functions as default
--   implementation; which one to use depends on number of type arguments
--   in your type: * <a>homomorphicTypeDocMdReference</a> *
--   <a>poly1TypeDocMdReference</a> * <a>poly2TypeDocMdReference</a>
--   
--   If none of them fits your purposes precisely, consider using
--   <a>customTypeDocMdReference</a>.
typeDocMdReference :: (TypeHasDoc a, Typeable a, IsHomomorphic a) => Proxy a -> WithinParens -> Builder

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: TypeHasDoc a => Proxy a -> [SomeTypeWithDoc]

-- | All types which this type directly contains.
--   
--   Used in automatic types discovery.
typeDocDependencies :: (TypeHasDoc a, Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: TypeHasDoc a => TypeDocHaskellRep a

-- | For complex types - their immediate Haskell representation.
--   
--   For primitive types set this to <a>Nothing</a>.
--   
--   For homomorphic types use <a>homomorphicTypeDocHaskellRep</a>
--   implementation.
--   
--   For polymorhpic types consider using <a>concreteTypeDocHaskellRep</a>
--   as implementation.
--   
--   Modifier <a>haskellRepNoFields</a> can be used to hide names of
--   fields, beneficial for newtypes.
--   
--   Another modifier called <a>haskellRepStripFieldPrefix</a> can be used
--   for datatypes to leave only meaningful part of name in every field.
typeDocHaskellRep :: (TypeHasDoc a, Generic a, GTypeHasDoc (Rep a), IsHomomorphic a) => TypeDocHaskellRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: TypeHasDoc a => TypeDocMichelsonRep a

-- | Final michelson representation of a type.
--   
--   For homomorphic types use <a>homomorphicTypeDocMichelsonRep</a>
--   implementation.
--   
--   For polymorhpic types consider using
--   <a>concreteTypeDocMichelsonRep</a> as implementation.
typeDocMichelsonRep :: (TypeHasDoc a, SingI (ToT a), IsHomomorphic a) => TypeDocMichelsonRep a

-- | Constraint, required when deriving <a>TypeHasDoc</a> for polymorphic
--   type with the least possible number of methods defined manually.
type PolyTypeHasDocC ts = Each '[TypeHasDoc] ts

-- | Data hides some type implementing <a>TypeHasDoc</a>.
data SomeTypeWithDoc
[SomeTypeWithDoc] :: TypeHasDoc td => Proxy td -> SomeTypeWithDoc

-- | Description of something.
data DDescription
DDescription :: Text -> DDescription

-- | An error thrown by a contract.
data DError
DError :: DError

-- | Doc element with description of a type.
data DType
[DType] :: TypeHasDoc a => Proxy a -> DType

-- | Render given contract documentation to markdown document.
contractDocToMarkdown :: ContractDoc -> LText

-- | Require two types to be built from the same type constructor.
--   
--   E.g. <tt>HaveCommonTypeCtor (Maybe Integer) (Maybe Natural)</tt> is
--   defined, while <tt>HaveCmmonTypeCtor (Maybe Integer) [Integer]</tt> is
--   not.
class HaveCommonTypeCtor a b

-- | Require this type to be homomorphic.
class IsHomomorphic a

-- | Implement <a>typeDocDependencies</a> via getting all immediate fields
--   of a datatype.
--   
--   Note: this will not include phantom types, I'm not sure yet how this
--   scenario should be handled (@martoon).
genericTypeDocDependencies :: forall a. (Generic a, GTypeHasDoc (Rep a)) => Proxy a -> [SomeTypeWithDoc]

-- | Render a reference to a type which consists of type constructor (you
--   have to provide name of this type constructor and documentation for
--   the whole type) and zero or more type arguments.
customTypeDocMdReference :: (Text, DType) -> [DType] -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for homomorphic types only.
homomorphicTypeDocMdReference :: forall (t :: Type). (Typeable t, TypeHasDoc t, IsHomomorphic t) => Proxy t -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with one type
--   argument, like <tt>Maybe Integer</tt>.
poly1TypeDocMdReference :: forall t (r :: Type) (a :: Type). (r ~ t a, Typeable t, Each '[TypeHasDoc] [r, a], IsHomomorphic t) => Proxy r -> WithinParens -> Builder

-- | Derive <a>typeDocMdReference</a>, for polymorphic type with two type
--   arguments, like <tt>Lambda Integer Natural</tt>.
poly2TypeDocMdReference :: forall t (r :: Type) (a :: Type) (b :: Type). (r ~ t a b, Typeable t, Each '[TypeHasDoc] [r, a, b], IsHomomorphic t) => Proxy r -> WithinParens -> Builder

-- | Implement <a>typeDocHaskellRep</a> for a homomorphic type.
--   
--   Note that it does not require your type to be of <a>IsHomomorphic</a>
--   instance, which can be useful for some polymorhpic types which, for
--   documentation purposes, we want to consider homomorphic. Example:
--   <a>Operation</a> is in fact polymorhpic, but we don't want this fact
--   to be reflected in the documentation.
homomorphicTypeDocHaskellRep :: forall a. (Generic a, GTypeHasDoc (Rep a)) => TypeDocHaskellRep a

-- | Implement <a>typeDocHaskellRep</a> on example of given concrete type.
--   
--   This is a best effort attempt to implement <a>typeDocHaskellRep</a>
--   for polymorhpic types, as soon as there is no simple way to preserve
--   type variables when automatically deriving Haskell representation of a
--   type.
concreteTypeDocHaskellRep :: forall a b. (Typeable a, IsoValue a, Generic a, GTypeHasDoc (Rep a), HaveCommonTypeCtor b a) => TypeDocHaskellRep b

-- | Erase fields from Haskell datatype representation.
--   
--   Use this when rendering fields names is undesired.
haskellRepNoFields :: TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Cut fields prefixes which we use according to the style guide.
--   
--   E.g. <tt>cmMyField</tt> field will be transformed to <tt>myField</tt>.
haskellRepStripFieldPrefix :: HasCallStack => TypeDocHaskellRep a -> TypeDocHaskellRep a

-- | Implement <a>typeDocMichelsonRep</a> for homomorphic type.
homomorphicTypeDocMichelsonRep :: forall a. SingI (ToT a) => TypeDocMichelsonRep a

-- | Implement <a>typeDocMichelsonRep</a> on example of given concrete
--   type.
--   
--   This function exists for the same reason as
--   <a>concreteTypeDocHaskellRep</a>.
concreteTypeDocMichelsonRep :: forall a b. (Typeable a, SingI (ToT a), HaveCommonTypeCtor b a) => TypeDocMichelsonRep b
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Michelson.Typed.Haskell.Doc.TypeHasDoc] '[i, o] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Base.Lambda i o)


-- | Identity transformations between different Haskell types.
module Lorentz.Coercions

-- | Whether two types have the same Michelson representation.
type Coercible_ a b = ToT a ~ ToT b

-- | Convert between values of types that have the same representation.
coerce_ :: Coercible_ a b => (a & s) :-> (b & s)

-- | Convert between two stacks via failing.
fakeCoerce :: s1 :-> s2

-- | Specialized version of <a>coerce_</a> to unwrap a haskell newtype.
coerceUnwrap :: Coercible_ newtyp (Unwrapped newtyp) => (newtyp : s) :-> (Unwrapped newtyp : s)

-- | Specialized version of <a>coerce_</a> to wrap into a haskell newtype.
coerceWrap :: Coercible_ newtyp (Unwrapped newtyp) => (Unwrapped newtyp : s) :-> (newtyp : s)

-- | Lift given value to a named value.
toNamed :: Label name -> (a : s) :-> (NamedF Identity a name : s)

-- | Unpack named value.
fromNamed :: Label name -> (NamedF Identity a name : s) :-> (a : s)

-- | <a>Wrapped</a> provides isomorphisms to wrap and unwrap newtypes or
--   data types with one constructor.
class Wrapped s where {
    type family Unwrapped s :: Type;
}

-- | An isomorphism between <tt>s</tt> and <tt>a</tt>.
--   
--   If your type has a <a>Generic</a> instance, <a>_Wrapped'</a> will
--   default to <a>_GWrapped'</a>, and you can choose to not override it
--   with your own definition.
_Wrapped' :: Wrapped s => Iso' s (Unwrapped s)


-- | This module contains implementation of <a>Extensible</a> values.
--   
--   <tt>Extensible</tt> values are an alternative representation of
--   sum-types for Michelson. Instead of representing them as nested
--   options, we treat them as (Natural, ByteString) pair, where the first
--   element of the pair represents the constructor index, while the second
--   is a packed argument.
--   
--   With such a representation sum types can be easily upgraded: it is
--   possible to add new elements to the sum type, and the representation
--   would not change.
--   
--   However, such representation essentially limits the applicability of
--   the values. This module does not provide Michelson-level function to
--   unwrap the value because it would require traversing all the possible
--   options in the contract code. While this is possible, it is very
--   inefficient. Up to this moment, we have not come up with a decent
--   reason to allow such behavior, so Extensible types are write-only in
--   Michelson code. They can be unwrapped off-chain with
--   <tt>fromExtVal</tt>.
--   
--   In order to preserve previous values during migrations, users should
--   ONLY APPEND items to the underlying sum type. Changing, reordering and
--   deleting items is not allowed and would lead to compatibility
--   breakage. Currently, this restriction in not enforced. Only
--   no-argument and one-argument constructors are supported.
--   
--   GOOD: -- `Extensible GoodSumTypeV1` is backwards compatible -- with
--   `Extensible GoodSumTypeV2` data GoodSumTypeV1 = A Natural | B data
--   GoodSumTypeV2 = A Natural | B | C MText
--   
--   BAD: -- `Extensible BadSumTypeV1` is NOT backwards compatible -- with
--   `Extensible BadSumTypeV2` data BadSumTypeV1 = A | B data BadSumTypeV2
--   = A Natural | B | C MText
module Lorentz.Extensible
newtype Extensible x
Extensible :: (Natural, ByteString) -> Extensible x

-- | Errors related to fromExtVal conversion
data ExtConversionError
ConstructorIndexNotFound :: Natural -> ExtConversionError
ArgumentUnpackFailed :: ExtConversionError
type ExtVal x = (Generic x, GExtVal x (Rep x))

-- | Information to be provided for documenting some <tt><a>Extensible</a>
--   x</tt>.
class ExtensibleHasDoc x

-- | Implementation for <a>typeDocName</a> of the corresponding
--   <tt>Extensible</tt>.
extensibleDocName :: ExtensibleHasDoc x => Proxy x -> Text

-- | Implementation for <a>typeDocDependencies</a> of the corresponding
--   <tt>Extensible</tt>.
extensibleDocDependencies :: ExtensibleHasDoc x => Proxy x -> [SomeTypeWithDoc]

-- | Implementation for <a>typeDocDependencies</a> of the corresponding
--   <tt>Extensible</tt>.
extensibleDocDependencies :: (ExtensibleHasDoc x, Generic x, GTypeHasDoc (Rep x)) => Proxy x -> [SomeTypeWithDoc]

-- | Overall description of this type.
extensibleDocMdDescription :: ExtensibleHasDoc x => Builder

-- | Converts a value from a Haskell representation to its extensible
--   Michelson representation (i.e. (Natural, Bytestring) pair).
toExtVal :: ExtVal a => a -> Extensible a

-- | Converts a value from an extensible Michelson representation to its
--   Haskell sum-type representation. Fails if the Michelson representation
--   points to a nun-existent constructor, or if we failed to unpack the
--   argument.
fromExtVal :: ExtVal a => UnpackEnv -> Extensible a -> Either ExtConversionError a

-- | Wraps an argument on top of the stack into an Extensible
--   representation
wrapExt :: forall t (n :: Nat) name field s. WrapExtC t n name field s => Label ("c" `AppendSymbol` name) -> AppendCtorField field s :-> (Extensible t : s)
type WrapExtC t n name field s = ( 'Ctor n name field ~ LookupCtor name (EnumerateCtors (GetCtors t)), WrapExt field, KnownNat n)
instance GHC.Show.Show Lorentz.Extensible.ExtConversionError
instance GHC.Classes.Eq Lorentz.Extensible.ExtConversionError
instance forall k (x :: k). Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). GHC.Show.Show (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). GHC.Classes.Eq (Lorentz.Extensible.Extensible x)
instance forall k (x :: k). GHC.Generics.Generic (Lorentz.Extensible.Extensible x)
instance (GHC.TypeNats.KnownNat pos, GHC.TypeLits.KnownSymbol name, Michelson.Typed.Haskell.Doc.TypeHasDoc param, param Data.Type.Equality.~ Michelson.Typed.Haskell.Instr.Sum.ExtractCtorField field) => Lorentz.Extensible.DocumentCtor ('Lorentz.Extensible.Ctor pos name field)
instance (Lorentz.Extensible.ExtensibleHasDoc x, Util.Type.ReifyList Lorentz.Extensible.DocumentCtor (Lorentz.Extensible.EnumerateCtors (Lorentz.Extensible.GetCtors x))) => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Extensible.Extensible x)
instance forall k (t :: k) (x :: * -> *) (i :: GHC.Generics.Meta). Lorentz.Extensible.GExtVal t x => Lorentz.Extensible.GExtVal t (GHC.Generics.D1 i x)
instance ('Lorentz.Extensible.Ctor n name 'Michelson.Typed.Haskell.Instr.Sum.NoFields Data.Type.Equality.~ Lorentz.Extensible.LookupCtor name (Lorentz.Extensible.EnumerateCtors (Lorentz.Extensible.GetCtors t)), GHC.TypeNats.KnownNat n) => Lorentz.Extensible.GExtVal t (GHC.Generics.C1 ('GHC.Generics.MetaCons name _1 _2) GHC.Generics.U1)
instance (Michelson.Typed.Haskell.Value.IsoValue param, Lorentz.Constraints.KnownValue param, Lorentz.Constraints.NoOperation param, Lorentz.Constraints.NoBigMap param, 'Lorentz.Extensible.Ctor n name ('Michelson.Typed.Haskell.Instr.Sum.OneField param) Data.Type.Equality.~ Lorentz.Extensible.LookupCtor name (Lorentz.Extensible.EnumerateCtors (Lorentz.Extensible.GetCtors t)), GHC.TypeNats.KnownNat n) => Lorentz.Extensible.GExtVal t (GHC.Generics.C1 ('GHC.Generics.MetaCons name _1 _2) (GHC.Generics.S1 _3 (GHC.Generics.Rec0 param)))
instance forall k (t :: k) (x :: * -> *) (y :: * -> *). (Lorentz.Extensible.GExtVal t x, Lorentz.Extensible.GExtVal t y) => Lorentz.Extensible.GExtVal t (x GHC.Generics.:+: y)
instance Formatting.Buildable.Buildable Lorentz.Extensible.ExtConversionError
instance (Michelson.Typed.Haskell.Value.IsoValue param, Lorentz.Constraints.KnownValue param, Lorentz.Constraints.NoOperation param, Lorentz.Constraints.NoBigMap param) => Lorentz.Extensible.WrapExt ('Michelson.Typed.Haskell.Instr.Sum.OneField param)
instance Lorentz.Extensible.WrapExt 'Michelson.Typed.Haskell.Instr.Sum.NoFields


-- | Composability helper for <a>UStore</a>.
module Lorentz.UStore.Lift

-- | Lift an <a>UStore</a> to another <a>UStore</a> which contains all the
--   entries of the former under given field.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Note that this function ensures that template of resulting store does
--   not contain inner nested templates with duplicated fields, otherwise
--   <a>UStore</a> invariants could get broken.
liftUStore :: (Generic template, RequireAllUniqueFields template) => Label name -> (UStore (GetFieldType template name) : s) :-> (UStore template : s)

-- | Unlift an <a>UStore</a> to a smaller <a>UStore</a> which is part of
--   the former.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Surprisingly, despite smaller <a>UStore</a> may have extra entries,
--   this function is safe when used in contract code. Truly, all getters
--   and setters are still safe to use. Also, there is no way for the
--   resulting small <tt>UStore</tt> to leak outside of the contract since
--   the only place where <tt>big_map</tt> can appear is contract storage,
--   so this small <tt>UStore</tt> can be either dropped or lifted back via
--   <a>liftUStore</a> to appear as part of the new contract's state.
--   
--   When this function is run as part of standalone instructions sequence,
--   not as part of contract code (e.g. in tests), you may get an
--   <tt>UStore</tt> with entries not inherent to it.
unliftUStore :: Generic template => Label name -> (UStore template : s) :-> (UStore (GetFieldType template name) : s)
type UStoreFieldsAreUnique template = AllUnique (UStoreFields template)
instance GHC.Generics.Generic Lorentz.UStore.Lift.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.UStore.Lift.MyStoreTemplate

module Lorentz.Ext
stackRef :: forall (gn :: Nat) st n. (n ~ ToPeano gn, SingI n, KnownPeano n, RequireLongerThan st n) => PrintComment st
printComment :: PrintComment (ToTs s) -> s :-> s
testAssert :: Typeable (ToTs out) => Text -> PrintComment (ToTs inp) -> (inp :-> (Bool & out)) -> inp :-> inp
stackType :: forall s. s :-> s

module Lorentz.CompileExts

-- | Defines a way to turn lorentz contract into typed contract.
--   
--   You probably want to choose some smart implementation for this, which
--   may add some annotations to resulting contract.
newtype LorentzCompilationWay cp st
LorentzCompilationWay :: (Contract cp st -> FullContract (ToT cp) (ToT st)) -> LorentzCompilationWay cp st
[compileLorentzContract'] :: LorentzCompilationWay cp st -> Contract cp st -> FullContract (ToT cp) (ToT st)

-- | Attaches no additional information.
lcwDumb :: (Each [Typeable, SingI] [ToT cp, ToT st], Each '[NoOperation] [cp, st], NoBigMap cp, CanHaveBigMap st) => LorentzCompilationWay cp st

-- | Fits for case when your contract exposes multiple entrypoints via
--   having sum type as its parameter.
--   
--   In particular, this will attach field annotations to immediate
--   parameter "arms" which will be named as corresponding constructor
--   names.
lcwEntryPoints :: LcwEntryPointsC  'False cp st => LorentzCompilationWay cp st

-- | Similar to <a>lcwEntryPoints</a>, but for case of parameter being
--   defined as several nested datatypes.
--   
--   In particular, this will traverse sum types recursively, stopping at
--   Michelson primitives (like <a>Natural</a>) and constructors with
--   number of fields different from one.
lcwEntryPointsRecursive :: LcwEntryPointsC  'True cp st => LorentzCompilationWay cp st
instance (Lorentz.CompileExts.EntryPointsNotes deep ep a, Michelson.Typed.Haskell.Value.IsGenericIsoValue a) => Lorentz.CompileExts.GEntryPointsNotes deep ep (GHC.Generics.Rec0 a)
instance Lorentz.CompileExts.GEntryPointsNotes deep ep x => Lorentz.CompileExts.GEntryPointsNotes deep ep (GHC.Generics.D1 i x)
instance (Lorentz.CompileExts.GEntryPointsNotes deep epx x, Lorentz.CompileExts.GEntryPointsNotes deep epy y) => Lorentz.CompileExts.GEntryPointsNotes deep ('Lorentz.CompileExts.EPNode epx epy) (x GHC.Generics.:+: y)
instance GHC.TypeLits.KnownSymbol ctor => Lorentz.CompileExts.GEntryPointsNotes 'GHC.Types.False ep (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance GHC.TypeLits.KnownSymbol ctor => Lorentz.CompileExts.GEntryPointsNotes 'GHC.Types.True 'Lorentz.CompileExts.EPLeaf (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance (ep Data.Type.Equality.~ 'Lorentz.CompileExts.EPNode epx epy, Lorentz.CompileExts.GEntryPointsNotes 'GHC.Types.True ep x) => Lorentz.CompileExts.GEntryPointsNotes 'GHC.Types.True ('Lorentz.CompileExts.EPNode epx epy) (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance Lorentz.CompileExts.GEntryPointsNotes deep ep x => Lorentz.CompileExts.GEntryPointsNotes deep ep (GHC.Generics.S1 i x)
instance Lorentz.CompileExts.GEntryPointsNotes deep 'Lorentz.CompileExts.EPLeaf GHC.Generics.U1
instance Lorentz.CompileExts.GEntryPointsNotes deep 'Lorentz.CompileExts.EPLeaf (x GHC.Generics.:*: y)


-- | Printing lorentz contracts.
module Lorentz.Print

-- | Pretty-print a Haskell value as Michelson one.
printLorentzValue :: (IsoValue v, SingI (ToT v), HasNoOp (ToT v)) => Bool -> v -> LText

-- | Pretty-print a Lorentz contract into Michelson code.
printLorentzContract :: forall cp st. Each '[SingI] [ToT cp, ToT st] => Bool -> LorentzCompilationWay cp st -> Contract cp st -> LText

module Lorentz.ADT

-- | Allows field access and modification.
type HasField dt fname = (InstrGetFieldC dt fname, InstrSetFieldC dt fname)

-- | Like <a>HasField</a>, but allows constrainting field type.
type HasFieldOfType dt fname fieldTy = (HasField dt fname, GetFieldType dt fname ~ fieldTy)

-- | Shortcut for multiple <a>HasFieldOfType</a> constraints.
type family HasFieldsOfType (dt :: Type) (fs :: [NamedField]) :: Constraint

-- | A pair of field name and type.
data NamedField
NamedField :: Symbol -> Type -> NamedField
type n := ty =  'NamedField n ty

-- | Extract a field of a datatype replacing the value of this datatype
--   with the extracted field.
--   
--   For this and the following functions you have to specify field name
--   which is either record name or name attached with <tt>(:!)</tt>
--   operator.
toField :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & st)

-- | Like <a>toField</a>, but leaves field named.
toFieldNamed :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & st)

-- | Extract a field of a datatype, leaving the original datatype on stack.
getField :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> (GetFieldType dt name & (dt : st))

-- | Like <a>getField</a>, but leaves field named.
getFieldNamed :: forall dt name st. InstrGetFieldC dt name => Label name -> (dt & st) :-> ((name :! GetFieldType dt name) & (dt : st))

-- | Set a field of a datatype.
setField :: forall dt name st. InstrSetFieldC dt name => Label name -> (GetFieldType dt name : (dt : st)) :-> (dt : st)

-- | Apply given modifier to a datatype field.
modifyField :: forall dt name st. (InstrGetFieldC dt name, InstrSetFieldC dt name) => Label name -> (forall st0. (GetFieldType dt name : st0) :-> (GetFieldType dt name : st0)) -> (dt & st) :-> (dt & st)

-- | Make up a datatype. You provide a pack of individual fields
--   constructors.
--   
--   Each element of the accepted record should be an instruction wrapped
--   with <a>fieldCtor</a> function. This instruction will have access to
--   the stack at the moment of calling <tt>construct</tt>. Instructions
--   have to output fields of the built datatype, one per instruction;
--   instructions order is expected to correspond to the order of fields in
--   the datatype.
construct :: forall dt st. (InstrConstructC dt, RMap (ConstructorFieldTypes dt)) => Rec (FieldConstructor st) (ConstructorFieldTypes dt) -> st :-> (dt & st)

-- | Version of <a>construct</a> which accepts tuple of field constructors.
constructT :: forall dt fctors st. (InstrConstructC dt, RMap (ConstructorFieldTypes dt), fctors ~ Rec (FieldConstructor st) (ConstructorFieldTypes dt), RecFromTuple fctors) => IsoRecTuple fctors -> st :-> (dt & st)

-- | Lift an instruction to field constructor.
fieldCtor :: (st :-> (f & st)) -> FieldConstructor st f

-- | Wrap entry in constructor. Useful for sum types.
wrap_ :: forall dt name st. InstrWrapC dt name => Label name -> AppendCtorField (GetCtorField dt name) st :-> (dt & st)

-- | Pattern match on the given sum type.
--   
--   You have to provide a <a>Rec</a> containing case branches. To
--   construct a case branch use <a>/-&gt;</a> operator.
case_ :: forall dt out inp. (InstrCaseC dt inp out, RMap (CaseClauses dt)) => Rec (CaseClauseL inp out) (CaseClauses dt) -> (dt & inp) :-> out

-- | Like <a>case_</a>, accepts a tuple of clauses, which may be more
--   convenient.
--   
--   If user is experiencing problems with wierd errors about tuples while
--   using this function, he should take look at <a>Instances</a> and
--   ensure that his tuple isn't bigger than generated instances, if so, he
--   should probably extend number of generated instances.
caseT :: forall dt out inp clauses. CaseTC dt out inp clauses => IsoRecTuple clauses -> (dt & inp) :-> out
type CaseTC dt out inp clauses = (InstrCaseC dt inp out, RMap (CaseClauses dt), RecFromTuple clauses, clauses ~ Rec (CaseClauseL inp out) (CaseClauses dt))

-- | Provides "case" arrow which works on different wrappers for clauses.
class CaseArrow name body clause | clause -> name, clause -> body

-- | Lift an instruction to case clause.
--   
--   You should write out constructor name corresponding to the clause
--   explicitly. Prefix constructor name with "c" letter, otherwise your
--   label will not be recognized by Haskell parser. Passing constructor
--   name can be circumvented but doing so is not recomended as mentioning
--   contructor name improves readability and allows avoiding some
--   mistakes.
(/->) :: CaseArrow name body clause => Label name -> body -> clause
infixr 0 /->

-- | Lorentz analogy of <a>CaseClause</a>, it works on plain <a>Type</a>
--   types.
data CaseClauseL (inp :: [Type]) (out :: [Type]) (param :: CaseClauseParam)
[CaseClauseL] :: (AppendCtorField x inp :-> out) -> CaseClauseL inp out ( 'CaseClauseParam ctor x)

-- | Constraint for <a>instrConstruct</a>.
type InstrConstructC dt = (IsoValue dt, Generic dt, GInstrConstruct (Rep dt), GValueType (Rep dt) ~ ToT dt)

-- | Types of all fields in a datatype.
type ConstructorFieldTypes dt = GFieldTypes (Rep dt)

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec (a :: u -> Type) (b :: [u]) :: forall u. () => u -> Type -> [u] -> Type
[RNil] :: forall u (a :: u -> Type) (b :: [u]). () => Rec a ([] :: [u])
[:&] :: forall u (a :: u -> Type) (b :: [u]) (r :: u) (rs :: [u]). () => !a r -> !Rec a rs -> Rec a (r : rs)
infixr 7 :&

-- | Infix notation for the type of a named parameter.
type (:!) (name :: Symbol) a = NamedF Identity a name

-- | Infix notation for the type of an optional named parameter.
type (:?) (name :: Symbol) a = NamedF Maybe a name

-- | <a>arg</a> unwraps a named parameter with the specified name. One way
--   to use it is to match on arguments with <tt>-XViewPatterns</tt>:
--   
--   <pre>
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ...
--   </pre>
--   
--   This way, the names of parameters can be inferred from the patterns:
--   no type signature for <tt>fn</tt> is required. In case a type
--   signature for <tt>fn</tt> is provided, the parameters must come in the
--   same order:
--   
--   <pre>
--   fn :: "t" :! Integer -&gt; "f" :! Integer -&gt; ...
--   fn (arg #t -&gt; t) (arg #f -&gt; f) = ... -- ok
--   fn (arg #f -&gt; f) (arg #t -&gt; t) = ... -- does not typecheck
--   </pre>
arg :: () => Name name -> (name :! a) -> a

-- | A variation of <a>arg</a> for optional arguments. Requires a default
--   value to handle the case when the optional argument was omitted:
--   
--   <pre>
--   fn (argDef #answer 42 -&gt; ans) = ...
--   </pre>
--   
--   In case you want to get a value wrapped in <a>Maybe</a> instead, use
--   <a>argF</a> or <a>ArgF</a>.
argDef :: () => Name name -> a -> (name :? a) -> a

-- | <a>argF</a> is similar to <a>arg</a>: it unwraps a named parameter
--   with the specified name. The difference is that the result of
--   <a>argF</a> is inside an arity wrapper, which is <a>Identity</a> for
--   normal parameters and <a>Maybe</a> for optional parameters.
argF :: () => Name name -> NamedF f a name -> f a
instance (name Data.Type.Equality.~ GHC.TypeLits.AppendSymbol "c" ctor, body Data.Type.Equality.~ (Michelson.Typed.Haskell.Instr.Sum.AppendCtorField x inp Lorentz.Base.:-> out)) => Lorentz.ADT.CaseArrow name body (Lorentz.ADT.CaseClauseL inp out ('Michelson.Typed.Haskell.Instr.Sum.CaseClauseParam ctor x))


-- | Utilities for declaring and documenting entry points.
module Lorentz.EntryPoints

-- | Gathers information about single entry point.
--   
--   We assume that entry points might be of different kinds, which is
--   designated by phantom type parameter. For instance, you may want to
--   have several groups of entry points corresponding to various parts of
--   a contract - specifying different <tt>kind</tt> type argument for each
--   of those groups will allow you defining different <a>DocItem</a>
--   instances with appropriate custom descriptions for them.
data DEntryPoint (kind :: Type)
DEntryPoint :: Text -> DocBlock -> DEntryPoint

-- | Default value for <a>DEntryPoint</a> type argument.
data PlainEntryPointsKind

-- | Default implementation of <a>docItemToMarkdown</a> for entry points.
diEntryPointToMarkdown :: HeaderLevel -> DEntryPoint level -> Builder

-- | Describes argument of an entry point.
data DEntryPointArg
DEntryPointArg :: Maybe DType -> [ParamBuildingStep] -> DEntryPointArg

-- | Argument of the entry point. Pass <a>Nothing</a> if no argument is
--   required.
[epaArg] :: DEntryPointArg -> Maybe DType

-- | Describes a way to lift an entry point argument into full parameter
--   which can be passed to the contract.
--   
--   Steps are supposed to be applied in the order in which they are given.
--   E.g. suppose that an entry point is called as <tt>Run (Service1
--   arg)</tt>; then the first step should describe wrapping into
--   <tt>Service1</tt> constructor, and the second step should be about
--   wrapping into <tt>Run</tt> constructor.
[epaBuilding] :: DEntryPointArg -> [ParamBuildingStep]

-- | Pick a type documentation from <a>CtorField</a>.
class DeriveCtorFieldDoc (cf :: CtorField)
deriveCtorFieldDoc :: DeriveCtorFieldDoc cf => Maybe DType

-- | Describes a parameter building step.
--   
--   This can be wrapping into (Haskell) constructor, or a more complex
--   transformation.
data ParamBuildingStep
ParamBuildingStep :: Builder -> (CurrentParam -> Builder) -> (CurrentParam -> Builder) -> ParamBuildingStep

-- | Plain english description of this step.
[pbsEnglish] :: ParamBuildingStep -> Builder

-- | How to construct parameter in Haskell code.
[pbsHaskell] :: ParamBuildingStep -> CurrentParam -> Builder

-- | How to construct parameter working on raw Michelson.
[pbsMichelson] :: ParamBuildingStep -> CurrentParam -> Builder

-- | Go over contract code and update every occurrence of
--   <a>DEntryPointArg</a> documentation item, adding the given step to its
--   "how to build parameter" description.
clarifyParamBuildingSteps :: ParamBuildingStep -> (inp :-> out) -> inp :-> out

-- | Like <a>caseT</a>, to be used for pattern-matching on parameter.
--   
--   Modifies documentation accordingly. Including description of
--   entrypoints' arguments, thus for them you will need to supply
--   <a>TypeHasDoc</a> instance.
entryCase :: forall dt entryPointKind out inp clauses. (CaseTC dt out inp clauses, DocumentEntryPoints entryPointKind dt) => Proxy entryPointKind -> IsoRecTuple clauses -> (dt & inp) :-> out
instance Lorentz.EntryPoints.GDocumentEntryPoints kind x => Lorentz.EntryPoints.GDocumentEntryPoints kind (GHC.Generics.D1 i x)
instance (Lorentz.EntryPoints.GDocumentEntryPoints kind x, Lorentz.EntryPoints.GDocumentEntryPoints kind y, Michelson.Typed.Haskell.Instr.Helpers.RSplit (Michelson.Typed.Haskell.Instr.Sum.GCaseClauses x) (Michelson.Typed.Haskell.Instr.Sum.GCaseClauses y)) => Lorentz.EntryPoints.GDocumentEntryPoints kind (x GHC.Generics.:+: y)
instance ('Michelson.Typed.Haskell.Instr.Sum.CaseClauseParam ctor cf Data.Type.Equality.~ Michelson.Typed.Haskell.Instr.Sum.GCaseBranchInput ctor x, GHC.TypeLits.KnownSymbol ctor, Michelson.Typed.Doc.DocItem (Lorentz.EntryPoints.DEntryPoint kind), Lorentz.EntryPoints.DeriveCtorFieldDoc cf) => Lorentz.EntryPoints.GDocumentEntryPoints kind (GHC.Generics.C1 ('GHC.Generics.MetaCons ctor _1 _2) x)
instance Lorentz.EntryPoints.DeriveCtorFieldDoc 'Michelson.Typed.Haskell.Instr.Sum.NoFields
instance Michelson.Typed.Haskell.Doc.TypeHasDoc ty => Lorentz.EntryPoints.DeriveCtorFieldDoc ('Michelson.Typed.Haskell.Instr.Sum.OneField ty)
instance Michelson.Typed.Doc.DocItem Lorentz.EntryPoints.DEntryPointArg
instance Michelson.Typed.Doc.DocItem (Lorentz.EntryPoints.DEntryPoint Lorentz.EntryPoints.PlainEntryPointsKind)


-- | Utility for <a>Typeable</a>.
module Util.Typeable

-- | Like <a>gcast</a>, casts some container's elements, producing
--   informative error on mismatch.
gcastE :: forall a b t. (Typeable a, Typeable b) => t a -> Either Text (t b)


-- | Advanced errors.
module Lorentz.Errors

-- | Haskell type representing error.
class IsError e

-- | Converts a Haskell error into <tt>Value</tt> representation.
errorToVal :: IsError e => e -> (forall t. KnownErrorT t => Value t -> r) -> r

-- | Converts a <tt>Value</tt> into Haskell error.
errorFromVal :: (IsError e, Typeable t, SingI t) => Value t -> Either Text e

-- | Implementation of <a>errorToVal</a> for custom errors.
customErrorToVal :: (LooseSumC e, HasCallStack) => e -> (forall t. KnownErrorT t => Value t -> r) -> r

-- | Implementation of <a>errorFromVal</a> for custom errors.
customErrorFromVal :: forall t e. (SingI t, LooseSumC e) => Value t -> Either Text e
type family CustomErrorNoIsoValue a

-- | Derive <a>IsError</a> instance for given type.
--   
--   This will also forbid deriving <a>IsoValue</a> instance for that type
--   to avoid having multiple different Michelson representations.
deriveCustomError :: Name -> Q [Dec]

-- | Use this type as replacement for <tt>()</tt> when you <b>really</b>
--   want to leave error cause unspecified.
data UnspecifiedError
UnspecifiedError :: UnspecifiedError

-- | Fail with the given Haskell value.
failUsing :: IsError e => e -> s :-> t

-- | Fail with given error, picking argument for error from the top of the
--   stack.
--   
--   If your error constructor does not carry an argument, use
--   <a>failUsing</a> function instead. Consider the following practice:
--   once error datatype for your contract is defined, create a
--   specialization of this function to the error type.
failUsingArg :: forall err name fieldTy s s'. FailUsingArg err name fieldTy s s'

-- | Signature of <tt>userFailWith</tt>.
type FailUsingArg e name fieldTy s s' = (KnownSymbol name, IsError e, CtorHasOnlyField name e fieldTy, Each [Typeable, SingI] '[ToT fieldTy], HasCallStack) => Label name -> fieldTy : s :-> s'

-- | Fail, providing a reference to the place in the code where this
--   function is called.
--   
--   Like <a>error</a> in Haskell code, this instruction is for internal
--   errors only.
failUnexpected :: HasCallStack => MText -> s :-> t
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Errors.UnspecifiedError
instance GHC.Generics.Generic Lorentz.Errors.UnspecifiedError
instance Lorentz.Errors.IsError Lorentz.Errors.UnspecifiedError
instance Lorentz.Errors.IsError Michelson.Text.MText
instance (TypeError ...) => Lorentz.Errors.IsError ()


-- | Common Michelson macros defined using Lorentz syntax.
module Lorentz.Macro
type IfCmpXConstraints a op = (Typeable a, ArithOpHs Compare a a, UnaryArithOpHs op (ArithResHs Compare a a), UnaryArithResHs op (ArithResHs Compare a a) ~ Bool)
eq :: (ArithOpHs Compare n n, UnaryArithOpHs Eq' (ArithResHs Compare n n)) => (n & (n & s)) :-> (UnaryArithResHs Eq' (ArithResHs Compare n n) & s)
neq :: (ArithOpHs Compare n n, UnaryArithOpHs Neq (ArithResHs Compare n n)) => (n & (n & s)) :-> (UnaryArithResHs Neq (ArithResHs Compare n n) & s)
lt :: (ArithOpHs Compare n n, UnaryArithOpHs Lt (ArithResHs Compare n n)) => (n & (n & s)) :-> (UnaryArithResHs Lt (ArithResHs Compare n n) & s)
gt :: (ArithOpHs Compare n n, UnaryArithOpHs Gt (ArithResHs Compare n n)) => (n & (n & s)) :-> (UnaryArithResHs Gt (ArithResHs Compare n n) & s)
le :: (ArithOpHs Compare n n, UnaryArithOpHs Le (ArithResHs Compare n n)) => (n & (n & s)) :-> (UnaryArithResHs Le (ArithResHs Compare n n) & s)
ge :: (ArithOpHs Compare n n, UnaryArithOpHs Ge (ArithResHs Compare n n)) => (n & (n & s)) :-> (UnaryArithResHs Ge (ArithResHs Compare n n) & s)
ifEq0 :: IfCmp0Constraints a Eq' => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifGe0 :: IfCmp0Constraints a Ge => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifGt0 :: IfCmp0Constraints a Gt => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifLe0 :: IfCmp0Constraints a Le => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifLt0 :: IfCmp0Constraints a Lt => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifNeq0 :: IfCmp0Constraints a Neq => (s :-> s') -> (s :-> s') -> (a & s) :-> s'
ifEq :: IfCmpXConstraints a Eq' => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifGe :: IfCmpXConstraints a Ge => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifGt :: IfCmpXConstraints a Gt => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifLe :: IfCmpXConstraints a Le => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifLt :: IfCmpXConstraints a Lt => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'
ifNeq :: IfCmpXConstraints a Neq => (s :-> s') -> (s :-> s') -> (a & (a & s)) :-> s'

-- | Analog of the FAIL macro in Michelson. Its usage is discouraged
--   because it doesn't carry any information about failure.

-- | <i>Warning: <a>fail_</a> remains in code</i>
fail_ :: a :-> c
assert :: IsError err => err -> (Bool & s) :-> s
assertEq0 :: (IfCmp0Constraints a Eq', IsError err) => err -> (a & s) :-> s
assertNeq0 :: (IfCmp0Constraints a Neq, IsError err) => err -> (a & s) :-> s
assertLt0 :: (IfCmp0Constraints a Lt, IsError err) => err -> (a & s) :-> s
assertGt0 :: (IfCmp0Constraints a Gt, IsError err) => err -> (a & s) :-> s
assertLe0 :: (IfCmp0Constraints a Le, IsError err) => err -> (a & s) :-> s
assertGe0 :: (IfCmp0Constraints a Ge, IsError err) => err -> (a & s) :-> s
assertEq :: (IfCmpXConstraints a Eq', IsError err) => err -> (a & (a & s)) :-> s
assertNeq :: (IfCmpXConstraints a Neq, IsError err) => err -> (a & (a & s)) :-> s
assertLt :: (IfCmpXConstraints a Lt, IsError err) => err -> (a & (a & s)) :-> s
assertGt :: (IfCmpXConstraints a Gt, IsError err) => err -> (a & (a & s)) :-> s
assertLe :: (IfCmpXConstraints a Le, IsError err) => err -> (a & (a & s)) :-> s
assertGe :: (IfCmpXConstraints a Ge, IsError err) => err -> (a & (a & s)) :-> s
assertNone :: IsError err => err -> (Maybe a & s) :-> s
assertSome :: IsError err => err -> (Maybe a & s) :-> (a & s)
assertLeft :: IsError err => err -> (Either a b & s) :-> (a & s)
assertRight :: IsError err => err -> (Either a b & s) :-> (b & s)
assertUsing :: IsError a => a -> (Bool & s) :-> s

-- | <tt>DII+P</tt> macro. For example, `dipX @3` is <tt>DIIIP</tt>.
dipX :: forall (n :: Nat) inp out s s'. (DipX (ToPeano n) (Above (ToPeano n) inp) s s', (Above (ToPeano n) inp ++ s) ~ inp, (Above (ToPeano n) inp ++ s') ~ out) => (s :-> s') -> inp :-> out

-- | Custom Lorentz macro that drops element with given index (starting
--   from 0) from the stack.
dropX :: forall (n :: Nat) a inp out s s'. (DipX (ToPeano n) (Above (ToPeano n) inp) s s', (Above (ToPeano n) inp ++ s) ~ inp, (Above (ToPeano n) inp ++ s') ~ out, s ~ (a : s')) => inp :-> out

-- | Duplicate the top of the stack <tt>n</tt> times.
--   
--   For example, `cloneX @3` has type `a &amp; s :-&gt; a &amp; a &amp; a
--   &amp; a &amp; s`.
cloneX :: forall (n :: Nat) a s. CloneX (ToPeano n) a s => (a & s) :-> CloneXT (ToPeano n) a s

-- | <tt>DUU+P</tt> macro. For example, `duupX @3` is <tt>DUUUP</tt>, it
--   puts the 3-rd (starting from 1) element to the top of the stack.
duupX :: forall (n :: Nat) inp. DuupX (ToPeano n) inp (At (ToPeano (n - 1)) inp) => inp :-> (At (ToPeano (n - 1)) inp & inp)

-- | Move item with given index (starting from 0) to the top of the stack.
--   
--   TODO: probably it can be implemented more efficiently, so if we ever
--   want to optimize gas consumption we can rewrite it. It only makes
--   sense if it's applied to a relatively large index.
elevateX :: forall (n :: Nat) inp out s a. (DuupX (ToPeano (1 + n)) inp a, DipX (ToPeano (n + 1)) (Above (ToPeano (n + 1)) (a : inp)) (a : s) s, (a : (Above (ToPeano n) inp ++ s)) ~ out, a ~ At (ToPeano n) inp, (Above (ToPeano (n + 1)) (a : inp) ++ (a : s)) ~ (a : inp), (Above (ToPeano (n + 1)) (a : inp) ++ s) ~ (a : (Above (ToPeano n) inp ++ s)), ((1 + n) - 1) ~ n) => inp :-> out
caar :: (((a, b1), b2) & s) :-> (a & s)
cadr :: (((a, b1), b2) & s) :-> (b1 & s)
cdar :: ((a1, (a2, b)) & s) :-> (a2 & s)
cddr :: ((a1, (a2, b)) & s) :-> (b & s)
ifRight :: ((b & s) :-> s') -> ((a & s) :-> s') -> (Either a b & s) :-> s'
ifSome :: ((a & s) :-> s') -> (s :-> s') -> (Maybe a & s) :-> s'
mapCar :: ((a & s) :-> (a1 & s)) -> ((a, b) & s) :-> ((a1, b) & s)
mapCdr :: ((b & ((a, b) & s)) :-> (b1 & ((a, b) & s))) -> ((a, b) & s) :-> ((a, b1) & s)
papair :: (a & (b & (c & s))) :-> (((a, b), c) & s)
ppaiir :: (a & (b & (c & s))) :-> ((a, (b, c)) & s)
unpair :: ((a, b) & s) :-> (a & (b & s))
setCar :: ((a, b1) & (b2 & s)) :-> ((b2, b1) & s)
setCdr :: ((a, b1) & (b2 & s)) :-> ((a, b2) & s)

-- | Insert given element into set.
--   
--   This is a separate function from <tt>updateMap</tt> because stacks
--   they operate with differ in length.
setInsert :: IsComparable e => (e & (Set e & s)) :-> (Set e & s)

-- | Insert given element into map.
mapInsert :: (MapInstrs map, IsComparable k) => (k : (v : (map k v : s))) :-> (map k v : s)

-- | Insert given element into set, ensuring that it does not overwrite any
--   existing entry.
--   
--   As first argument accepts container name.
setInsertNew :: (IsComparable e, KnownValue err) => (forall s0. (e : s0) :-> (err : s0)) -> (e & (Set e & s)) :-> (Set e & s)

-- | Insert given element into map, ensuring that it does not overwrite any
--   existing entry.
--   
--   As first argument accepts container name (for error message).
mapInsertNew :: (MapInstrs map, IsComparable k, KnownValue e) => (forall s0. (k : s0) :-> (e : s0)) -> (k : (v : (map k v : s))) :-> (map k v : s)

-- | Delete element from the map.
deleteMap :: forall k v s. (MapInstrs map, IsComparable k, KnownValue k, KnownValue v) => (k : (map k v : s)) :-> (map k v : s)

-- | Delete given element from the set.
setDelete :: IsComparable e => (e & (Set e & s)) :-> (Set e & s)

-- | <tt>view</tt> type synonym as described in A1.
data View (a :: Type) (r :: Type)
View :: a -> ContractAddr r -> View
[viewParam] :: View -> a
[viewCallbackTo] :: View -> ContractAddr r

-- | <tt>void</tt> type synonym as described in A1.
data Void_ (a :: Type) (b :: Type)
Void_ :: a -> Lambda b b -> Void_

-- | Entry point argument.
[voidParam] :: Void_ -> a

-- | Type of result reported via <a>failWith</a>.
[voidResProxy] :: Void_ -> Lambda b b

-- | Newtype over void result type used in tests to distinguish successful
--   void result from other errors.
--   
--   Usage example: lExpectFailWith (== VoidResult roleMaster)`
newtype VoidResult r
VoidResult :: r -> VoidResult r
[unVoidResult] :: VoidResult r -> r
view_ :: (KnownValue r, NoOperation r, NoBigMap r) => (forall s0. ((a, storage) & s0) :-> (r : s0)) -> (View a r & (storage & s)) :-> ((List Operation, storage) & s)
void_ :: forall a b s s' anything. (Typeable b, IsoValue b, KnownValue b) => ((a & s) :-> (b & s')) -> (Void_ a b & s) :-> anything
mkVoid :: forall b a. a -> Void_ a b
instance GHC.Classes.Eq r => GHC.Classes.Eq (Lorentz.Macro.VoidResult r)
instance GHC.Generics.Generic (Lorentz.Macro.VoidResult r)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Macro.Void_ a b)
instance GHC.Generics.Generic (Lorentz.Macro.Void_ a b)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Macro.View a r)
instance GHC.Generics.Generic (Lorentz.Macro.View a r)
instance (Data.Typeable.Internal.Typeable r, Michelson.Typed.Haskell.Value.IsoValue r, Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Data.Singletons.Internal.SingI] '[Michelson.Typed.Haskell.Value.ToT r]) => Lorentz.Errors.IsError (Lorentz.Macro.VoidResult r)
instance Lorentz.Errors.CustomErrorNoIsoValue (Lorentz.Macro.VoidResult r) => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Macro.VoidResult r)
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Michelson.Typed.Haskell.Doc.TypeHasDoc] '[a, r] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Macro.Void_ a r)
instance Universum.TypeOps.Each '[Data.Typeable.Internal.Typeable, Michelson.Typed.Haskell.Doc.TypeHasDoc] '[a, r] => Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Macro.View a r)
instance Lorentz.Macro.MapInstrs Data.Map.Internal.Map
instance Lorentz.Macro.MapInstrs Michelson.Typed.Haskell.Value.BigMap
instance Lorentz.Macro.DuupX ('Data.Vinyl.TypeLevel.S 'Data.Vinyl.TypeLevel.Z) (a Lorentz.Base.& xs) a
instance Lorentz.Macro.DuupX ('Data.Vinyl.TypeLevel.S n) xs a => Lorentz.Macro.DuupX ('Data.Vinyl.TypeLevel.S ('Data.Vinyl.TypeLevel.S n)) (x Lorentz.Base.& xs) a
instance Lorentz.Macro.CloneX 'Data.Vinyl.TypeLevel.Z a s
instance Lorentz.Macro.CloneX n a s => Lorentz.Macro.CloneX ('Data.Vinyl.TypeLevel.S n) a s
instance Lorentz.Macro.DipX 'Data.Vinyl.TypeLevel.Z '[] s s'
instance Lorentz.Macro.DipX n h s s' => Lorentz.Macro.DipX ('Data.Vinyl.TypeLevel.S n) (a : h) s s'


-- | Instructions to work with <a>UStore</a>.
module Lorentz.UStore.Instr
ustoreMem :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Bool : s)
ustoreGet :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Maybe (GetUStoreValue store name) : s)
ustoreUpdate :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (Maybe (GetUStoreValue store name) : (UStore store : s))) :-> (UStore store : s)
ustoreInsert :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
ustoreInsertNew :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (forall s0 any. (GetUStoreKey store name : s0) :-> any) -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreDelete :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (UStore store : s)

-- | Like <tt>toField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreToField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : s)

-- | Like <tt>getField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreGetField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : (UStore store : s))

-- | Like <tt>setField</tt>, but for <a>UStore</a>.
ustoreSetField :: forall store name s. FieldAccessC store name => Label name -> (GetUStoreField store name : (UStore store : s)) :-> (UStore store : s)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some submap(s) of it.
--   
--   It can use all UStore operations for a particular name, key and value
--   without knowing whole template.
type HasUStore name key value store = (KeyAccessC store name, ValueAccessC store name, GetUStoreKey store name ~ key, GetUStoreValue store name ~ value)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some field of it.
type HasUField name ty store = (FieldAccessC store name, GetUStoreField store name ~ ty)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|~&gt;</a> and <a>UStoreField</a> fields in
--   its immediate fields, no deep inspection is performed.
type HasUStoreForAllIn store constrained = (Generic store, GHasStoreForAllIn constrained (Rep store))
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplate3
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.UStore.Instr.MyNatural
instance Michelson.Typed.Haskell.Value.IsoCValue Lorentz.UStore.Instr.MyNatural
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplate2
instance GHC.Generics.Generic Lorentz.UStore.Instr.MyStoreTemplate


-- | This module contains implementation of <a>UStore</a>.
--   
--   <tt>UStore</tt> is essentially <a>Store</a> modified for the sake of
--   upgradeability.
--   
--   In API it differs from <tt>Store</tt> in the following ways: 1. It
--   keeps both virtual <tt>big_map</tt>s and plain fields; 2. Neat
--   conversion between Michelson and Haskell values is implemented; 3.
--   Regarding composabililty, one can operate with one <tt>UStore</tt> and
--   then lift it to a bigger one which includes the former. This allows
--   for simpler management of stores and clearer error messages. In spite
--   of this, operations with <a>UStore</a>s over deeply nested templates
--   will still work as before.
--   
--   We represent <a>UStore</a> as <tt>big_map bytes bytes</tt>.
--   
--   <ul>
--   <li>Plain fields are stored as <tt>key = pack fieldName; value = pack
--   originalValue</tt>.</li>
--   <li>Virtual <tt>big_map</tt>s are kept as <tt>key = pack (bigMapName,
--   originalKey); value = pack originalValue</tt>.</li>
--   </ul>
module Lorentz.UStore

-- | Gathers multple fields and <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "store template" - a
--   datatype with one constructor and multiple fields, each containing an
--   object of type <a>UStoreField</a> or <a>|~&gt;</a> and corresponding
--   to single virtual field or <a>BigMap</a> respectively. It's also
--   possible to parameterize it with a larger type which is a product of
--   types satisfying the above property.
--   
--   Inside it keeps only one <a>BigMap</a> thus not violating Michelson
--   limitations.
data UStore a

-- | Describes one virtual big map in the storage.
newtype k |~> v
UStoreSubMap :: Map k v -> (|~>) k v
[unUStoreSubMap] :: (|~>) k v -> Map k v
newtype UStoreField v
UStoreField :: v -> UStoreField v
[unUStoreField] :: UStoreField v -> v

-- | Get type of submap key.
type GetUStoreKey store name = MSKey (GetUStore name store)

-- | Get type of submap value.
type GetUStoreValue store name = MSValue (GetUStore name store)

-- | Get type of plain field.
type GetUStoreField store name = FSValue (GetUStore name store)
ustoreMem :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Bool : s)
ustoreGet :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (Maybe (GetUStoreValue store name) : s)
ustoreUpdate :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (Maybe (GetUStoreValue store name) : (UStore store : s))) :-> (UStore store : s)
ustoreInsert :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
ustoreInsertNew :: forall store name s. (KeyAccessC store name, ValueAccessC store name) => Label name -> (forall s0 any. (GetUStoreKey store name : s0) :-> any) -> (GetUStoreKey store name : (GetUStoreValue store name : (UStore store : s))) :-> (UStore store : s)
ustoreDelete :: forall store name s. KeyAccessC store name => Label name -> (GetUStoreKey store name : (UStore store : s)) :-> (UStore store : s)

-- | Like <tt>toField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreToField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : s)

-- | Like <tt>getField</tt>, but for <a>UStore</a>.
--   
--   This may fail only if <a>UStore</a> was made up incorrectly during
--   contract initialization.
ustoreGetField :: forall store name s. FieldAccessC store name => Label name -> (UStore store : s) :-> (GetUStoreField store name : (UStore store : s))

-- | Like <tt>setField</tt>, but for <a>UStore</a>.
ustoreSetField :: forall store name s. FieldAccessC store name => Label name -> (GetUStoreField store name : (UStore store : s)) :-> (UStore store : s)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some submap(s) of it.
--   
--   It can use all UStore operations for a particular name, key and value
--   without knowing whole template.
type HasUStore name key value store = (KeyAccessC store name, ValueAccessC store name, GetUStoreKey store name ~ key, GetUStoreValue store name ~ value)

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some field of it.
type HasUField name ty store = (FieldAccessC store name, GetUStoreField store name ~ ty)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|~&gt;</a> and <a>UStoreField</a> fields in
--   its immediate fields, no deep inspection is performed.
type HasUStoreForAllIn store constrained = (Generic store, GHasStoreForAllIn constrained (Rep store))

-- | Lift an <a>UStore</a> to another <a>UStore</a> which contains all the
--   entries of the former under given field.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Note that this function ensures that template of resulting store does
--   not contain inner nested templates with duplicated fields, otherwise
--   <a>UStore</a> invariants could get broken.
liftUStore :: (Generic template, RequireAllUniqueFields template) => Label name -> (UStore (GetFieldType template name) : s) :-> (UStore template : s)

-- | Unlift an <a>UStore</a> to a smaller <a>UStore</a> which is part of
--   the former.
--   
--   This function is not intended for use in migrations, only in normal
--   entry points.
--   
--   Surprisingly, despite smaller <a>UStore</a> may have extra entries,
--   this function is safe when used in contract code. Truly, all getters
--   and setters are still safe to use. Also, there is no way for the
--   resulting small <tt>UStore</tt> to leak outside of the contract since
--   the only place where <tt>big_map</tt> can appear is contract storage,
--   so this small <tt>UStore</tt> can be either dropped or lifted back via
--   <a>liftUStore</a> to appear as part of the new contract's state.
--   
--   When this function is run as part of standalone instructions sequence,
--   not as part of contract code (e.g. in tests), you may get an
--   <tt>UStore</tt> with entries not inherent to it.
unliftUStore :: Generic template => Label name -> (UStore template : s) :-> (UStore (GetFieldType template name) : s)

-- | Given template can be converted to <a>UStore</a> value.
class GUStoreConversible (Rep template) => UStoreConversible template

-- | Make <a>UStore</a> from separate <tt>big_map</tt>s and fields.
mkUStore :: (Generic template, UStoreConversible template) => template -> UStore template

-- | Decompose <a>UStore</a> into separate <tt>big_map</tt>s and fields.
--   
--   Since this function needs to <tt>UNPACK</tt> content of
--   <tt>UStore</tt> to actual keys and values, you have to provide
--   <a>UnpackEnv</a>.
--   
--   Along with resulting value, you get a list of <tt>UStore</tt> entries
--   which were not recognized as belonging to any submap or field
--   according to <tt>UStore</tt>'s template - this should be empty unless
--   <tt>UStore</tt> invariants were violated.
ustoreDecompose :: forall template. (Generic template, UStoreConversible template) => UnpackEnv -> UStore template -> Either Text (UStoreContent, template)

-- | Like <a>ustoreDecompose</a>, but requires all entries from
--   <tt>UStore</tt> to be recognized.
ustoreDecomposeFull :: forall template. (Generic template, UStoreConversible template) => UnpackEnv -> UStore template -> Either Text template

module Lorentz.UParam

-- | Encapsulates parameter for one of entry points. It keeps entry point
--   name and corresponding argument serialized.
--   
--   In Haskell world, we keep an invariant of that contained value relates
--   to one of entry points from <tt>entries</tt> list.
newtype UParam (entries :: [EntryPointKind])
UParamUnsafe :: (MText, ByteString) -> UParam

-- | An entry point is described by two types: its name and type of
--   argument.
type EntryPointKind = (Symbol, Type)

-- | A convenient alias for type-level name-something pair.
type (n :: Symbol) ?: (a :: k) = '(n, a)

-- | Construct a <a>UParam</a> safely.
mkUParam :: (KnownSymbol name, IsoValue a, KnownValue a, NoOperation a, NoBigMap a, LookupEntryPoint name entries ~ a, RequireUniqueEntryPoints entries) => Label name -> a -> UParam entries

-- | This type can store any value that satisfies a certain constraint.
data ConstrainedSome (c :: Type -> Constraint)
[ConstrainedSome] :: c a => a -> ConstrainedSome c

-- | This class is needed to implement <a>unpackUParam</a>.
class UnpackUParam (c :: Type -> Constraint) entries

-- | Turn <a>UParam</a> into a Haskell value. Since we don't know its type
--   in compile time, we have to erase it using <a>ConstrainedSome</a>. The
--   user of this function can require arbitrary constraint to hold
--   (depending on how they want to use the result).
unpackUParam :: UnpackUParam c entries => UParam entries -> Either EntryPointLookupError (MText, ConstrainedSome c)

-- | Implementations of some entry points.
--   
--   Note that this thing inherits properties of <a>Rec</a>, e.g. you can
--   <tt>Data.Vinyl.Core.rappend</tt> implementations for two entry point
--   sets when assembling scattered parts of a contract.
type EntryPointsImpl inp out entries = Rec (CaseClauseU inp out) entries

-- | An action invoked when user-provided entry point is not found.
type UParamFallback inp out = ((MText, ByteString) : inp) :-> out

-- | Errors related to entry point lookup.
data EntryPointLookupError
NoSuchEntryPoint :: MText -> EntryPointLookupError
ArgumentUnpackFailed :: EntryPointLookupError

-- | Make up a "case" over entry points.
class CaseUParam (entries :: [EntryPointKind])

-- | Pattern-match on given <tt>UParam entries</tt>.
--   
--   You have to provide all case branches and a fallback action on case
--   when entry point is not found.
caseUParam :: (CaseUParam entries, RequireUniqueEntryPoints entries) => Rec (CaseClauseU inp out) entries -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Like <a>caseUParam</a>, but accepts a tuple of clauses, not a
--   <a>Rec</a>.
caseUParamT :: (clauses ~ Rec (CaseClauseU inp out) entries, RecFromTuple clauses, CaseUParam entries) => IsoRecTuple clauses -> UParamFallback inp out -> (UParam entries : inp) :-> out

-- | Default implementation for <a>UParamFallback</a>, simply reports an
--   error.
uparamFallbackFail :: UParamFallback inp out

-- | Get type of entry point argument by its name.
type family LookupEntryPoint (name :: Symbol) (entries :: [EntryPointKind]) :: Type

-- | Ensure that given entry points do no contain duplicated names.
type family RequireUniqueEntryPoints (entries :: [EntryPointKind]) :: Constraint

-- | Make up <a>UParam</a> from ADT sum.
--   
--   Entry points template will consist of <tt>(constructorName,
--   constructorFieldType)</tt> pairs. Each constructor is expected to have
--   exactly one field.
uparamFromAdt :: UParamLinearize up => up -> UParam (UParamLinearized up)

-- | Constraint required by <a>uparamFromAdt</a>.
type UParamLinearize p = (Generic p, GUParamLinearize (Rep p))

-- | Entry points template derived from given ADT sum.
type UParamLinearized p = GUParamLinearized (Rep p)

-- | Helper instruction which extracts content of <a>UParam</a>.
unwrapUParam :: (UParam entries : s) :-> ((MText, ByteString) : s)
instance Lorentz.UParam.GUParamLinearize x => Lorentz.UParam.GUParamLinearize (GHC.Generics.D1 i x)
instance (Lorentz.UParam.GUParamLinearize x, Lorentz.UParam.GUParamLinearize y) => Lorentz.UParam.GUParamLinearize (x GHC.Generics.:+: y)
instance (GHC.TypeLits.KnownSymbol name, Michelson.Typed.Haskell.Value.IsoValue a, Lorentz.Constraints.KnownValue a, Lorentz.Constraints.NoOperation a, Lorentz.Constraints.NoBigMap a) => Lorentz.UParam.GUParamLinearize (GHC.Generics.C1 ('GHC.Generics.MetaCons name _1 _2) (GHC.Generics.S1 si (GHC.Generics.Rec0 a)))
instance (TypeError ...) => Lorentz.UParam.GUParamLinearize (GHC.Generics.C1 i GHC.Generics.U1)
instance (TypeError ...) => Lorentz.UParam.GUParamLinearize (GHC.Generics.C1 i (x GHC.Generics.:*: y))
instance Lorentz.UParam.CaseUParam '[]
instance (GHC.TypeLits.KnownSymbol name, Lorentz.UParam.CaseUParam entries, Lorentz.Constraints.KnownValue arg, Lorentz.Constraints.NoOperation arg, Lorentz.Constraints.NoBigMap arg) => Lorentz.UParam.CaseUParam ((name Lorentz.UParam.?: arg) : entries)
instance Lorentz.Errors.IsError Lorentz.UParam.EntryPointLookupError
instance Lorentz.Errors.CustomErrorNoIsoValue Lorentz.UParam.EntryPointLookupError => Michelson.Typed.Haskell.Value.IsoValue Lorentz.UParam.EntryPointLookupError
instance Formatting.Buildable.Buildable Lorentz.UParam.EntryPointLookupError
instance Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.UParam.UParam interface)
instance GHC.Show.Show Lorentz.UParam.EntryPointLookupError
instance GHC.Classes.Eq Lorentz.UParam.EntryPointLookupError
instance GHC.Generics.Generic Lorentz.UParam.EntryPointLookupError
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.UParam.UParam entries)
instance GHC.Show.Show (Lorentz.UParam.UParam entries)
instance GHC.Classes.Eq (Lorentz.UParam.UParam entries)
instance GHC.Generics.Generic (Lorentz.UParam.UParam entries)
instance Lorentz.UParam.UnpackUParam c '[]
instance (GHC.TypeLits.KnownSymbol name, Lorentz.UParam.UnpackUParam c entries, Michelson.Typed.Haskell.Value.IsoValue arg, Lorentz.Constraints.KnownValue arg, Lorentz.Constraints.NoOperation arg, Lorentz.Constraints.NoBigMap arg, c arg) => Lorentz.UParam.UnpackUParam c ((name Lorentz.UParam.?: arg) : entries)
instance (name Data.Type.Equality.~ name', body Data.Type.Equality.~ ((arg : inp) Lorentz.Base.:-> out)) => Lorentz.ADT.CaseArrow name' body (Lorentz.UParam.CaseClauseU inp out '(name, arg))
instance GHC.Show.Show (Lorentz.UParam.ConstrainedSome GHC.Show.Show)
instance Formatting.Buildable.Buildable (Lorentz.UParam.ConstrainedSome Formatting.Buildable.Buildable)


-- | Impementation of <tt>Store</tt> - object incapsulating multiple
--   <a>BigMap</a>s.
--   
--   This module also provides template for the contract storage -
--   <a>StorageSkeleton</a>.
--   
--   We represent <a>Store</a> as <tt>big_map bytes (a | b | ...)</tt>.
--   
--   Key of this map is formed as <tt>(index, orig_key)</tt>, where
--   <tt>index</tt> is zero-based index of emulated map, <tt>orig_key</tt>
--   is key of this emulated map.
--   
--   Value of this map is just a union of emulated map's values.
module Lorentz.Store

-- | Gathers multple <a>BigMap</a>s under one object.
--   
--   Type argument of this datatype stands for a "map template" - a
--   datatype with multiple constructors, each containing an object of type
--   <a>|-&gt;</a> and corresponding to single virtual <a>BigMap</a>. It's
--   also possible to parameterize it with a larger type which is a sum of
--   types satisfying the above property.
--   
--   Inside it keeps only one <a>BigMap</a> thus not violating Michelson
--   limitations.
--   
--   See examples below.
newtype Store a
Store :: BigMap ByteString a -> Store a
[unStore] :: Store a -> BigMap ByteString a

-- | Describes one virtual big map.
data k |-> v
type GetStoreKey store name = MSKey (GetStore name store)
type GetStoreValue store name = MSValue (GetStore name store)
storeMem :: forall store name s. StoreMemC store name => Label name -> (GetStoreKey store name : (Store store : s)) :-> (Bool : s)
storeGet :: forall store name s. StoreGetC store name => Label name -> (GetStoreKey store name : (Store store : s)) :-> (Maybe (GetStoreValue store name) : s)
storeUpdate :: forall store name s. StoreUpdateC store name => Label name -> (GetStoreKey store name : (Maybe (GetStoreValue store name) : (Store store : s))) :-> (Store store : s)
storeInsert :: forall store name s. StoreInsertC store name => Label name -> (GetStoreKey store name : (GetStoreValue store name : (Store store : s))) :-> (Store store : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
storeInsertNew :: forall store name s. (StoreInsertC store name, KnownSymbol name) => Label name -> (forall s0 any. (GetStoreKey store name : s0) :-> any) -> (GetStoreKey store name : (GetStoreValue store name : (Store store : s))) :-> (Store store : s)
storeDelete :: forall store name s. StoreDeleteC store name => Label name -> (GetStoreKey store name : (Store store : s)) :-> (Store store : s)
type StoreMemC store name = StoreOpC store name
type StoreGetC store name = (StoreOpC store name, InstrUnwrapC store name, SingI (ToT (GetStoreValue store name)), CtorHasOnlyField name store (GetStoreKey store name |-> GetStoreValue store name))
type StoreUpdateC store name = (SingI (ToT store), StoreOpC store name, InstrWrapC store name, CtorHasOnlyField name store (GetStoreKey store name |-> GetStoreValue store name))
type StoreInsertC store name = (StoreOpC store name, InstrWrapC store name, CtorHasOnlyField name store (GetStoreKey store name |-> GetStoreValue store name))
type StoreDeleteC store name = (StoreOpC store name, SingI (ToT store))

-- | This constraint can be used if a function needs to work with
--   <i>big</i> store, but needs to know only about some part(s) of it.
--   
--   It can use all Store operations for a particular name, key and value
--   without knowing whole template.
type HasStore name key value store = (StoreGetC store name, StoreInsertC store name, StoreDeleteC store name, GetStoreKey store name ~ key, GetStoreValue store name ~ value, StorePieceC store name key value)

-- | Write down all sensisble constraints which given <tt>store</tt>
--   satisfies and apply them to <tt>constrained</tt>.
--   
--   This store should have <a>|-&gt;</a> datatype in its immediate fields,
--   no deep inspection is performed.
type HasStoreForAllIn store constrained = GForAllHasStore constrained (Rep store)

-- | Contract storage with <tt>big_map</tt>.
--   
--   Due to Michelson constraints it is the only possible layout containing
--   <tt>big_map</tt>.
data StorageSkeleton storeTemplate other
StorageSkeleton :: Store storeTemplate -> other -> StorageSkeleton storeTemplate other
[sMap] :: StorageSkeleton storeTemplate other -> Store storeTemplate
[sFields] :: StorageSkeleton storeTemplate other -> other

-- | Unpack <a>StorageSkeleton</a> into a pair.
storageUnpack :: (StorageSkeleton store fields : s) :-> ((Store store, fields) : s)

-- | Pack a pair into <a>StorageSkeleton</a>.
storagePack :: ((Store store, fields) : s) :-> (StorageSkeleton store fields : s)
storageMem :: forall store name fields s. StoreMemC store name => Label name -> (GetStoreKey store name : (StorageSkeleton store fields : s)) :-> (Bool : s)
storageGet :: forall store name fields s. StoreGetC store name => Label name -> (GetStoreKey store name : (StorageSkeleton store fields : s)) :-> (Maybe (GetStoreValue store name) : s)
storageInsert :: forall store name fields s. StoreInsertC store name => Label name -> (GetStoreKey store name : (GetStoreValue store name : (StorageSkeleton store fields : s))) :-> (StorageSkeleton store fields : s)

-- | Insert a key-value pair, but fail if it will overwrite some existing
--   entry.
storageInsertNew :: forall store name fields s. (StoreInsertC store name, KnownSymbol name) => Label name -> (forall s0 any. (GetStoreKey store name : s0) :-> any) -> (GetStoreKey store name : (GetStoreValue store name : (StorageSkeleton store fields : s))) :-> (StorageSkeleton store fields : s)
storageDelete :: forall store name fields s. StoreDeleteC store name => Label name -> (GetStoreKey store name : (StorageSkeleton store fields : s)) :-> (StorageSkeleton store fields : s)

-- | Lift a key-value pair to <a>Store</a>.
--   
--   Further you can use <a>Monoid</a> instance of <tt>Store</tt> to make
--   up large stores.
storePiece :: forall name store key value. StorePieceC store name key value => Label name -> key -> value -> Store store
storeKeyValueList :: forall name store key value. StorePieceC store name key value => Label name -> [(key, value)] -> Store store

-- | Get a value from store by key.
--   
--   It expects map to be consistent, otherwise call to this function fails
--   with error.
storeLookup :: forall name store key value ctorIdx. (key ~ GetStoreKey store name, value ~ GetStoreValue store name, ctorIdx ~ MSCtorIdx (GetStore name store), IsoValue key, KnownValue key, HasNoOp (ToT key), HasNoBigMap (ToT key), KnownNat ctorIdx, InstrUnwrapC store name, Generic store, CtorOnlyField name store ~ (key |-> value)) => Label name -> key -> Store store -> Maybe value
type StorePieceC store name key value = (key ~ GetStoreKey store name, value ~ GetStoreValue store name, IsoValue key, KnownValue key, HasNoOp (ToT key), HasNoBigMap (ToT key), KnownNat (MSCtorIdx (GetStore name store)), InstrWrapC store name, Generic store, ExtractCtorField (GetCtorField store name) ~ (key |-> value))
instance (Michelson.Typed.Haskell.Value.IsoValue storeTemplate, Michelson.Typed.Haskell.Value.IsoValue other) => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Store.StorageSkeleton storeTemplate other)
instance Data.Default.Class.Default other => Data.Default.Class.Default (Lorentz.Store.StorageSkeleton storeTemplate other)
instance GHC.Generics.Generic (Lorentz.Store.StorageSkeleton storeTemplate other)
instance (GHC.Show.Show storeTemplate, GHC.Show.Show other) => GHC.Show.Show (Lorentz.Store.StorageSkeleton storeTemplate other)
instance (GHC.Classes.Eq storeTemplate, GHC.Classes.Eq other) => GHC.Classes.Eq (Lorentz.Store.StorageSkeleton storeTemplate other)
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplateBig
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplateBig
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplate3
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplate3
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyNatural
instance Michelson.Typed.Haskell.Value.IsoCValue Lorentz.Store.MyNatural
instance GHC.Generics.Generic Lorentz.Store.MyNatural
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplate2
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplate2
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Store.MyStoreTemplate
instance GHC.Generics.Generic Lorentz.Store.MyStoreTemplate
instance forall k1 (k2 :: k1) v. Michelson.Typed.Haskell.Value.IsoValue v => Michelson.Typed.Haskell.Value.IsoValue (k2 Lorentz.Store.|-> v)
instance forall k1 (k2 :: k1) v. GHC.Generics.Generic (k2 Lorentz.Store.|-> v)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Store.Store a)
instance GHC.Base.Monoid (Lorentz.Store.Store a)
instance GHC.Base.Semigroup (Lorentz.Store.Store a)
instance Data.Default.Class.Default (Lorentz.Store.Store a)
instance GHC.Show.Show a => GHC.Show.Show (Lorentz.Store.Store a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lorentz.Store.Store a)


-- | Reimplementation of some syntax sugar.
--   
--   You need the following module pragmas to make it work smoothly:
module Lorentz.Rebinded

-- | Aliases for '(#)' used by do-blocks.
(>>) :: (a :-> b) -> (b :-> c) -> a :-> c

-- | Lift a value.
pure :: Applicative f => a -> f a

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Defines semantics of <tt>if ... then ... else ...</tt> construction.
ifThenElse :: Condition st arg argl argr -> (argl :-> o) -> (argr :-> o) -> arg :-> o

-- | Predicate for <tt>if ... then .. else ...</tt> construction, defines a
--   kind of operation applied to the top elements of the current stack.
data Condition st arg argl argr
[Holds] :: Condition s (Bool : s) s s
[IsSome] :: Condition s (Maybe a : s) (a : s) s
[IsNone] :: Condition s (Maybe a : s) s (a : s)
[IsLeft] :: Condition s (Either l r : s) (l : s) (r : s)
[IsRight] :: Condition s (Either l r : s) (r : s) (l : s)
[IsCons] :: Condition s ([a] : s) (a : ([a] : s)) s
[IsNil] :: Condition s ([a] : s) s (a : ([a] : s))
[IsZero] :: (UnaryArithOpHs Eq' a, UnaryArithResHs Eq' a ~ Bool) => Condition s (a : s) s s
[IsNotZero] :: (UnaryArithOpHs Eq' a, UnaryArithResHs Eq' a ~ Bool) => Condition s (a : s) s s
[IsEq] :: IfCmpXConstraints a Eq' => Condition s (a : (a : s)) s s
[IsNeq] :: IfCmpXConstraints a Neq => Condition s (a : (a : s)) s s
[IsLt] :: IfCmpXConstraints a Lt => Condition s (a : (a : s)) s s
[IsGt] :: IfCmpXConstraints a Gt => Condition s (a : (a : s)) s s
[IsLe] :: IfCmpXConstraints a Le => Condition s (a : (a : s)) s s
[IsGe] :: IfCmpXConstraints a Ge => Condition s (a : (a : s)) s s

-- | Conversion from an <a>Integer</a>. An integer literal represents the
--   application of the function <a>fromInteger</a> to the appropriate
--   value of type <a>Integer</a>, so such literals have type
--   <tt>(<a>Num</a> a) =&gt; a</tt>.
fromInteger :: Num a => Integer -> a
fromString :: IsString a => String -> a
fromLabel :: IsLabel x a => a

module Lorentz


-- | Functions to import contracts to be used in tests.
module Michelson.Test.Import
readContract :: forall cp st. Each [Typeable, SingI] [cp, st] => FilePath -> Text -> Either ImportContractError (Contract, Contract cp st)

-- | Import contract from a given file path.
--   
--   This function reads file, parses and type checks a contract. Within
--   the typechecking we assume that no contracts are originated, otherwise
--   a type checking error will be caused.
--   
--   This function may throw <a>IOException</a> and
--   <a>ImportContractError</a>.
importContract :: forall cp st. Each [Typeable, SingI] [cp, st] => FilePath -> IO (Contract, Contract cp st)
importUntypedContract :: FilePath -> IO Contract

-- | Error type for <a>importContract</a> function.
data ImportContractError
ICEUnexpectedParamType :: !Type -> !Type -> ImportContractError
ICEUnexpectedStorageType :: !Type -> !Type -> ImportContractError
ICEParse :: !ParserException -> ImportContractError
ICETypeCheck :: !TCError -> ImportContractError

-- | Import contract and use to create test trees. Both versions of
--   contract are passed to the callback function (untyped and typed).
--   
--   If contract's import fails, a tree with single failing test will be
--   generated (so test tree will likely be generated unexceptionally, but
--   a failing result will notify about problem).
testTreesWithContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> IO [TestTree]) -> IO [TestTree]

-- | Like <a>testTreesWithContract</a> but for Lorentz types.
testTreesWithContractL :: (Each [Typeable, SingI] [ToT cp, ToT st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> IO [TestTree]) -> IO [TestTree]

-- | Like <a>testTreesWithContract</a> but supplies only typed contract.
testTreesWithTypedContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> (Contract cp st -> IO [TestTree]) -> IO [TestTree]
concatTestTrees :: [IO [TestTree]] -> IO [TestTree]

-- | Import contract and use it in the spec. Both versions of contract are
--   passed to the callback function (untyped and typed).
--   
--   If contract's import fails, a spec with single failing expectation
--   will be generated (so tests will likely run unexceptionally, but a
--   failing result will notify about problem).
specWithContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> Spec) -> Spec

-- | Like <a>specWithContract</a>, but for Lorentz types.
specWithContractL :: (Each [Typeable, SingI] [ToT cp, ToT st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> Spec) -> Spec

-- | A version of <a>specWithContract</a> which passes only the typed
--   representation of the contract.
specWithTypedContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> (Contract cp st -> Spec) -> Spec
specWithUntypedContract :: FilePath -> (Contract -> Spec) -> Spec
instance GHC.Classes.Eq Michelson.Test.Import.ImportContractError
instance GHC.Show.Show Michelson.Test.Import.ImportContractError
instance Formatting.Buildable.Buildable Michelson.Test.Import.ImportContractError
instance GHC.Exception.Type.Exception Michelson.Test.Import.ImportContractError


-- | Module containing some utilities for testing Michelson contracts using
--   Haskell testing frameworks (hspec and QuickCheck in particular). It's
--   Morley testing EDSL.
module Michelson.Test

-- | Import contract and use it in the spec. Both versions of contract are
--   passed to the callback function (untyped and typed).
--   
--   If contract's import fails, a spec with single failing expectation
--   will be generated (so tests will likely run unexceptionally, but a
--   failing result will notify about problem).
specWithContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> Spec) -> Spec

-- | Like <a>specWithContract</a>, but for Lorentz types.
specWithContractL :: (Each [Typeable, SingI] [ToT cp, ToT st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> Spec) -> Spec

-- | A version of <a>specWithContract</a> which passes only the typed
--   representation of the contract.
specWithTypedContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> (Contract cp st -> Spec) -> Spec
specWithUntypedContract :: FilePath -> (Contract -> Spec) -> Spec

-- | Import contract and use to create test trees. Both versions of
--   contract are passed to the callback function (untyped and typed).
--   
--   If contract's import fails, a tree with single failing test will be
--   generated (so test tree will likely be generated unexceptionally, but
--   a failing result will notify about problem).
testTreesWithContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> IO [TestTree]) -> IO [TestTree]

-- | Like <a>testTreesWithContract</a> but for Lorentz types.
testTreesWithContractL :: (Each [Typeable, SingI] [ToT cp, ToT st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> IO [TestTree]) -> IO [TestTree]

-- | Like <a>testTreesWithContract</a> but supplies only typed contract.
testTreesWithTypedContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> (Contract cp st -> IO [TestTree]) -> IO [TestTree]
concatTestTrees :: [IO [TestTree]] -> IO [TestTree]
importUntypedContract :: FilePath -> IO Contract
type ContractReturn st = (Either MichelsonFailed ([Operation], Value st), InterpreterState)

-- | Type for contract execution validation.
--   
--   It's a function which is supplied with contract execution output
--   (failure or new storage with operation list).
--   
--   Function returns a property which type is designated by type variable
--   <tt>prop</tt> and might be <a>Property</a> or <a>Expectation</a> or
--   anything else relevant.
type ContractPropValidator st prop = ContractReturn st -> prop

-- | Contract's property tester against given input. Takes contract
--   environment, initial storage and parameter, interprets contract on
--   this input and invokes validation function.
contractProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st) => Contract cp st -> ContractPropValidator st prop -> ContractEnv -> param -> storage -> prop

-- | Version of <a>contractProp</a> which takes <tt>Val</tt> as arguments
--   instead of regular Haskell values.
contractPropVal :: Contract cp st -> ContractPropValidator st prop -> ContractEnv -> Value cp -> Value st -> prop
contractRepeatedProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st) => Contract cp st -> ContractPropValidator st prop -> ContractEnv -> [param] -> storage -> prop
contractRepeatedPropVal :: Contract cp st -> ContractPropValidator st prop -> ContractEnv -> [Value cp] -> Value st -> prop

-- | Validator for integrational testing. If an error is expected, it
--   should be <a>Left</a> with validator for errors. Otherwise it should
--   check final global state and its updates.
type IntegrationalValidator = Either (InterpreterError -> Bool) SuccessValidator

-- | Validator for integrational testing that expects successful execution.
type SuccessValidator = (InternalState -> GState -> [GStateUpdate] -> Either ValidationError ())
type IntegrationalScenario = IntegrationalScenarioM Validated

-- | A monad inside which integrational tests can be described using
--   do-notation.
type IntegrationalScenarioM = StateT InternalState (Except ScenarioError)

-- | Integrational test that executes given operations and validates them
--   using given validator. It can fail using <a>Expectation</a>
--   capability. It starts with <a>initGState</a> and some reasonable dummy
--   values for gas limit and current timestamp. You can update blockchain
--   state by performing some operations.
integrationalTestExpectation :: IntegrationalScenario -> Expectation

-- | Integrational test similar to <a>integrationalTestExpectation</a>. It
--   can fail using <a>Property</a> capability. It can be used with
--   QuickCheck's <tt>forAll</tt> to make a property-based test with
--   arbitrary data.
integrationalTestProperty :: IntegrationalScenario -> Property

-- | Originate a contract with given initial storage and balance. Its
--   address is returned.
originate :: Contract -> Text -> Value -> Mutez -> IntegrationalScenarioM Address

-- | Transfer tokens to given address.
transfer :: TxData -> Address -> IntegrationalScenarioM ()

-- | Execute all operations that were added to the scenarion since last
--   <a>validate</a> call. If validator fails, the execution will be
--   aborted.
validate :: IntegrationalValidator -> IntegrationalScenario

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given gas limit.
setMaxSteps :: RemainingSteps -> IntegrationalScenarioM ()

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given timestamp as the current one.
setNow :: Timestamp -> IntegrationalScenarioM ()

-- | Execute multiple testing scenarios independently, basing them on
--   scenario built till this point.
--   
--   The following property holds for this function:
--   
--   <tt> pre &gt;&gt; branchout [a, b, c] = branchout [pre &gt;&gt; a, pre
--   &gt;&gt; b, pre &gt;&gt; c] </tt>.
--   
--   In case of property failure in one of the branches no following branch
--   is executed.
--   
--   Providing empty list of scenarios to this function causes error; we do
--   not require <a>NonEmpty</a> here though for convenience.
branchout :: HasCallStack => [(Text, IntegrationalScenario)] -> IntegrationalScenario

-- | Make a tuple with name without extra syntactic noise.
(?-) :: Text -> a -> (Text, a)
infixr 0 ?-

-- | Compose two success validators.
--   
--   For example:
--   
--   expectBalance bal addr <a>composeValidators</a>
--   expectStorageUpdateConst addr2 ValueUnit
composeValidators :: SuccessValidator -> SuccessValidator -> SuccessValidator

-- | Compose a list of success validators.
composeValidatorsList :: [SuccessValidator] -> SuccessValidator

-- | <a>SuccessValidator</a> that always passes.
expectAnySuccess :: SuccessValidator

-- | Check that there were no updates.
expectNoUpdates :: SuccessValidator

-- | Check that there were no storage updates.
expectNoStorageUpdates :: SuccessValidator

-- | Check that storage value is updated for given address. Takes a
--   predicate that is used to check the value.
--   
--   It works even if updates are not filtered (i. e. a value can be
--   updated more than once).
expectStorageUpdate :: Address -> (Value -> Either ValidationError ()) -> SuccessValidator

-- | Like <a>expectStorageUpdate</a>, but expects a constant.
expectStorageUpdateConst :: Address -> Value -> SuccessValidator

-- | Check that eventually address has some particular balance.
expectBalance :: Address -> Mutez -> SuccessValidator

-- | Check that eventually address has some particular storage value.
expectStorageConst :: Address -> Value -> SuccessValidator

-- | Check that interpreter failed due to gas exhaustion.
expectGasExhaustion :: InterpreterError -> Bool

-- | Expect that interpretation of contract with given address ended with
--   [FAILED].
expectMichelsonFailed :: (MichelsonFailed -> Bool) -> Address -> InterpreterError -> Bool

-- | Data associated with a particular transaction.
data TxData
TxData :: !Address -> !Value -> !Mutez -> TxData
[tdSenderAddress] :: TxData -> !Address
[tdParameter] :: TxData -> !Value
[tdAmount] :: TxData -> !Mutez

-- | One of genesis addresses.
genesisAddress :: Address

-- | A <a>Property</a> that always failes with given message.
failedProp :: Text -> Property

-- | A <a>Property</a> that always succeeds.
succeededProp :: Property

-- | The <a>Property</a> holds on `Left a`.
qcIsLeft :: Show b => Either a b -> Property

-- | The <a>Property</a> holds on `Right b`.
qcIsRight :: Show a => Either a b -> Property

-- | Dummy <a>ContractEnv</a> with some reasonable hardcoded values. You
--   can override values you are interested in using record update syntax.
dummyContractEnv :: ContractEnv

-- | Minimal (earliest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
minTimestamp :: Timestamp

-- | Maximal (latest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
maxTimestamp :: Timestamp

-- | Median of <a>minTimestamp</a> and <a>maxTimestamp</a>. Useful for
--   testing (exactly half of generated dates will be before and after this
--   date).
midTimestamp :: Timestamp

module Util.Test.Arbitrary

-- | Run given generator deterministically.
runGen :: Int -> Gen a -> a
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Value.InternalByteString
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Ext.Var
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Ext.TyVar
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Ext.StackTypePattern
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Aliases.ExpandedExtInstr
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.ErrorPos.Pos
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.ErrorPos.Pos
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.ErrorPos.SrcPos
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.ErrorPos.SrcPos
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.ErrorPos.LetName
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.ErrorPos.LetName
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.ErrorPos.InstrCallStack
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.ErrorPos.InstrCallStack
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Instr.ExpandedOp
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Instr.ExpandedOp
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Tezos.Core.Mutez
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Annotation.TypeAnn
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Annotation.TypeAnn
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Annotation.FieldAnn
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Annotation.FieldAnn
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Annotation.VarAnn
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Annotation.VarAnn
instance (Test.QuickCheck.Arbitrary.Arbitrary op, Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary op) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Michelson.Untyped.Contract.Contract' op)
instance Test.QuickCheck.Arbitrary.Arbitrary op => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Untyped.Contract.Contract' op)
instance (Test.QuickCheck.Arbitrary.Arbitrary op, Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary op, Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Untyped.Ext.ExtInstrAbstract op)) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Michelson.Untyped.Instr.InstrAbstract op)
instance (Test.QuickCheck.Arbitrary.Arbitrary op, Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Untyped.Ext.ExtInstrAbstract op)) => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Untyped.Instr.InstrAbstract op)
instance (Test.QuickCheck.Arbitrary.Arbitrary op, Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary op) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Michelson.Untyped.Value.Value' op)
instance Test.QuickCheck.Arbitrary.Arbitrary op => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Untyped.Value.Value' op)
instance (Test.QuickCheck.Arbitrary.Arbitrary op, Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary op) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Michelson.Untyped.Value.Elt op)
instance Test.QuickCheck.Arbitrary.Arbitrary op => Test.QuickCheck.Arbitrary.Arbitrary (Michelson.Untyped.Value.Elt op)
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Type.Type
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Type.Type
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Type.T
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Type.T
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Type.CT
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Type.CT
instance Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary Michelson.Untyped.Type.Comparable
instance Test.QuickCheck.Arbitrary.Arbitrary Michelson.Untyped.Type.Comparable
instance (GHC.Classes.Ord k, Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (k Lorentz.UStore.Types.|~> v)
instance Test.QuickCheck.Arbitrary.Arbitrary v => Test.QuickCheck.Arbitrary.Arbitrary (Lorentz.UStore.Types.UStoreField v)


-- | Mirrors <a>Integrational</a> module in a Lorentz way.
module Lorentz.Test.Integrational

-- | Data associated with a particular transaction.
data TxData
TxData :: !Address -> !Value -> !Mutez -> TxData
[tdSenderAddress] :: TxData -> !Address
[tdParameter] :: TxData -> !Value
[tdAmount] :: TxData -> !Mutez

-- | Initially these addresses have a lot of money.
genesisAddresses :: NonEmpty Address

-- | One of genesis addresses.
genesisAddress :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress1 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress2 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress3 :: Address
genesisAddress4 :: Address
genesisAddress5 :: Address
genesisAddress6 :: Address

-- | Validator for integrational testing. If an error is expected, it
--   should be <a>Left</a> with validator for errors. Otherwise it should
--   check final global state and its updates.
type IntegrationalValidator = Either (InterpreterError -> Bool) SuccessValidator

-- | Validator for integrational testing that expects successful execution.
type SuccessValidator = (InternalState -> GState -> [GStateUpdate] -> Either ValidationError ())

-- | A monad inside which integrational tests can be described using
--   do-notation.
type IntegrationalScenarioM = StateT InternalState (Except ScenarioError)
type IntegrationalScenario = IntegrationalScenarioM Validated
data ValidationError
UnexpectedInterpreterError :: IntegrationalInterpreterError -> ValidationError
UnexpectedTypeCheckError :: TCError -> ValidationError
ExpectingInterpreterToFail :: ValidationError
IncorrectUpdates :: ValidationError -> [GStateUpdate] -> ValidationError
IncorrectStorageUpdate :: AddressName -> Text -> ValidationError
InvalidStorage :: AddressName -> ExpectedStorage -> Text -> ValidationError
InvalidBalance :: AddressName -> ExpectedBalance -> Text -> ValidationError
UnexpectedUpdates :: NonEmpty GStateUpdate -> ValidationError
CustomError :: Text -> ValidationError

-- | Integrational test that executes given operations and validates them
--   using given validator. It can fail using <a>Expectation</a>
--   capability. It starts with <a>initGState</a> and some reasonable dummy
--   values for gas limit and current timestamp. You can update blockchain
--   state by performing some operations.
integrationalTestExpectation :: IntegrationalScenario -> Expectation

-- | Integrational test similar to <a>integrationalTestExpectation</a>. It
--   can fail using <a>Property</a> capability. It can be used with
--   QuickCheck's <tt>forAll</tt> to make a property-based test with
--   arbitrary data.
integrationalTestProperty :: IntegrationalScenario -> Property

-- | Like <tt>originate</tt>, but for Lorentz contracts.
lOriginate :: (SingI (ToT cp), SingI (ToT st), HasNoOp (ToT st), IsoValue st) => Contract cp st -> Text -> st -> Mutez -> IntegrationalScenarioM (ContractAddr cp)

-- | Originate a contract with empty balance and default storage.
lOriginateEmpty :: (SingI (ToT cp), SingI (ToT st), HasNoOp (ToT st), IsoValue st, Default st) => Contract cp st -> Text -> IntegrationalScenarioM (ContractAddr cp)

-- | Similar to <a>transfer</a>, for Lorentz values.
lTransfer :: (SingI (ToT cp), HasNoOp (ToT cp), IsoValue cp) => ("from" :! Address) -> ("to" :! ContractAddr cp) -> Mutez -> cp -> IntegrationalScenarioM ()

-- | Call a contract without caring about source address and money.
lCall :: (SingI (ToT cp), HasNoOp (ToT cp), IsoValue cp) => ContractAddr cp -> cp -> IntegrationalScenarioM ()

-- | Execute all operations that were added to the scenarion since last
--   <a>validate</a> call. If validator fails, the execution will be
--   aborted.
validate :: IntegrationalValidator -> IntegrationalScenario

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given gas limit.
setMaxSteps :: RemainingSteps -> IntegrationalScenarioM ()

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given timestamp as the current one.
setNow :: Timestamp -> IntegrationalScenarioM ()

-- | Pretend that given address initiates all the transfers within the code
--   block (i.e. <tt>SENDER</tt> instruction will return this address).
withSender :: Address -> IntegrationalScenarioM a -> IntegrationalScenarioM a

-- | Execute multiple testing scenarios independently, basing them on
--   scenario built till this point.
--   
--   The following property holds for this function:
--   
--   <tt> pre &gt;&gt; branchout [a, b, c] = branchout [pre &gt;&gt; a, pre
--   &gt;&gt; b, pre &gt;&gt; c] </tt>.
--   
--   In case of property failure in one of the branches no following branch
--   is executed.
--   
--   Providing empty list of scenarios to this function causes error; we do
--   not require <a>NonEmpty</a> here though for convenience.
branchout :: HasCallStack => [(Text, IntegrationalScenario)] -> IntegrationalScenario

-- | Make a tuple with name without extra syntactic noise.
(?-) :: Text -> a -> (Text, a)
infixr 0 ?-

-- | Compose two success validators.
--   
--   For example:
--   
--   expectBalance bal addr <a>composeValidators</a>
--   expectStorageUpdateConst addr2 ValueUnit
composeValidators :: SuccessValidator -> SuccessValidator -> SuccessValidator

-- | Compose a list of success validators.
composeValidatorsList :: [SuccessValidator] -> SuccessValidator

-- | <a>SuccessValidator</a> that always passes.
expectAnySuccess :: SuccessValidator

-- | Check that there were no updates.
expectNoUpdates :: SuccessValidator

-- | Check that there were no storage updates.
expectNoStorageUpdates :: SuccessValidator

-- | Similar to <tt>expectStorageUpdate</tt>, for Lorentz values.
lExpectStorageUpdate :: (IsoValue st, Each [Typeable, SingI, HasNoOp] '[ToT st], HasCallStack) => ContractAddr cp -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Like <tt>expectBalance</tt>, for Lorentz values.
lExpectBalance :: ContractAddr cp -> Mutez -> SuccessValidator

-- | Similar to <tt>expectStorageConst</tt>, for Lorentz values.
lExpectStorageConst :: (IsoValue st, Each '[SingI, HasNoOp] '[ToT st]) => ContractAddr cp -> st -> SuccessValidator

-- | Expect that interpretation of contract with given address ended with
--   [FAILED].
lExpectMichelsonFailed :: (MichelsonFailed -> Bool) -> ContractAddr cp -> InterpreterError -> Bool

-- | Expect contract to fail with <a>FAILWITH</a> instruction and provided
--   value to match against the given predicate.
lExpectFailWith :: forall e. (Typeable (ToT e), IsoValue e) => (e -> Bool) -> InterpreterError -> Bool

-- | Expect contract to fail with given <tt>LorentzUserError</tt> error.
lExpectError :: forall e. IsError e => (e -> Bool) -> InterpreterError -> Bool

-- | Version of <a>lExpectStorageUpdate</a> specialized to "consumer"
--   contract (see <a>contractConsumer</a>).
lExpectConsumerStorage :: (st ~ [cp], IsoValue st, Each [Typeable, SingI, HasNoOp] '[ToT st]) => ContractAddr cp -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Assuming that "consumer" contract receives a value from <tt>View</tt>,
--   expect this view return value to be the given one.
--   
--   Despite consumer stores parameters it was called with in reversed
--   order, this function cares about it, so you should provide a list of
--   expected values in the same order in which the corresponding events
--   were happenning.
lExpectViewConsumerStorage :: (st ~ [cp], Eq cp, Buildable cp, IsoValue st, Each [Typeable, SingI, HasNoOp] '[ToT st]) => ContractAddr cp -> [cp] -> SuccessValidator

module Lorentz.Test

-- | Import contract and use it in the spec. Both versions of contract are
--   passed to the callback function (untyped and typed).
--   
--   If contract's import fails, a spec with single failing expectation
--   will be generated (so tests will likely run unexceptionally, but a
--   failing result will notify about problem).
specWithContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> ((Contract, Contract cp st) -> Spec) -> Spec

-- | A version of <a>specWithContract</a> which passes only the typed
--   representation of the contract.
specWithTypedContract :: (Each [Typeable, SingI] [cp, st], HasCallStack) => FilePath -> (Contract cp st -> Spec) -> Spec
specWithUntypedContract :: FilePath -> (Contract -> Spec) -> Spec
type ContractReturn st = (Either MichelsonFailed ([Operation], Value st), InterpreterState)

-- | Type for contract execution validation.
--   
--   It's a function which is supplied with contract execution output
--   (failure or new storage with operation list).
--   
--   Function returns a property which type is designated by type variable
--   <tt>prop</tt> and might be <a>Property</a> or <a>Expectation</a> or
--   anything else relevant.
type ContractPropValidator st prop = ContractReturn st -> prop

-- | Contract's property tester against given input. Takes contract
--   environment, initial storage and parameter, interprets contract on
--   this input and invokes validation function.
contractProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st) => Contract cp st -> ContractPropValidator st prop -> ContractEnv -> param -> storage -> prop

-- | Version of <a>contractProp</a> which takes <tt>Val</tt> as arguments
--   instead of regular Haskell values.
contractPropVal :: Contract cp st -> ContractPropValidator st prop -> ContractEnv -> Value cp -> Value st -> prop
contractRepeatedProp :: (IsoValue param, IsoValue storage, ToT param ~ cp, ToT storage ~ st) => Contract cp st -> ContractPropValidator st prop -> ContractEnv -> [param] -> storage -> prop
contractRepeatedPropVal :: Contract cp st -> ContractPropValidator st prop -> ContractEnv -> [Value cp] -> Value st -> prop

-- | Validator for integrational testing. If an error is expected, it
--   should be <a>Left</a> with validator for errors. Otherwise it should
--   check final global state and its updates.
type IntegrationalValidator = Either (InterpreterError -> Bool) SuccessValidator

-- | Validator for integrational testing that expects successful execution.
type SuccessValidator = (InternalState -> GState -> [GStateUpdate] -> Either ValidationError ())
type IntegrationalScenario = IntegrationalScenarioM Validated

-- | A monad inside which integrational tests can be described using
--   do-notation.
type IntegrationalScenarioM = StateT InternalState (Except ScenarioError)
data ValidationError
UnexpectedInterpreterError :: IntegrationalInterpreterError -> ValidationError
UnexpectedTypeCheckError :: TCError -> ValidationError
ExpectingInterpreterToFail :: ValidationError
IncorrectUpdates :: ValidationError -> [GStateUpdate] -> ValidationError
IncorrectStorageUpdate :: AddressName -> Text -> ValidationError
InvalidStorage :: AddressName -> ExpectedStorage -> Text -> ValidationError
InvalidBalance :: AddressName -> ExpectedBalance -> Text -> ValidationError
UnexpectedUpdates :: NonEmpty GStateUpdate -> ValidationError
CustomError :: Text -> ValidationError

-- | Integrational test that executes given operations and validates them
--   using given validator. It can fail using <a>Expectation</a>
--   capability. It starts with <a>initGState</a> and some reasonable dummy
--   values for gas limit and current timestamp. You can update blockchain
--   state by performing some operations.
integrationalTestExpectation :: IntegrationalScenario -> Expectation

-- | Integrational test similar to <a>integrationalTestExpectation</a>. It
--   can fail using <a>Property</a> capability. It can be used with
--   QuickCheck's <tt>forAll</tt> to make a property-based test with
--   arbitrary data.
integrationalTestProperty :: IntegrationalScenario -> Property

-- | Like <tt>originate</tt>, but for Lorentz contracts.
lOriginate :: (SingI (ToT cp), SingI (ToT st), HasNoOp (ToT st), IsoValue st) => Contract cp st -> Text -> st -> Mutez -> IntegrationalScenarioM (ContractAddr cp)

-- | Originate a contract with empty balance and default storage.
lOriginateEmpty :: (SingI (ToT cp), SingI (ToT st), HasNoOp (ToT st), IsoValue st, Default st) => Contract cp st -> Text -> IntegrationalScenarioM (ContractAddr cp)

-- | Similar to <a>transfer</a>, for Lorentz values.
lTransfer :: (SingI (ToT cp), HasNoOp (ToT cp), IsoValue cp) => ("from" :! Address) -> ("to" :! ContractAddr cp) -> Mutez -> cp -> IntegrationalScenarioM ()

-- | Call a contract without caring about source address and money.
lCall :: (SingI (ToT cp), HasNoOp (ToT cp), IsoValue cp) => ContractAddr cp -> cp -> IntegrationalScenarioM ()

-- | Execute all operations that were added to the scenarion since last
--   <a>validate</a> call. If validator fails, the execution will be
--   aborted.
validate :: IntegrationalValidator -> IntegrationalScenario

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given gas limit.
setMaxSteps :: RemainingSteps -> IntegrationalScenarioM ()

-- | Make all further interpreter calls (which are triggered by the
--   <a>validate</a> function) use given timestamp as the current one.
setNow :: Timestamp -> IntegrationalScenarioM ()

-- | Pretend that given address initiates all the transfers within the code
--   block (i.e. <tt>SENDER</tt> instruction will return this address).
withSender :: Address -> IntegrationalScenarioM a -> IntegrationalScenarioM a

-- | Execute multiple testing scenarios independently, basing them on
--   scenario built till this point.
--   
--   The following property holds for this function:
--   
--   <tt> pre &gt;&gt; branchout [a, b, c] = branchout [pre &gt;&gt; a, pre
--   &gt;&gt; b, pre &gt;&gt; c] </tt>.
--   
--   In case of property failure in one of the branches no following branch
--   is executed.
--   
--   Providing empty list of scenarios to this function causes error; we do
--   not require <a>NonEmpty</a> here though for convenience.
branchout :: HasCallStack => [(Text, IntegrationalScenario)] -> IntegrationalScenario

-- | Make a tuple with name without extra syntactic noise.
(?-) :: Text -> a -> (Text, a)
infixr 0 ?-

-- | Compose two success validators.
--   
--   For example:
--   
--   expectBalance bal addr <a>composeValidators</a>
--   expectStorageUpdateConst addr2 ValueUnit
composeValidators :: SuccessValidator -> SuccessValidator -> SuccessValidator

-- | Compose a list of success validators.
composeValidatorsList :: [SuccessValidator] -> SuccessValidator

-- | <a>SuccessValidator</a> that always passes.
expectAnySuccess :: SuccessValidator

-- | Check that there were no updates.
expectNoUpdates :: SuccessValidator

-- | Check that there were no storage updates.
expectNoStorageUpdates :: SuccessValidator

-- | Similar to <tt>expectStorageUpdate</tt>, for Lorentz values.
lExpectStorageUpdate :: (IsoValue st, Each [Typeable, SingI, HasNoOp] '[ToT st], HasCallStack) => ContractAddr cp -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Like <tt>expectBalance</tt>, for Lorentz values.
lExpectBalance :: ContractAddr cp -> Mutez -> SuccessValidator

-- | Similar to <tt>expectStorageConst</tt>, for Lorentz values.
lExpectStorageConst :: (IsoValue st, Each '[SingI, HasNoOp] '[ToT st]) => ContractAddr cp -> st -> SuccessValidator

-- | Expect that interpretation of contract with given address ended with
--   [FAILED].
lExpectMichelsonFailed :: (MichelsonFailed -> Bool) -> ContractAddr cp -> InterpreterError -> Bool

-- | Expect contract to fail with <a>FAILWITH</a> instruction and provided
--   value to match against the given predicate.
lExpectFailWith :: forall e. (Typeable (ToT e), IsoValue e) => (e -> Bool) -> InterpreterError -> Bool

-- | Expect contract to fail with given <tt>LorentzUserError</tt> error.
lExpectError :: forall e. IsError e => (e -> Bool) -> InterpreterError -> Bool

-- | Version of <a>lExpectStorageUpdate</a> specialized to "consumer"
--   contract (see <a>contractConsumer</a>).
lExpectConsumerStorage :: (st ~ [cp], IsoValue st, Each [Typeable, SingI, HasNoOp] '[ToT st]) => ContractAddr cp -> (st -> Either ValidationError ()) -> SuccessValidator

-- | Assuming that "consumer" contract receives a value from <tt>View</tt>,
--   expect this view return value to be the given one.
--   
--   Despite consumer stores parameters it was called with in reversed
--   order, this function cares about it, so you should provide a list of
--   expected values in the same order in which the corresponding events
--   were happenning.
lExpectViewConsumerStorage :: (st ~ [cp], Eq cp, Buildable cp, IsoValue st, Each [Typeable, SingI, HasNoOp] '[ToT st]) => ContractAddr cp -> [cp] -> SuccessValidator

-- | Data associated with a particular transaction.
data TxData
TxData :: !Address -> !Value -> !Mutez -> TxData
[tdSenderAddress] :: TxData -> !Address
[tdParameter] :: TxData -> !Value
[tdAmount] :: TxData -> !Mutez

-- | Initially these addresses have a lot of money.
genesisAddresses :: NonEmpty Address

-- | One of genesis addresses.
genesisAddress :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress1 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress2 :: Address

-- | More genesis addresses
--   
--   We know size of <tt>genesisAddresses</tt>, so it is safe to use
--   <tt>!!</tt>
genesisAddress3 :: Address
genesisAddress4 :: Address
genesisAddress5 :: Address
genesisAddress6 :: Address

-- | A <a>Property</a> that always failes with given message.
failedProp :: Text -> Property

-- | A <a>Property</a> that always succeeds.
succeededProp :: Property

-- | The <a>Property</a> holds on `Left a`.
qcIsLeft :: Show b => Either a b -> Property

-- | The <a>Property</a> holds on `Right b`.
qcIsRight :: Show a => Either a b -> Property

-- | Dummy <a>ContractEnv</a> with some reasonable hardcoded values. You
--   can override values you are interested in using record update syntax.
dummyContractEnv :: ContractEnv

-- | Minimal (earliest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
minTimestamp :: Timestamp

-- | Maximal (latest) timestamp used for <tt>Arbitrary (CValue
--   'CTimestamp)</tt>
maxTimestamp :: Timestamp

-- | Median of <a>minTimestamp</a> and <a>maxTimestamp</a>. Useful for
--   testing (exactly half of generated dates will be before and after this
--   date).
midTimestamp :: Timestamp
