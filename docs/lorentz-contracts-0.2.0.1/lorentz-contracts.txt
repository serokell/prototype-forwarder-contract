-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Set of Michelson contracts implemented in Lorentz eDSL.
--   
--   Various contracts including simple examples.
@package lorentz-contracts
@version 0.2.0.1

module Lorentz.Contracts.Auction
auctionContract :: Contract Parameter Storage


-- | Contract which remembers all parameters it has been called with.
--   
--   Useful to save return values of <tt>View</tt> entry points.
module Lorentz.Contracts.Consumer

-- | Remembers parameters it was called with, last go first.
contractConsumer :: Contract cp [cp]


-- | Types shared between contracts participating in ManagedLedger.
module Lorentz.Contracts.ManagedLedger.Types
type TransferParams = ("from" :! Address, "to" :! Address, "value" :! Natural)
type ApproveParams = ("spender" :! Address, "value" :! Natural)
type AllowanceParams = ("owner" :! Address, "spender" :! Address, "value" :! Natural)
type GetAllowanceParams = ("owner" :! Address, "spender" :! Address)
type MintParams = ("to" :! Address, "value" :! Natural)
type BurnParams = ("from" :! Address, "value" :! Natural)
type LedgerValue = ("balance" :! Natural, "approvals" :! Map Address Natural)
data Error

-- | Attempt to change allowance from non-zero to a non-zero value.
UnsafeAllowanceChange :: Natural -> Error

-- | Contract initiator has not enough rights to perform this operation.
SenderIsNotAdmin :: Error

-- | Insufficient balance.
NotEnoughBalance :: ("required" :! Natural, "present" :! Natural) -> Error

-- | Insufficient allowance to transfer foreign funds.
NotEnoughAllowance :: ("required" :! Natural, "present" :! Natural) -> Error

-- | Operation is unavailable until resume by token admin.
OperationsArePaused :: Error
data Storage' fields
Storage' :: BigMap Address LedgerValue -> fields -> Storage' fields
[ledger] :: Storage' fields -> BigMap Address LedgerValue
[fields] :: Storage' fields -> fields

-- | Create a default storage with ability to set some balances to non-zero
--   values.
mkStorage' :: Map Address Natural -> fields -> Storage' fields
instance Michelson.Typed.Haskell.Value.IsoValue fields => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.ManagedLedger.Types.Storage' fields)
instance GHC.Generics.Generic (Lorentz.Contracts.ManagedLedger.Types.Storage' fields)
instance Lorentz.Errors.IsError Lorentz.Contracts.ManagedLedger.Types.Error
instance Lorentz.Errors.CustomErrorNoIsoValue Lorentz.Contracts.ManagedLedger.Types.Error => Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Types.Error
instance Formatting.Buildable.Buildable Lorentz.Contracts.ManagedLedger.Types.Error
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Types.Error
instance GHC.Classes.Eq Lorentz.Contracts.ManagedLedger.Types.Error


-- | Implementation of manalged ledger which does not require particular
--   storage type.
module Lorentz.Contracts.ManagedLedger.Impl
type StorageFieldsC fields = fields `HasFieldsOfType` ["admin" := Address, "paused" := Bool, "totalSupply" := Natural]
transfer :: forall fields. StorageFieldsC fields => Entrypoint TransferParams fields

-- | This is a slightly more general version of <a>transfer</a> which is
--   needed to implement <tt>transferViaProxy</tt>. It does not use
--   <a>sender</a>.
transfer' :: forall fields. StorageFieldsC fields => Entrypoint ("sender" :! Address, TransferParams) fields
approve :: forall fields. StorageFieldsC fields => Entrypoint ApproveParams fields

-- | This is a slightly more general version of <a>approve</a> which is
--   needed to implement <tt>approveViaProxy</tt>. It does not use
--   <a>sender</a>.
approve' :: forall fields. StorageFieldsC fields => Entrypoint AllowanceParams fields
getAllowance :: StorageFieldsC fields => Entrypoint (View GetAllowanceParams Natural) fields
getBalance :: StorageFieldsC fields => Entrypoint (View Address Natural) fields
getTotalSupply :: StorageFieldsC fields => Entrypoint (View () Natural) fields
setPause :: StorageFieldsC fields => Entrypoint Bool fields
setAdministrator :: StorageFieldsC fields => Entrypoint Address fields
getAdministrator :: StorageFieldsC fields => Entrypoint (View () Address) fields
mint :: StorageFieldsC fields => Entrypoint MintParams fields
burn :: StorageFieldsC fields => Entrypoint BurnParams fields


-- | Managed ledger which is compatible with FA1.2 standard and extended
--   with administrator functionality. It is <b>not</b> compatible with the
--   Athens version of FA1.2.
module Lorentz.Contracts.ManagedLedger.Babylon
data Parameter
Transfer :: !TransferParams -> Parameter
Approve :: !ApproveParams -> Parameter
GetAllowance :: !View GetAllowanceParams Natural -> Parameter
GetBalance :: !View Address Natural -> Parameter
GetTotalSupply :: !View () Natural -> Parameter
SetPause :: !Bool -> Parameter
SetAdministrator :: !Address -> Parameter
GetAdministrator :: !View () Address -> Parameter
Mint :: !MintParams -> Parameter
Burn :: !BurnParams -> Parameter
type Storage = Storage' StorageFields
data Error

-- | Attempt to change allowance from non-zero to a non-zero value.
UnsafeAllowanceChange :: Natural -> Error

-- | Contract initiator has not enough rights to perform this operation.
SenderIsNotAdmin :: Error

-- | Insufficient balance.
NotEnoughBalance :: ("required" :! Natural, "present" :! Natural) -> Error

-- | Insufficient allowance to transfer foreign funds.
NotEnoughAllowance :: ("required" :! Natural, "present" :! Natural) -> Error

-- | Operation is unavailable until resume by token admin.
OperationsArePaused :: Error

-- | Create a default storage with ability to set some balances to non-zero
--   values.
mkStorage :: Address -> Map Address Natural -> Storage
managedLedgerContract :: Contract Parameter Storage
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Babylon.StorageFields
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Babylon.StorageFields
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Babylon.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Babylon.Parameter


-- | Implementation of managed ledger compatible with FA1.2.1 which targets
--   Athens. Requires a proxy contract (<tt>ManagedLedgerProxy</tt>).
module Lorentz.Contracts.ManagedLedger.Athens
data Parameter
Transfer :: !TransferParams -> Parameter
TransferViaProxy :: !("sender" :! Address, TransferParams) -> Parameter
Approve :: !ApproveParams -> Parameter
ApproveViaProxy :: !("sender" :! Address, ApproveParams) -> Parameter
GetAllowance :: !View GetAllowanceParams Natural -> Parameter
GetBalance :: !View Address Natural -> Parameter
GetTotalSupply :: !View () Natural -> Parameter
SetPause :: !Bool -> Parameter
SetAdministrator :: !Address -> Parameter
GetAdministrator :: !View () Address -> Parameter
Mint :: !MintParams -> Parameter
Burn :: !BurnParams -> Parameter
SetProxy :: !Address -> Parameter
type Storage = Storage' StorageFields

-- | Create a default storage. In order to make this contract fully usable
--   administrator must call the <a>SetProxy</a> entrypoint. Only
--   administrator can do it (though in principle we can accept two
--   addresses here and let someone else set proxy instead. Balances can be
--   set to non-zero values if they are passed in one of the arguments.
--   Approvals are all empty.
mkStorage :: Address -> Map Address Natural -> Storage
managedLedgerAthensContract :: Contract Parameter Storage

-- | Errors specific to this (i. e. compatible with Athens) implementation.
data AthensError
ProxyAlreadySet :: AthensError
NotAllowedToSetProxy :: AthensError
ProxyIsNotSet :: AthensError
CallerIsNotProxy :: AthensError
instance Lorentz.Errors.IsError Lorentz.Contracts.ManagedLedger.Athens.AthensError
instance Lorentz.Errors.CustomErrorNoIsoValue Lorentz.Contracts.ManagedLedger.Athens.AthensError => Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Athens.AthensError
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Athens.AthensError
instance GHC.Classes.Eq Lorentz.Contracts.ManagedLedger.Athens.AthensError
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Athens.StorageFields
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Athens.StorageFields
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Athens.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Athens.Parameter


-- | Proxy contract to be used with ManagedLedgerAthens. See FA1.2.1.
module Lorentz.Contracts.ManagedLedger.Proxy
data Parameter
Transfer :: !TransferParams -> Parameter
Parameter0 :: !Parameter0 -> Parameter

-- | Sane representation of parameter which we currently can't use because
--   it's Michelson representation is a balanced tree, while we need to be
--   compatible with FA1.2 which requires linear structure.
data SaneParameter
STransfer :: !TransferParams -> SaneParameter
SApprove :: !ApproveParams -> SaneParameter
SGetAllowance :: !View GetAllowanceParams Natural -> SaneParameter
SGetBalance :: !View Address Natural -> SaneParameter
SGetTotalSupply :: !View () Natural -> SaneParameter

-- | Convert sane parameter to parameter of this contract.
fromSaneParameter :: SaneParameter -> Parameter
type Storage = ContractAddr Parameter
managedLedgerProxyContract :: Contract Parameter Storage
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Proxy.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Proxy.Parameter
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Proxy.Parameter0
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Proxy.Parameter0
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Proxy.Parameter1
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Proxy.Parameter1
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.ManagedLedger.Proxy.Parameter2
instance GHC.Generics.Generic Lorentz.Contracts.ManagedLedger.Proxy.Parameter2


-- | Unsafe ledger implementation as described in TZIP-FA1.
module Lorentz.Contracts.UnsafeLedger
data Parameter
Transfer :: TransferParams -> Parameter
GetTotalSupply :: View () Natural -> Parameter
GetBalance :: View Address Natural -> Parameter
data Storage
Storage :: BigMap Address Natural -> Natural -> Storage
[ledger] :: Storage -> BigMap Address Natural
[totalSupply] :: Storage -> Natural
unsafeLedgerContract :: Contract Parameter Storage
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UnsafeLedger.Storage
instance GHC.Generics.Generic Lorentz.Contracts.UnsafeLedger.Storage
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.UnsafeLedger.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.UnsafeLedger.Parameter

module Lorentz.Contracts.Upgradeable.Common.Base
type UParameter = (MText, ByteString)
type UStore_ = BigMap ByteString ByteString
type MigrationScript = Lambda UStore_ UStore_
type ContractCode = Lambda (UParameter, UStore_) ([Operation], UStore_)

module Lorentz.Contracts.Upgradeable.Common.Contract
data Parameter (interface :: [EntryPointKind])
Run :: UParam interface -> Parameter
Upgrade :: UpgradeParameters -> Parameter
GetVersion :: View () Natural -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: Natural -> Parameter
EpwApplyMigration :: MigrationScript -> Parameter
EpwSetCode :: ContractCode -> Parameter
EpwFinishUpgrade :: Parameter
data Storage
data Error

-- | Tx sender does not have enough rights to perform this operation.
SenderIsNotAdmin :: Error

-- | Expected version does not match the version of the supplied code.
VersionMismatch :: ("expected" :! Natural, "actual" :! Natural) -> Error

-- | The reuested operation requires the contract to be running but it is
--   paused.
ContractIsPaused :: Error

-- | The reuested operation requires the contract to be paused but it is
--   not.
ContractIsNotPaused :: Error
upgradeableContract :: forall (interface :: [EntryPointKind]). Contract (Parameter interface) Storage
mkEmptyStorage :: Address -> Storage

-- | Mentions that parameter should be wrapped into <a>Run</a> entry point.
pbsContainedInRun :: ParamBuildingStep
instance Michelson.Typed.Doc.DocItem (Lorentz.EntryPoints.DEntryPoint Lorentz.Contracts.Upgradeable.Common.Contract.UpgradeableEntryPointKind)
instance Lorentz.Errors.IsError Lorentz.Contracts.Upgradeable.Common.Contract.Error
instance Lorentz.Errors.CustomErrorNoIsoValue Lorentz.Contracts.Upgradeable.Common.Contract.Error => Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Upgradeable.Common.Contract.Error
instance Formatting.Buildable.Buildable Lorentz.Contracts.Upgradeable.Common.Contract.Error
instance GHC.Generics.Generic Lorentz.Contracts.Upgradeable.Common.Contract.Error
instance GHC.Classes.Eq Lorentz.Contracts.Upgradeable.Common.Contract.Error
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Upgradeable.Common.Contract.Storage
instance GHC.Generics.Generic Lorentz.Contracts.Upgradeable.Common.Contract.Storage
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Upgradeable.Common.Contract.StorageFields
instance GHC.Generics.Generic Lorentz.Contracts.Upgradeable.Common.Contract.StorageFields
instance Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter interface)
instance GHC.Generics.Generic (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter interface)
instance Lorentz.UParam.UnpackUParam Formatting.Buildable.Buildable interface => Formatting.Buildable.Buildable (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter interface)
instance Michelson.Typed.Haskell.Doc.TypeHasDoc (Lorentz.Contracts.Upgradeable.Common.Contract.Parameter interface)

module Lorentz.Contracts.Upgradeable.Common

module Lorentz.Contracts.Upgradeable.EntryPointWise

-- | A helper type that defines an entry point that receives a packed
--   argument, i.e. it's basically an unpack instruction followed by a
--   TypedEntryPoint code
type EntryPointImpl store = Lambda (ByteString, UStore store) ([Operation], UStore store)

-- | A helper type that defines a function being called in case no
--   implementation matches the requested entry point
type EpwFallback store = Lambda ((MText, ByteString), UStore store) ([Operation], UStore store)

-- | This data type represents the new contract code and migrations
--   necessary to upgrade the contract endpoints to the new version.
data EpwContract interface store
EpwContract :: ContractCode -> [MigrationScript] -> EpwContract interface store

-- | <a>epwServe</a> does the dispatching logic and is assumed to be used
--   for the <tt>code</tt> lambda of the upgradeable contract.
[epwServe] :: EpwContract interface store -> ContractCode

-- | <a>epwCodeMigrations</a> is a list of packed migrations the client
--   ought to pass to the <tt>EpwUpgrade</tt> method in order to upgrade
--   the implementation.
[epwCodeMigrations] :: EpwContract interface store -> [MigrationScript]

-- | A data type representing a full case clause with the name and
--   implementation of an entry point.
data EpwCaseClause store (entry :: EntryPointKind)
[EpwCaseClause] :: TypedEntryPointImpl arg store -> EpwCaseClause store '(name, arg)

-- | Creates the EpwContract data structure from a Rec of case clauses
mkEpwContract :: forall (interface :: [EntryPointKind]) store. (CodeMigrations interface, GetUStoreKey store "code" ~ MText, GetUStoreValue store "code" ~ EntryPointImpl store, GetUStoreField store "fallback" ~ EpwFallback store) => Rec (EpwCaseClause store) interface -> EpwFallback store -> EpwContract interface store

-- | Like <a>mkEpwContract</a>, but accepts a tuple of clauses, not a
--   <a>Rec</a>.
mkEpwContractT :: forall clauses (interface :: [EntryPointKind]) store. (clauses ~ Rec (EpwCaseClause store) interface, RecFromTuple clauses, CodeMigrations interface, GetUStoreKey store "code" ~ MText, GetUStoreValue store "code" ~ EntryPointImpl store, GetUStoreField store "fallback" ~ EpwFallback store) => IsoRecTuple clauses -> EpwFallback store -> EpwContract interface store

-- | Default implementation for <a>EpwFallback</a> reports an error just
--   like its UParam counterpart
epwFallbackFail :: EpwFallback store
(/==>) :: Label name -> Lambda (arg, UStore store) ([Operation], UStore store) -> EpwCaseClause store '(name, arg)
infixr 0 /==>

-- | Removes an endpoint from the #code submap
removeEndpoint :: forall store name s. (KnownSymbol name, GetUStoreKey store "code" ~ MText) => Label name -> (UStore store : s) :-> (UStore store : s)

-- | Helper for documenting entrypoints with EPW interface.
class EpwDocumented (entries :: [EntryPointKind])

-- | Make up documentation for given entry points.
--   
--   As result you get a fake contract from which you can later build
--   desired documentation. Although, you may want to add contract name and
--   description first.
epwDocument :: EpwDocumented entries => Rec (EpwCaseClause store) entries -> Lambda () ()
instance Lorentz.Contracts.Upgradeable.EntryPointWise.EpwDocumented '[]
instance (Lorentz.Constraints.NoOperation a, Lorentz.Constraints.NoBigMap a, GHC.TypeLits.KnownSymbol name, Lorentz.Contracts.Upgradeable.EntryPointWise.EpwDocumented es) => Lorentz.Contracts.Upgradeable.EntryPointWise.EpwDocumented ('(name, a) : es)
instance (Lorentz.Contracts.Upgradeable.EntryPointWise.CodeMigrations entries, GHC.TypeLits.KnownSymbol name, Lorentz.Constraints.KnownValue arg, Lorentz.Constraints.NoOperation arg, Lorentz.Constraints.NoBigMap arg) => Lorentz.Contracts.Upgradeable.EntryPointWise.CodeMigrations ((name Lorentz.UParam.?: arg) : entries)
instance Lorentz.Contracts.Upgradeable.EntryPointWise.CodeMigrations '[]


-- | UpgradeableCounter demonstrates the implementation of a simple
--   contract that has upgradeable storage, interface, and implementation.
--   
--   In the first version it stores a Natural and allows to add some value
--   to it or multiply the current value by a certain natural number.
--   
--   The second version changes the type of the stored value to Integer,
--   and instead of providing Mul Natural and Add Natural endpoints, it
--   just allows to increment or decrement the current value.
--   
--   While the contract does not have any advanced functionality, it
--   provides a birds-eye view on all the aspects of the upgradeable
--   contracts concept and serves as an example on how to apply this
--   concept.
module Lorentz.Contracts.UpgradeableCounter
data Parameter (interface :: [EntryPointKind])
Run :: UParam interface -> Parameter
Upgrade :: UpgradeParameters -> Parameter
GetVersion :: View () Natural -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: Natural -> Parameter
EpwApplyMigration :: MigrationScript -> Parameter
EpwSetCode :: ContractCode -> Parameter
EpwFinishUpgrade :: Parameter
data Storage
data Error

-- | Tx sender does not have enough rights to perform this operation.
SenderIsNotAdmin :: Error

-- | Expected version does not match the version of the supplied code.
VersionMismatch :: ("expected" :! Natural, "actual" :! Natural) -> Error

-- | The reuested operation requires the contract to be running but it is
--   paused.
ContractIsPaused :: Error

-- | The reuested operation requires the contract to be paused but it is
--   not.
ContractIsNotPaused :: Error
upgradeableCounterContract :: forall (interface :: [EntryPointKind]). Contract (Parameter interface) Storage
mkEmptyStorage :: Address -> Storage

module Lorentz.Contracts.UpgradeableCounter.V1
type Interface = ["add" ?: Natural, "mul" ?: Natural, "getCounterValue" ?: View () Natural]
version :: Natural
migrate :: MigrationScript

-- | Migrations represent entrypoint-wise upgrades. Each migration puts an
--   implementation of a method to UStore. The contract code itself
--   (<a>epwServe</a>) does not do anything special except for taking these
--   lambdas out of the big map.
migrations :: [MigrationScript]
counterContract :: ContractCode
type UStoreV1 = UStore UStoreTemplate
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounter.V1.UStoreTemplate
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableCounter.V1.UStoreTemplate

module Lorentz.Contracts.UpgradeableCounter.V2
type Interface = ["inc" ?: (), "dec" ?: (), "getCounterValue" ?: View () Integer]
type UStoreV2 = UStore UStoreTemplate
version :: Natural
migrate :: MigrationScript
migrations :: [MigrationScript]
counterContract :: ContractCode
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableCounter.V2.UStoreTemplate
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableCounter.V2.UStoreTemplate


-- | UpgradeableUnsafeLedger demonstrates a real-world use case of an
--   upgradeable contract. Its V1 contains a bug that makes it return an
--   incorrect totalSupply. Fortunately, we can upgrade the contract and
--   fix the bug. This contract does not use entrypoint-wise upgrades.
--   Instead, it upgrades atomically in one transaction. For non-atomic
--   upgrades please see the UpgradeableCounter example.
module Lorentz.Contracts.UpgradeableUnsafeLedger
data Parameter (interface :: [EntryPointKind])
Run :: UParam interface -> Parameter
Upgrade :: UpgradeParameters -> Parameter
GetVersion :: View () Natural -> Parameter
SetAdministrator :: Address -> Parameter
EpwBeginUpgrade :: Natural -> Parameter
EpwApplyMigration :: MigrationScript -> Parameter
EpwSetCode :: ContractCode -> Parameter
EpwFinishUpgrade :: Parameter
data Storage
upgradeableUnsafeLedgerContract :: forall (interface :: [EntryPointKind]). Contract (Parameter interface) Storage
mkEmptyStorage :: Address -> Storage


-- | A buggy implementation of Unsafe ledger, returns balances multiplied
--   by 2
module Lorentz.Contracts.UpgradeableUnsafeLedger.V1
type Interface = ["transfer" ?: TransferParams, "getTotalSupply" ?: View () Natural, "getBalance" ?: View Address (Maybe Natural)]
version :: Natural

-- | Like in UpgradeableCounter, this function populates the empty UStore_
--   with entries and initial values for each field. The result is expected
--   to adhere to V1.UStoreTemplate
migrate :: '[UStore_] :-> '[UStore_]
unsafeLedgerContract :: ContractCode
type UStoreV1 = UStore UStoreTempate
type TransferParams = (Address, Natural)
transfer :: '[TransferParams, UStoreV1] :-> '[([Operation], UStoreV1)]
getTotalSupply :: '[View () Natural, UStoreV1] :-> '[([Operation], UStoreV1)]
instance GHC.Generics.Generic Lorentz.Contracts.UpgradeableUnsafeLedger.V1.UStoreTempate
instance GHC.Classes.Eq Lorentz.Contracts.UpgradeableUnsafeLedger.V1.UStoreTempate


-- | The implementation of Unsafe ledger with V1 balance bug fixed
module Lorentz.Contracts.UpgradeableUnsafeLedger.V2

-- | Storage migration function. Since the storage is the same, there's
--   nothing to migrate
migrate :: '[UStore_] :-> '[UStore_]
version :: Natural

-- | The second version of the UpgradeableUnsafeLedger. Most of the
--   functions are from V1 except for getBalance.
unsafeLedgerContract :: ContractCode

module Lorentz.Contracts.Walker
walkerContract :: Contract Parameter Storage
data Parameter
GoLeft :: Parameter
GoRight :: Parameter
GoUp :: Parameter
GoDown :: Parameter
Boost :: BoostParams -> Parameter
Reset :: IterationId -> Parameter
type Storage = StorageSkeleton StoreTemplate StorageFields
data StorageFields
StorageFields :: Position -> Power -> IterationId -> StorageFields
[pos] :: StorageFields -> Position
[power] :: StorageFields -> Power
[iterId] :: StorageFields -> IterationId
data Position
Position :: Integer -> Integer -> Position
[x] :: Position -> Integer
[y] :: Position -> Integer
data PowerUp
BoostPowerUp :: Integer -> PowerUp
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Walker.StorageFields
instance Data.Default.Class.Default Lorentz.Contracts.Walker.StorageFields
instance GHC.Generics.Generic Lorentz.Contracts.Walker.StorageFields
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Walker.StoreTemplate
instance GHC.Generics.Generic Lorentz.Contracts.Walker.StoreTemplate
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Walker.PowerUp
instance GHC.Generics.Generic Lorentz.Contracts.Walker.PowerUp
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Walker.Position
instance Data.Default.Class.Default Lorentz.Contracts.Walker.Position
instance GHC.Generics.Generic Lorentz.Contracts.Walker.Position
instance GHC.Classes.Eq Lorentz.Contracts.Walker.Position
instance Michelson.Typed.Haskell.Value.IsoValue Lorentz.Contracts.Walker.Parameter
instance GHC.Generics.Generic Lorentz.Contracts.Walker.Parameter
